const questions = [
  {
    id: 'palindrome-check',
    name: 'Palindrome Check',
    category: 'Strings',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty string and that returns a boolean\n  representing whether the string is a palindrome.\n</p>\n<p>\n  A palindrome is defined as a string that\'s written the same forward and\n  backward. Note that single-character strings are palindromes.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "abcdcba"\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue <span class="CodeEditor-promptComment">// it\'s written the same forward and backward</span>\n</pre>\n</div>',
    hints: [
      '<p>\nStart by building the input string in reverse order and comparing this newly built string to the input string. Can you do this without using string concatenations?\n</p>\n',
      "\n<p>\nCan you optimize your algorithm by using recursion? What are the implications of recursion on an algorithm's space-time complexity analysis?\n</p>\n",
      '\n<p>\nGo back to an iterative solution and try using pointers to solve this problem: start with a pointer at the first index of the string and a pointer at the final index of the string. What can you do from there?\n</p>',
    ],
    customInputVars: [
      {
        name: 'string',
        example: 'abcdcba',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function isPalindrome(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.isPalindrome = isPalindrome;\n',
      solutions: [
        "// O(n^2) time | O(n) space\nfunction isPalindrome(string) {\n  let reversedString = '';\n  for (let i = string.length - 1; i >= 0; i--) {\n    reversedString += string[i];\n  }\n  return string === reversedString;\n}\n\nexports.isPalindrome = isPalindrome;\n",
        "// O(n) time | O(n) space\nfunction isPalindrome(string) {\n  const reversedChars = [];\n  for (let i = string.length - 1; i >= 0; i--) {\n    reversedChars.push(string[i]);\n  }\n  return string === reversedChars.join('');\n}\n\nexports.isPalindrome = isPalindrome;\n",
        '// O(n) time | O(n) space\nfunction isPalindrome(string, i = 0) {\n  const j = string.length - 1 - i;\n  return i >= j ? true : string[i] === string[j] && isPalindrome(string, i + 1);\n}\n\nexports.isPalindrome = isPalindrome;\n',
        '// O(n) time | O(1) space\nfunction isPalindrome(string) {\n  let leftIdx = 0;\n  let rightIdx = string.length - 1;\n  while (leftIdx < rightIdx) {\n    if (string[leftIdx] !== string[rightIdx]) return false;\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n\nexports.isPalindrome = isPalindrome;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.isPalindrome('abcdcba')).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.isPalindrome('abcdcba')).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input string',
    tests: [
      { string: 'abcdcba' },
      { string: 'a' },
      { string: 'ab' },
      { string: 'aba' },
      { string: 'abb' },
      { string: 'abba' },
      { string: 'abcdefghhgfedcba' },
      { string: 'abcdefghihgfedcba' },
      { string: 'abcdefghihgfeddcba' },
    ],
  },
  {
    id: 'caesar-cipher-encryptor',
    name: 'Caesar Cipher Encryptor',
    category: 'Strings',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Given a non-empty string of lowercase letters and a non-negative integer\n  representing a key, write a function that returns a new string obtained by\n  shifting every letter in the input string by k positions in the alphabet,\n  where k is the key.\n</p>\n<p>\n  Note that letters should "wrap" around the alphabet; in other words, the\n  letter <span>z</span> shifted by one returns the letter <span>a</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "xyz"\n<span class="CodeEditor-promptParameter">key</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"zab"\n</pre>\n</div>',
    hints: [
      "<p>\nMost languages have built-in functions that give you the Unicode value of a character as well as the character corresponding to a Unicode value. Consider using such functions to determine which letters the input string's letters should be mapped to.\n</p>\n",
      "\n<p>\nTry creating your own mapping of letters to codes. In other words, try associating each letter in the alphabet with a specific number - its position in the alphabet, for instance - and using that to determine which letters the input string's letters should be mapped to.\n</p>\n",
      '\n<p>\nHow do you handle cases where a letter gets shifted to a position that requires wrapping around the alphabet? What about cases where the key is very large and causes multiple wrappings around the alphabet? The modulo operator should be your friend here.\n</p>',
    ],
    customInputVars: [
      {
        name: 'string',
        example: 'xyz',
        schema: { minLength: 1, pattern: '^[a-z]+$', type: 'string' },
      },
      { name: 'key', example: 2, schema: { minimum: 0, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function caesarCipherEncryptor(string, key) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.caesarCipherEncryptor = caesarCipherEncryptor;\n',
      solutions: [
        "// O(n) time | O(n) space\nfunction caesarCipherEncryptor(string, key) {\n  const newLetters = [];\n  const newKey = key % 26;\n  for (const letter of string) {\n    newLetters.push(getNewLetter(letter, newKey));\n  }\n  return newLetters.join('');\n}\n\nfunction getNewLetter(letter, key) {\n  const newLetterCode = letter.charCodeAt() + key;\n  return newLetterCode <= 122\n    ? String.fromCharCode(newLetterCode)\n    : String.fromCharCode(96 + (newLetterCode % 122));\n}\n\nexports.caesarCipherEncryptor = caesarCipherEncryptor;\n",
        "// O(n) time | O(n) space\nfunction caesarCipherEncryptor(string, key) {\n  const newLetters = [];\n  const newKey = key % 26;\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  for (const letter of string) {\n    newLetters.push(getNewLetter(letter, newKey, alphabet));\n  }\n  return newLetters.join('');\n}\n\nfunction getNewLetter(letter, key, alphabet) {\n  const newLetterCode = alphabet.indexOf(letter) + key;\n  return alphabet[newLetterCode % 26];\n}\n\nexports.caesarCipherEncryptor = caesarCipherEncryptor;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.caesarCipherEncryptor('xyz', 2)).to.deep.equal('zab');\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.caesarCipherEncryptor('xyz', 2)).to.deep.equal('zab');\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input string',
    tests: [
      { key: 2, string: 'xyz' },
      { key: 0, string: 'abc' },
      { key: 3, string: 'abc' },
      { key: 5, string: 'xyz' },
      { key: 26, string: 'abc' },
      { key: 52, string: 'abc' },
      { key: 57, string: 'abc' },
      { key: 25, string: 'xyz' },
      { key: 25, string: 'iwufqnkqkqoolxzzlzihqfm' },
      { key: 52, string: 'ovmqkwtujqmfkao' },
      { key: 7, string: 'mvklahvjcnbwqvtutmfafkwiuagjkzmzwgf' },
      {
        key: 15,
        string: 'kjwmntauvjjnmsagwgawkagfuaugjhawgnawgjhawjgawbfawghesh',
      },
    ],
  },
  {
    id: 'longest-palindromic-substring',
    name: 'Longest Palindromic Substring',
    category: 'Strings',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that, given a string, returns its longest palindromic\n  substring.\n</p>\n<p>\n  A palindrome is defined as a string that\'s written the same forward and\n  backward. Note that single-character strings are palindromes.\n</p>\n<p>You can assume that there will only be one longest palindromic substring.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "abaxyzzyxf"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"xyzzyx"\n</pre>\n</div>',
    hints: [
      '<p>\nTry generating all possible substrings of the input string and checking for their palindromicity. What is the runtime of the isPalindrome check? What is the total runtime of this approach?\n</p>\n',
      '\n<p>\nRecognize that a palindrome is a string that is symmetrical with respect to its center, which can either be a character (in the case of odd-length palindromes) or an empty string (in the case of even-length palindromes). Thus, you can check the palindromicity of a string by simply expanding from its center and making sure that characters on both sides are indeed mirrored.\n</p>\n',
      '\n<p>\nTraverse the input string, and at each index, apply the logic mentioned in Hint #2. What does this accomplish? Is the runtime of this approach better?\n</p>',
    ],
    customInputVars: [
      { name: 'string', example: 'abaxyzzyxf', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function longestPalindromicSubstring(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestPalindromicSubstring = longestPalindromicSubstring;\n',
      solutions: [
        "// O(n^3) time | O(n) space\nfunction longestPalindromicSubstring(string) {\n  let longest = '';\n  for (let i = 0; i < string.length; i++) {\n    for (let j = i; j < string.length; j++) {\n      const substring = string.slice(i, j + 1);\n      if (substring.length > longest.length && isPalindrome(substring)) {\n        longest = substring;\n      }\n    }\n  }\n  return longest;\n}\n\nfunction isPalindrome(string) {\n  let leftIdx = 0;\n  let rightIdx = string.length - 1;\n  while (leftIdx < rightIdx) {\n    if (string[leftIdx] !== string[rightIdx]) return false;\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n\nexports.longestPalindromicSubstring = longestPalindromicSubstring;\n",
        '// O(n^2) time | O(n) space\nfunction longestPalindromicSubstring(string) {\n  let currentLongest = [0, 1];\n  for (let i = 1; i < string.length; i++) {\n    const odd = getLongestPalindromeFrom(string, i - 1, i + 1);\n    const even = getLongestPalindromeFrom(string, i - 1, i);\n    const longest = odd[1] - odd[0] > even[1] - even[0] ? odd : even;\n    currentLongest =\n      currentLongest[1] - currentLongest[0] > longest[1] - longest[0] ? currentLongest : longest;\n  }\n  return string.slice(currentLongest[0], currentLongest[1]);\n}\n\nfunction getLongestPalindromeFrom(string, leftIdx, rightIdx) {\n  while (leftIdx >= 0 && rightIdx < string.length) {\n    if (string[leftIdx] !== string[rightIdx]) break;\n    leftIdx--;\n    rightIdx++;\n  }\n  return [leftIdx + 1, rightIdx];\n}\n\nexports.longestPalindromicSubstring = longestPalindromicSubstring;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.longestPalindromicSubstring('abaxyzzyxf')).to.deep.equal('xyzzyx');\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.longestPalindromicSubstring('abaxyzzyxf')).to.deep.equal('xyzzyx');\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the length of the input string',
    tests: [
      { string: 'abaxyzzyxf' },
      { string: 'a' },
      { string: "it's highnoon" },
      { string: 'noon high it is' },
      { string: "abccbait's highnoon" },
      { string: 'abcdefgfedcbazzzzzzzzzzzzzzzzzzzz' },
      { string: 'abcdefgfedcba' },
      { string: 'abcdefghfedcbaa' },
      { string: 'abcdefggfedcba' },
      { string: 'zzzzzzz2345abbbba5432zzbbababa' },
      { string: 'z234a5abbbba54a32z' },
      { string: 'z234a5abbba54a32z' },
      { string: 'ab12365456321bb' },
      { string: 'aca' },
    ],
  },
  {
    id: 'longest-substring-without-duplication',
    name: 'Longest Substring Without Duplication',
    category: 'Strings',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a string and returns its longest substring\n  without duplicate characters.\n</p>\n<p>You can assume that there will only be one longest substring without duplication.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "clementisacap"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"mentisac"\n</pre>\n</div>',
    hints: [
      '<p>\nTry traversing the input string and storing the last position at which you see each character in a hash table. How can this help you solve the given problem?\n</p>\n',
      '\n<p>\nAs you traverse the input string, keep track of a starting index variable. This variable, as its name suggests, should represent the most recent index from which you could start a substring with no duplicate characters, ending at your current index. Use the hash table mentioned in Hint #1 to update this variable correctly, and update the longest substring as you go.\n</p>',
    ],
    customInputVars: [
      { name: 'string', example: 'clementisacap', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function longestSubstringWithoutDuplication(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestSubstringWithoutDuplication = longestSubstringWithoutDuplication;\n',
      solutions: [
        '// O(n) time | O(min(n, a)) space\nfunction longestSubstringWithoutDuplication(string) {\n  const lastSeen = {};\n  let longest = [0, 1];\n  let startIdx = 0;\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char in lastSeen) {\n      startIdx = Math.max(startIdx, lastSeen[char] + 1);\n    }\n    if (longest[1] - longest[0] < i + 1 - startIdx) {\n      longest = [startIdx, i + 1];\n    }\n    lastSeen[char] = i;\n  }\n  return string.slice(longest[0], longest[1]);\n}\n\nexports.longestSubstringWithoutDuplication = longestSubstringWithoutDuplication;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestSubstringWithoutDuplication('clementisacap'))\n    .to.deep.equal('mentisac');\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestSubstringWithoutDuplication('clementisacap'))\n    .to.deep.equal('mentisac');\n});\n",
    },
    bigO: 'O(n) time | O(min(n, a)) space - where n is the length of the input string and a is the length of the character alphabet represented in the input string',
    tests: [
      { string: 'clementisacap' },
      { string: 'a' },
      { string: 'abc' },
      { string: 'abcb' },
      { string: 'abcdeabcdefc' },
      { string: 'abccdeaabbcddef' },
      { string: 'abacacacaaabacaaaeaaafa' },
      { string: 'abcdabcef' },
      { string: 'abcbde' },
      { string: 'clementisanarm' },
    ],
  },
  {
    id: 'underscorify-substring',
    name: 'Underscorify Substring',
    category: 'Strings',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in two strings: a main string and a potential\n  substring of the main string. The function should return a version of the main\n  string with every instance of the substring in it wrapped between underscores.\n</p>\n<p>\n  If two or more instances of the substring in the main string overlap each\n  other or sit side by side, the underscores relevant to these substrings should\n  only appear on the far left of the leftmost substring and on the far right of\n  the rightmost substring. If the main string doesn\'t contain the other string\n  at all, the function should return the main string intact.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "testthis is a testtest to see if testestest it works"\n<span class="CodeEditor-promptParameter">substring</span> = "test"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"_test_this is a _testtest_ to see if _testestest_ it works"\n</pre>\n</div>',
    hints: [
      "<p>\nThe first thing you need to do to solve this question is to get the locations of all instances of the substring in the main string. Try traversing the main string one character at a time and calling whatever substring-matching function is built into the language you're working in. Store a 2D array of locations, where each subarray holds the starting and ending indices of a specific instance of the substring in the main string.\n</p>\n",
      '\n<p>\nThe second thing you need to do is to "collapse" the 2D array mentioned in Hint #1. In essence, you need to merge the locations of substrings that overlap each other or sit next to each other. Traverse the 2D array mentioned in Hint #1 and build a new 2D array that holds these "collapsed" locations.\n</p>\n',
      '\n<p>\nFinally, you need to create a new string with underscores added in the correct positions. Construct this new string by traversing the main string and the 2D array mentioned in Hint #2 at the same time. You might have to keep track of when you are "in between" underscores in order to correctly traverse the 2D array.\n</p>',
    ],
    customInputVars: [
      {
        name: 'string',
        example: 'testthis is a testtest to see if testestest it works',
        schema: { type: 'string' },
      },
      { name: 'substring', example: 'test', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function underscorifySubstring(string, substring) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.underscorifySubstring = underscorifySubstring;\n',
      solutions: [
        "// Average case: O(n + m) | O(n) space - where n is the length\n// of the main string and m is the length of the substring\nfunction underscorifySubstring(string, substring) {\n  const locations = collapse(getLocations(string, substring));\n  return underscorify(string, locations);\n}\n\nfunction getLocations(string, substring) {\n  const locations = [];\n  let startIdx = 0;\n  while (startIdx < string.length) {\n    const nextIdx = string.indexOf(substring, startIdx);\n    if (nextIdx !== -1) {\n      locations.push([nextIdx, nextIdx + substring.length]);\n      startIdx = nextIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return locations;\n}\n\nfunction collapse(locations) {\n  if (!locations.length) return locations;\n  const newLocations = [locations[0]];\n  let previous = newLocations[0];\n  for (let i = 1; i < locations.length; i++) {\n    const current = locations[i];\n    if (current[0] <= previous[1]) {\n      previous[1] = current[1];\n    } else {\n      newLocations.push(current);\n      previous = current;\n    }\n  }\n  return newLocations;\n}\n\nfunction underscorify(string, locations) {\n  let locationsIdx = 0;\n  let stringIdx = 0;\n  let inBetweenUnderscores = false;\n  const finalChars = [];\n  let i = 0;\n  while (stringIdx < string.length && locationsIdx < locations.length) {\n    if (stringIdx === locations[locationsIdx][i]) {\n      finalChars.push('_');\n      inBetweenUnderscores = !inBetweenUnderscores;\n      if (!inBetweenUnderscores) locationsIdx++;\n      i = i === 1 ? 0 : 1;\n    }\n    finalChars.push(string[stringIdx]);\n    stringIdx++;\n  }\n  if (locationsIdx < locations.length) {\n    finalChars.push('_');\n  } else if (stringIdx < string.length) {\n    finalChars.push(string.slice(stringIdx));\n  }\n  return finalChars.join('');\n}\n\nexports.underscorifySubstring = underscorifySubstring;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.underscorifySubstring('testthis is a testtest to see if testestest it works', 'test'),\n    )\n    .to.deep.equal('_test_this is a _testtest_ to see if _testestest_ it works');\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.underscorifySubstring('testthis is a testtest to see if testestest it works', 'test'),\n    )\n    .to.deep.equal('_test_this is a _testtest_ to see if _testestest_ it works');\n});\n",
    },
    bigO: 'Average case: O(n + m) | O(n) space - where n is the length of the main string and m is the length of the substring',
    tests: [
      {
        string: 'testthis is a testtest to see if testestest it works',
        substring: 'test',
      },
      { string: 'this is a test to see if it works', substring: 'test' },
      { string: 'test this is a test to see if it works', substring: 'test' },
      { string: 'testthis is a test to see if it works', substring: 'test' },
      {
        string: 'testthis is a testest to see if testestes it works',
        substring: 'test',
      },
      {
        string: 'this is a test to see if it works and test',
        substring: 'test',
      },
      {
        string: 'this is a test to see if it works and test',
        substring: 'bfjawkfja',
      },
      { string: 'ttttttttttttttbtttttctatawtatttttastvb', substring: 'ttt' },
      { string: 'tzttztttz', substring: 'ttt' },
      { string: 'abababababababababababababaababaaabbababaa', substring: 'a' },
      {
        string: 'abcabcabcabcabcabcabcabcabcabcabcabcabcabc',
        substring: 'abc',
      },
    ],
  },
  {
    id: 'pattern-matcher',
    name: 'Pattern Matcher',
    category: 'Strings',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given two non-empty strings. The first one is a pattern consisting of\n  only <span>"x"</span>s and / or <span>"y"</span>s; the other one is a normal\n  string of alphanumeric characters. Write a function that checks whether the\n  normal string matches the pattern.\n</p>\n<p>\n  A string <span>S0</span> is said to match a pattern if replacing all\n  <span>"x"</span>s in the pattern with some non-empty substring\n  <span>S1</span> of <span>S0</span> and replacing all <span>"y"</span>s in the\n  pattern with some non-empty substring <span>S2</span> of\n  <span>S0</span> yields the same string <span>S0</span>.\n</p>\n<p>\n  If the input string doesn\'t match the input pattern, the function should\n  return an empty array; otherwise, it should return an array holding the\n  strings <span>S1</span> and <span>S2</span> that represent\n  <span>"x"</span> and <span>"y"</span> in the normal string, in that order. If\n  the pattern doesn\'t contain any <span>"x"</span>s or <span>"y"</span>s, the\n  respective letter should be represented by an empty string in the final array\n  that you return.\n</p>\n<p>\n  You can assume that there will never be more than one pair of strings\n  <span>S1</span> and <span>S2</span> that appropriately represent\n  <span>"x"</span> and <span>"y"</span> in the normal string.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">pattern</span> = "xxyxxy"\n<span class="CodeEditor-promptParameter">string</span> = "gogopowerrangergogopowerranger"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["go", "powerranger"]\n</pre>\n</div>',
    hints: [
      '<p>\nStart by checking if the pattern starts with an "x". If it doesn\'t, consider generating a new pattern that swaps all "x"s for "y"s and vice versa; this might greatly simplify the rest of your algorithm. Make sure to keep track of whether or not you do this swap, as your final answer will be affected by it.\n</p>\n',
      '\n<p>\nUse a hash table to store the number of "x"s and "y"s that appear in the pattern, and keep track of the position of the first "y". Knowing how many "x"s and "y"s appear in the pattern, paired with the length of the main string which you have access to, will allow you to quickly test out various possible lengths for "x" and "y". Knowing where the first "y" appears in the pattern will allow you to actually generate potential substrings.\n</p>\n',
      '\n<p>\nTraverse the main string and try different combinations of substrings that could represent "x" and "y". For each potential combination, map the new pattern mentioned in Hint #1 and see if it matches the main string.\n</p>',
    ],
    customInputVars: [
      {
        name: 'pattern',
        example: 'xxyxxy',
        schema: { minLength: 1, type: 'string' },
      },
      {
        name: 'string',
        example: 'gogopowerrangergogopowerranger',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function patternMatcher(pattern, string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.patternMatcher = patternMatcher;\n',
      solutions: [
        "// O(n^2 + m) time | O(n + m) space\nfunction patternMatcher(pattern, string) {\n  if (pattern.length > string.length) return [];\n  const newPattern = getNewPattern(pattern);\n  const didSwitch = newPattern[0] !== pattern[0];\n  const counts = {x: 0, y: 0};\n  const firstYPos = getCountsAndFirstYPos(newPattern, counts);\n  if (counts['y'] !== 0) {\n    for (let lenOfX = 1; lenOfX < string.length; lenOfX++) {\n      const lenOfY = (string.length - lenOfX * counts['x']) / counts['y'];\n      if (lenOfY <= 0 || lenOfY % 1 !== 0) continue;\n      const yIdx = firstYPos * lenOfX;\n      const x = string.slice(0, lenOfX);\n      const y = string.slice(yIdx, yIdx + lenOfY);\n      const potentialMatch = newPattern.map(char => (char === 'x' ? x : y));\n      if (string === potentialMatch.join('')) {\n        return !didSwitch ? [x, y] : [y, x];\n      }\n    }\n  } else {\n    const lenOfX = string.length / counts['x'];\n    if (lenOfX % 1 === 0) {\n      const x = string.slice(0, lenOfX);\n      const potentialMatch = newPattern.map(char => (char === 'x' ? x : ''));\n      if (string === potentialMatch.join('')) {\n        return !didSwitch ? [x, ''] : ['', x];\n      }\n    }\n  }\n  return [];\n}\n\nfunction getNewPattern(pattern) {\n  const patternLetters = pattern.split('');\n  if (pattern[0] === 'x') {\n    return patternLetters;\n  } else {\n    return patternLetters.map(char => (char === 'y' ? 'x' : 'y'));\n  }\n}\n\nfunction getCountsAndFirstYPos(pattern, counts) {\n  let firstYPos = null;\n  for (let i = 0; i < pattern.length; i++) {\n    const char = pattern[i];\n    counts[char]++;\n    if (char === 'y' && firstYPos === null) firstYPos = i;\n  }\n  return firstYPos;\n}\n\nexports.patternMatcher = patternMatcher;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.patternMatcher('xxyxxy', 'gogopowerrangergogopowerranger'))\n    .to.deep.equal(['go', 'powerranger']);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.patternMatcher('xxyxxy', 'gogopowerrangergogopowerranger'))\n    .to.deep.equal(['go', 'powerranger']);\n});\n",
    },
    bigO: 'O(n^2 + m) time | O(n + m) space - where n is the length of the main string and m is the length of the pattern',
    tests: [
      { pattern: 'xxyxxy', string: 'gogopowerrangergogopowerranger' },
      { pattern: 'xyxy', string: 'abab' },
      { pattern: 'yxyx', string: 'abab' },
      { pattern: 'yxx', string: 'yomama' },
      { pattern: 'yyxyyx', string: 'gogopowerrangergogopowerranger' },
      { pattern: 'xyx', string: 'thisshouldobviouslybewrong' },
      { pattern: 'xxxx', string: 'testtesttesttest' },
      { pattern: 'yyyy', string: 'testtesttesttest' },
      { pattern: 'xxyxyy', string: 'testtestwrongtestwrongtest' },
      {
        pattern: 'xyxxxyyx',
        string:
          'baddaddoombaddadoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom',
      },
      {
        pattern: 'yxyyyxxy',
        string:
          'baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom',
      },
      {
        pattern: 'xyxxxyyx',
        string:
          'baddaddoombaddaddoomibaddaddoombaddaddoombaddaddoombaddaddoomibaddaddoomibaddaddoom',
      },
    ],
  },
  {
    id: 'group-anagrams',
    name: 'Group Anagrams',
    category: 'Strings',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of strings and groups anagrams together.\n</p>\n<p>\n  Anagrams are strings made up of exactly the same letters, where order doesn\'t\n  matter. For example, <span>"cinema"</span> and <span>"iceman"</span> are\n  anagrams; similarly, <span>"foo"</span> and <span>"ofo"</span> are anagrams.\n</p>\n<p>\n  Your function should return a list of anagram groups in no particular order.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">words</span> = ["yo", "act", "flop", "tac", "foo", "cat", "oy", "olfp"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[["yo", "oy"], ["flop", "olfp"], ["act", "tac", "cat"], ["foo"]]\n</pre>\n</div>',
    hints: [
      "<p>\nTry rearranging every input string such that each string's letters are ordered in alphabetical order. What can you do with the resulting strings?\n</p>\n",
      '\n<p>\nFor any two of the resulting strings mentioned in Hint #1 that are equal to each other, their original strings (with their letters in normal order) must be anagrams. Realizing this, you could bucket all of these resulting strings together, all the while keeping track of their original strings, to find the groups of anagrams.\n</p>\n',
      '\n<p>\nCan you simply store the resulting strings mentioned in Hint #1 in a hash table and find the groups of anagrams using this hash table?\n</p>',
    ],
    customInputVars: [
      {
        name: 'words',
        example: ['yo', 'act', 'flop', 'tac', 'foo', 'cat', 'oy', 'olfp'],
        schema: { items: { type: 'string' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function groupAnagrams(words) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.groupAnagrams = groupAnagrams;\n',
      solutions: [
        "// O(w * n * log(n) + n * w * log(w)) time | O(wn) space - where w is the number of words and\n// n is the length of the longest word\nfunction groupAnagrams(words) {\n  if (words.length === 0) return [];\n\n  const sortedWords = words.map(word => word.split('').sort().join(''));\n  const indices = [...Array(words.length).keys()];\n  indices.sort((a, b) => {\n    if (sortedWords[a] < sortedWords[b]) return -1;\n    if (sortedWords[a] > sortedWords[b]) return 1;\n    return 0;\n  });\n\n  const result = [];\n  let currentAnagramGroup = [];\n  let currentAnagram = sortedWords[indices[0]];\n  for (const index of indices) {\n    const word = words[index];\n    const sortedWord = sortedWords[index];\n\n    if (sortedWord === currentAnagram) {\n      currentAnagramGroup.push(word);\n      continue;\n    }\n\n    result.push(currentAnagramGroup);\n    currentAnagramGroup = [word];\n    currentAnagram = sortedWord;\n  }\n\n  result.push(currentAnagramGroup);\n\n  return result;\n}\n\nexports.groupAnagrams = groupAnagrams;\n",
        "// O(w * n * log(n)) time | O(wn) space - where w is the number of words and n is the length of the longest word\nfunction groupAnagrams(words) {\n  const anagrams = {};\n  for (const word of words) {\n    const sortedWord = word.split('').sort().join('');\n    if (sortedWord in anagrams) {\n      anagrams[sortedWord].push(word);\n    } else {\n      anagrams[sortedWord] = [word];\n    }\n  }\n  return Object.values(anagrams);\n}\n\nexports.groupAnagrams = groupAnagrams;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const words = ['yo', 'act', 'flop', 'tac', 'foo', 'cat', 'oy', 'olfp'];\n  const expected = [['yo', 'oy'], ['flop', 'olfp'], ['act', 'tac', 'cat'], ['foo']];\n  const output = program.groupAnagrams(words).map(anagramGroup => anagramGroup.sort());\n\n  compare(expected, output);\n});\n\nfunction compare(expected, output) {\n  chai.expect(output.length).to.deep.equal(expected.length);\n  for (const group of expected) {\n    chai.expect(output).to.deep.include(group.sort());\n  }\n}\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const words = ['yo', 'act', 'flop', 'tac', 'foo', 'cat', 'oy', 'olfp'];\n  const expected = [['yo', 'oy'], ['flop', 'olfp'], ['act', 'tac', 'cat'], ['foo']];\n  const output = program.groupAnagrams(words).map(anagramGroup => anagramGroup.sort());\n\n  compare(expected, output);\n});\n\nfunction compare(expected, output) {\n  chai.expect(output.length).to.deep.equal(expected.length);\n  for (const group of expected) {\n    chai.expect(output).to.deep.include(group.sort());\n  }\n}\n",
    },
    bigO: 'O(w * n * log(n)) time | O(wn) space - where w is the number of words and n is the length of the longest word',
    tests: [
      { words: ['yo', 'act', 'flop', 'tac', 'foo', 'cat', 'oy', 'olfp'] },
      { words: [] },
      { words: ['test'] },
      { words: ['abc', 'dabd', 'bca', 'cab', 'ddba'] },
      { words: ['abc', 'cba', 'bca'] },
      { words: ['zxc', 'asd', 'weq', 'sda', 'qwe', 'xcz'] },
      { words: ['cinema', 'a', 'flop', 'iceman', 'meacyne', 'lofp', 'olfp'] },
      { words: ['abc', 'abe', 'abf', 'abg'] },
      { words: ['aaa', 'a'] },
      { words: ['bob', 'boo'] },
      { words: ['ill', 'duh'] },
      { words: ['yo', 'oy', 'zn'] },
      { words: ['yyo', 'yo'] },
      { words: ['aca', 'bba'] },
    ],
  },
  {
    id: 'smallest-substring-containing',
    name: 'Smallest Substring Containing',
    category: 'Strings',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  You\'re given two non-empty strings: a big string and a small string. Write a\n  function that returns the smallest substring in the big string that contains\n  all of the small string\'s characters.\n</p>\n<p>\n  Note that:\n</p>\n<ul>\n  <li>\n    The substring can contain other characters not found in the small string.\n  </li>\n  <li>\n    The characters in the substring don\'t have to be in the same order as they\n    appear in the small string.\n  </li>\n  <li>\n    If the small string has duplicate characters, the substring has to contain\n    those duplicate characters (it can also contain more, but not fewer).\n  </li>\n</ul>\n<p>\n  You can assume that there will only be one relevant smallest substring.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">bigString</span> = "abcd$ef$axb$c$"\n<span class="CodeEditor-promptParameter">smallString</span> = "$$abf"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"f$axb$"\n</pre>\n</div>',
    hints: [
      "<p>\nTry storing all of the small string's character counts in a hash table where each character maps to the number of times that it appears in the small string.\n</p>\n",
      '\n<p>\nTry using two pointers (a left pointer and a right pointer) to traverse through the big string. How can this help you find the relevant smallest substring?\n</p>\n',
      '\n<p>\nWith the two pointers mentioned in Hint #2, move the right pointer to the right in the big string, keeping track of all the characters you visit in a hash table identical to the one mentioned in Hint #1, until you\'ve found all of the characters contained in the small string. At that point, move the left pointer to the right in the big string, keeping track of all the characters you "lose", and stop once you no longer have all of the small string\'s characters in between the left and right pointers. Then, repeat the process by moving the right pointer forward and implementing the same logic described in this Hint.\n</p>',
    ],
    customInputVars: [
      {
        name: 'bigString',
        example: 'abcd$ef$axb$c$',
        schema: { minLength: 1, type: 'string' },
      },
      {
        name: 'smallString',
        example: '$$abf',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function smallestSubstringContaining(bigString, smallString) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.smallestSubstringContaining = smallestSubstringContaining;\n',
      solutions: [
        "// O(b + s) time | O(b + s) space - where b is the length of the big\n// input string and s is the length of the small input string\nfunction smallestSubstringContaining(bigString, smallString) {\n  const targetCharCounts = getCharCounts(smallString);\n  const substringBounds = getSubstringBounds(bigString, targetCharCounts);\n  return getStringFromBounds(bigString, substringBounds);\n}\n\nfunction getCharCounts(string) {\n  const charCounts = {};\n  for (const char of string) {\n    increaseCharCount(char, charCounts);\n  }\n  return charCounts;\n}\n\nfunction getSubstringBounds(string, targetCharCounts) {\n  let substringBounds = [0, Infinity];\n  const substringCharCounts = {};\n  const numUniqueChars = Object.keys(targetCharCounts).length;\n  let numUniqueCharsDone = 0;\n  let leftIdx = 0;\n  let rightIdx = 0;\n  // Move the rightIdx to the right in the string until you've counted\n  // all of the target characters enough times.\n  while (rightIdx < string.length) {\n    const rightChar = string[rightIdx];\n    if (!(rightChar in targetCharCounts)) {\n      rightIdx++;\n      continue;\n    }\n    increaseCharCount(rightChar, substringCharCounts);\n    if (substringCharCounts[rightChar] === targetCharCounts[rightChar]) {\n      numUniqueCharsDone++;\n    }\n    // Move the leftIdx to the right in the string until you no longer\n    // have enough of the target characters in between the leftIdx and\n    // the rightIdx. Update the substringBounds accordingly.\n    while (numUniqueCharsDone === numUniqueChars && leftIdx <= rightIdx) {\n      substringBounds = getCloserBounds(leftIdx, rightIdx, substringBounds[0], substringBounds[1]);\n      const leftChar = string[leftIdx];\n      if (!(leftChar in targetCharCounts)) {\n        leftIdx++;\n        continue;\n      }\n      if (substringCharCounts[leftChar] === targetCharCounts[leftChar]) {\n        numUniqueCharsDone--;\n      }\n      decreaseCharCount(leftChar, substringCharCounts);\n      leftIdx++;\n    }\n    rightIdx++;\n  }\n  return substringBounds;\n}\n\nfunction getCloserBounds(idx1, idx2, idx3, idx4) {\n  return idx2 - idx1 < idx4 - idx3 ? [idx1, idx2] : [idx3, idx4];\n}\n\nfunction getStringFromBounds(string, bounds) {\n  const [start, end] = bounds;\n  if (end === Infinity) return '';\n  return string.slice(start, end + 1);\n}\n\nfunction increaseCharCount(char, charCounts) {\n  charCounts[char] = (charCounts[char] || 0) + 1;\n}\n\nfunction decreaseCharCount(char, charCounts) {\n  charCounts[char]--;\n}\n\nexports.smallestSubstringContaining = smallestSubstringContaining;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const bigString = 'abcd$ef$axb$c$';\n  const smallString = '$$abf';\n  const expected = 'f$axb$';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const bigString = 'abcd$ef$axb$c$';\n  const smallString = '$$abf';\n  const expected = 'f$axb$';\n  chai.expect(program.smallestSubstringContaining(bigString, smallString)).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(b + s) time | O(b + s) space - where b is the length of the big input string and s is the length of the small input string',
    tests: [
      { bigString: 'abcd$ef$axb$c$', smallString: '$$abf' },
      { bigString: 'abcdef', smallString: 'fa' },
      { bigString: 'abcdef', smallString: 'd' },
      { bigString: 'abcdefghijklmnopqrstuvwxyz', smallString: 'aajjttwwxxzz' },
      {
        bigString: 'abzacdwejxjftghiwjtklmnopqrstuvwxyz',
        smallString: 'aajjttwwxxzz',
      },
      {
        bigString: 'abzacdwejxjfxztghiwjtklmnopqrstuvwxyz',
        smallString: 'aajjttwwxxzz',
      },
      { bigString: 'aaaa+a$+aaa++$+++++++aaa', smallString: 'a+$aaAaaaa$++' },
      {
        bigString: 'a$fuu+afff+affaffa+a$Affab+a+a+$a$',
        smallString: 'a+$aaAaaaa$++',
      },
      {
        bigString: 'a$fuu+afff+affaffa+a$Affab+a+a+$a$bccgtt+aaaacA+++aaa$',
        smallString: 'a+$aaAaaaa$++',
      },
      {
        bigString: '145624356128828193236336541277356789901',
        smallString: '123',
      },
      {
        bigString: '1456243561288281932363365412356789901!',
        smallString: '123!',
      },
      {
        bigString: '14562435612!88281932363365$412356789901',
        smallString: '$123!',
      },
      {
        bigString: '14562435612!88281932363365$412356789901',
        smallString: '#!123!',
      },
      {
        bigString: '14562435612!88281932363365$412356789901',
        smallString: '#!333333123!',
      },
      {
        bigString: '14562435612z!8828!193236!336!5$41!23!5!6789901#',
        smallString: '#!2z',
      },
      {
        bigString: '14562435612z!8828!193236!336!5$41!23!5!6789901#z2!',
        smallString: '#!2z',
      },
    ],
  },
  {
    id: 'run-length-encoding',
    name: 'Run-Length Encoding',
    category: 'Strings',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty string and returns its run-length\n  encoding.\n</p>\n<p>\n  From Wikipedia, "run-length encoding is a form of lossless data compression in\n  which runs of data are stored as a single data value and count, rather than as\n  the original run." For this problem, a run of data is any sequence of\n  consecutive, identical characters. So the run <span>"AAA"</span> would be\n  run-length-encoded as <span>"3A"</span>.\n</p>\n<p>\n  To make things more complicated, however, the input string can contain all\n  sorts of special characters, including numbers. And since encoded data must be\n  decodable, this means that we can\'t naively run-length-encode long runs. For\n  example, the run <span>"AAAAAAAAAAAA"</span> (12 <span>A</span>s), can\'t\n  naively be encoded as <span>"12A"</span>, since this string can be decoded as\n  either <span>"AAAAAAAAAAAA"</span> or <span>"1AA"</span>. Thus, long runs (runs\n  of 10 or more characters) should be encoded in a split fashion; the\n  aforementioned run should be encoded as <span>"9A3A"</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "AAAAAAAAAAAAABBCCCCDD"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"9A4A2B4C2D"\n</pre>\n</div>',
    hints: [
      '<p>\nTraverse the input string and count the length of each run. As you traverse the string, what should you do when you reach a run of length 9 or the end of a run?\n</p>\n',
      "\n<p>\nWhen you reach a run of length 9 or the end of a run, store the computed count for the run as well as its character (you'll likely need a list for these computed counts and characters), and reset the count to 1 before continuing to traverse the string.\n</p>\n",
      '\n<p>\nMake sure that your solution correctly handles the last run in the string.\n</p>',
    ],
    customInputVars: [
      {
        name: 'string',
        example: 'AAAAAAAAAAAAABBCCCCDD',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function runLengthEncoding(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.runLengthEncoding = runLengthEncoding;\n',
      solutions: [
        "// O(n) time | O(n) space - where n is the length of the input string\nfunction runLengthEncoding(string) {\n  // The input string is guaranteed to be non-empty,\n  // so our first run will be of at least length 1.\n  const encodedStringCharacters = [];\n  let currentRunLength = 1;\n\n  for (let i = 1; i < string.length; i++) {\n    const currentCharacter = string[i];\n    const previousCharacter = string[i - 1];\n\n    if (currentCharacter !== previousCharacter || currentRunLength === 9) {\n      encodedStringCharacters.push(currentRunLength.toString());\n      encodedStringCharacters.push(previousCharacter);\n      currentRunLength = 0;\n    }\n\n    currentRunLength++;\n  }\n\n  // Handle the last run.\n  encodedStringCharacters.push(currentRunLength.toString());\n  encodedStringCharacters.push(string[string.length - 1]);\n\n  return encodedStringCharacters.join('');\n}\n\nexports.runLengthEncoding = runLengthEncoding;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const string = 'AAAAAAAAAAAAABBCCCCDD';\n  const expected = '9A4A2B4C2D';\n  const actual = program.runLengthEncoding(string);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const string = 'AAAAAAAAAAAAABBCCCCDD';\n  const expected = '9A4A2B4C2D';\n  const actual = program.runLengthEncoding(string);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input string',
    tests: [
      { string: 'AAAAAAAAAAAAABBCCCCDD' },
      { string: 'aA' },
      { string: '122333' },
      { string: '************^^^^^^^$$$$$$%%%%%%%!!!!!!AAAAAAAAAAAAAAAAAAAA' },
      { string: 'aAaAaaaaaAaaaAAAABbbbBBBB' },
      { string: '                          ' },
      { string: '1  222 333    444  555' },
      { string: '1A2BB3CCC4DDDD' },
      { string: '........______=========AAAA   AAABBBB   BBB' },
      {
        string:
          'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
      },
      { string: '        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' },
      { string: ' ' },
      { string: '[(aaaaaaa,bbbbbbb,ccccc,dddddd)]' },
      { string: ";;;;;;;;;;;;''''''''''''''''''''1233333332222211112222111s" },
      { string: 'AAAAAAAAAAAAABBCCCCDDDDDDDDDDD' },
    ],
  },
  {
    id: 'longest-balanced-substring',
    name: 'Longest Balanced Substring',
    category: 'Strings',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a string made up of parentheses (<span>(</span>\n  and <span>)</span>). The function should return an integer representing the\n  length of the longest balanced substring with regards to parentheses.\n</p>\n<p>\n  A string is said to be balanced if it has as many opening parentheses as it\n  has closing parentheses and if no parenthesis is unmatched. Note that an\n  opening parenthesis can\'t match a closing parenthesis that comes before it,\n  and similarly, a closing parenthesis can\'t match an opening parenthesis that\n  comes after it.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "(()))("\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 <span class="CodeEditor-promptComment">// The longest balanced substring is "(())".</span>\n</pre>\n</div>',
    hints: [
      "<p>\nWith a brute-force style approach, you can iterate through all substrings of the input string, check if they're balanced, and keep track of the longest balanced one. This approach will require using an auxiliary method to check whether a substring is balanced.\n</p>\n",
      "\n<p>\nA more efficient approach to solving this problem is to iterate through the input string only once, using a stack to track the indices of all unmatched opening parentheses. Whenever a closing parenthesis is encountered, you check if the stack has a corresponding opening-parenthesis index, and you pop that index off the stack if it does. If the stack doesn't have a corresponding opening-parenthesis index, then the closing parenthesis is unmatched, and its own index in the input string denotes the start of a new, potentially balanced substring. With this approach, you'll have to figure out a way to keep track of how long a balanced substring is.\n</p>\n",
      '\n<p>\nThe most efficient way to solve this problem is to use only two variables to keep track of the numbers of opening and closing parentheses, respectively, as you traverse the string. Think about how you can use these two pieces of information alone to find the longest balanced substring. Specifically, how do these two pieces of information help you figure out if a substring is balanced, and how can you use them to calculate the length of such a substring?\n</p>',
    ],
    customInputVars: [
      {
        name: 'string',
        example: '(()))(',
        schema: { pattern: '^[()]+$|^$', type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function longestBalancedSubstring(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestBalancedSubstring = longestBalancedSubstring;\n',
      solutions: [
        "// O(n^3) time | O(n) space - where n is the length of the input string\nfunction longestBalancedSubstring(string) {\n  let maxLength = 0;\n\n  for (let i = 0; i < string.length; i++) {\n    for (let j = i + 2; j < string.length + 1; j += 2) {\n      if (isBalanced(string.slice(i, j))) {\n        const currentLength = j - i;\n        maxLength = Math.max(maxLength, currentLength);\n      }\n    }\n  }\n\n  return maxLength;\n}\n\nfunction isBalanced(string) {\n  const openParensStack = [];\n\n  for (const char of string) {\n    if (char === '(') {\n      openParensStack.push('(');\n    } else if (openParensStack.length > 0) {\n      openParensStack.pop();\n    } else {\n      return false;\n    }\n  }\n\n  return openParensStack.length === 0;\n}\n\nexports.longestBalancedSubstring = longestBalancedSubstring;\n",
        "// O(n) time | O(n) space - where n is the length of the input string\nfunction longestBalancedSubstring(string) {\n  let maxLength = 0;\n  const idxStack = [];\n  idxStack.push(-1);\n\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '(') {\n      idxStack.push(i);\n    } else {\n      idxStack.pop();\n      if (idxStack.length === 0) {\n        idxStack.push(i);\n      } else {\n        const balancedSubstringStartIdx = idxStack[idxStack.length - 1];\n        const currentLength = i - balancedSubstringStartIdx;\n        maxLength = Math.max(maxLength, currentLength);\n      }\n    }\n  }\n\n  return maxLength;\n}\n\nexports.longestBalancedSubstring = longestBalancedSubstring;\n",
        "// O(n) time | O(1) space - where n is the length of the input string\nfunction longestBalancedSubstring(string) {\n  let maxLength = 0;\n\n  let openingCount = 0;\n  let closingCount = 0;\n\n  for (const char of string) {\n    if (char === '(') {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, closingCount * 2);\n    } else if (closingCount > openingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n  }\n\n  openingCount = 0;\n  closingCount = 0;\n\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string[i];\n\n    if (char === '(') {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, openingCount * 2);\n    } else if (openingCount > closingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n  }\n\n  return maxLength;\n}\n\nexports.longestBalancedSubstring = longestBalancedSubstring;\n",
        "// O(n) time | O(1) space - where n is the length of the input string\nfunction longestBalancedSubstring(string) {\n  return Math.max(\n    getLongestBalancedInDirection(string, true),\n    getLongestBalancedInDirection(string, false),\n  );\n}\n\nfunction getLongestBalancedInDirection(string, leftToRight) {\n  const openingParens = leftToRight ? '(' : ')';\n  const startIdx = leftToRight ? 0 : string.length - 1;\n  const step = leftToRight ? 1 : -1;\n\n  let maxLength = 0;\n\n  let openingCount = 0;\n  let closingCount = 0;\n\n  let idx = startIdx;\n  while (idx >= 0 && idx < string.length) {\n    const char = string[idx];\n\n    if (char === openingParens) {\n      openingCount++;\n    } else {\n      closingCount++;\n    }\n\n    if (openingCount === closingCount) {\n      maxLength = Math.max(maxLength, closingCount * 2);\n    } else if (closingCount > openingCount) {\n      openingCount = 0;\n      closingCount = 0;\n    }\n\n    idx += step;\n  }\n\n  return maxLength;\n}\n\nexports.longestBalancedSubstring = longestBalancedSubstring;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const string = '(()))(';\n  const expected = 4;\n  const actual = program.longestBalancedSubstring(string);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const string = '(()))(';\n  const expected = 4;\n  const actual = program.longestBalancedSubstring(string);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input string',
    tests: [
      { string: '(()))(' },
      { string: '())()(()())' },
      { string: '()()()()()()()()()()' },
      { string: '((()))()()()()()()()()()()' },
      { string: '()' },
      { string: '(())' },
      { string: '((((((((()))))))))' },
      { string: '((((((((((((((((()))))))))))))))))' },
      { string: '(((()))()())))(()()()())()()' },
      { string: '((((((()()()())()))((())))()' },
      { string: '((' },
      { string: '))' },
      { string: '(' },
      { string: ')' },
      { string: '((((((((((((((((((' },
      { string: '))))))))))))))))))' },
      { string: '(((((((((((((((((()' },
      { string: '()))))))))))))))))))' },
      { string: ')(' },
      { string: '(((((((((())))))))))' },
      { string: '(((((((((()())))))))))' },
      { string: '(((((((((()))))))))))' },
      { string: '))))))))))((((((((((' },
      { string: '' },
      { string: '())()' },
      { string: '()(()' },
      { string: ')))))))()))))())((((' },
      { string: '))())(())((())(())((' },
      { string: ')())()(()(()())))(((' },
      { string: '((()))())()()()()))(' },
      { string: ')(())))(())()))))))(' },
      { string: '()()((((()()))()()()' },
      { string: '()(())()(()()))((())' },
      { string: ')(()((()()(()()()(((' },
      { string: ')())()(()))()((()))(' },
      { string: '()()))))(())((()(()(' },
      { string: '(()())())()((())())(' },
      { string: '(()))((())()))))))()' },
      { string: '(((()()()(())((()()(' },
      { string: ')(()())((()(()())(((' },
      { string: '))()(()()()(()()()))' },
      { string: '(((((((((((((()(()()' },
      { string: ')))(()(()(()()()((()' },
      { string: '()(()((()((()(((((()' },
      { string: ')((())(((()(()()(())' },
      { string: ')((((((()))(()))()((' },
      { string: '()(()()(()(()))((())' },
      { string: ')))((())()()))())(()' },
      { string: '()())()((()()(((()))' },
      { string: ')(()))))(()())))(()(' },
      { string: '))(()()((()))()))()(' },
      { string: ')()()))()(())))))))(' },
      { string: '(((())(())()())()()(' },
      { string: '()()(()()())((((()))' },
      { string: '((()()((()(((()))())' },
      { string: '))(())()())())))()))' },
      { string: '(()(()()())())()((()' },
      { string: '()()())))()()()())()' },
      { string: '))((((()))()))()))))' },
      { string: ')())(())((((((()((()' },
      { string: ')((()())))((()((()))' },
      { string: '())(())))(((()()((()' },
      { string: ')()))((()))(((((((()' },
      { string: ')((((((((()())((())(' },
      { string: ')(())))((()()()(((()' },
      { string: ')()()))((((())))((()' },
      { string: '(()(())(()((()))()()' },
      { string: '(((()(((()()))((())(' },
      { string: ')()()())()))(())()()' },
      { string: '((()))())(((()((())(' },
      { string: ')((((()()(()))))()))' },
      { string: '((()(())))))((()))((' },
      { string: '(()()))())()()(())((' },
      { string: '(()))((())()()((((((' },
      { string: '((()(()))(((((())(((' },
      { string: '())))))())(((())((()' },
      { string: '(()(()' },
    ],
  },
  {
    id: 'valid-ip-addresses',
    name: 'Valid IP Addresses',
    category: 'Strings',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a string of length 12 or smaller, containing only digits. Write a\n  function that returns all the possible IP addresses that can be created by\n  inserting three <span>.</span>s in the string.\n</p>\n<p>\n  An IP address is a sequence of four positive integers that are separated by\n  <span>.</span>s, where each individual integer is within the range\n  <span>0 - 255</span>, inclusive.\n</p>\n<p>\n  An IP address isn\'t valid if any of the individual integers contains leading\n  <span>0</span>s. For example, <span>"192.168.0.1"</span> is a valid IP\n  address, but <span>"192.168.00.1"</span> and\n  <span>"192.168.0.01"</span> aren\'t, because they contain <span>"00"</span> and\n  <span>01</span>, respectively. Another example of a valid IP address is\n  <span>"99.1.1.10"</span>; conversely, <span>"991.1.1.0"</span> isn\'t valid,\n  because <span>"991"</span> is greater than 255.\n</p>\n<p>\n  Your function should return the IP addresses in string format and in no\n  particular order. If no valid IP addresses can be created from the string,\n  your function should return an empty list.\n</p>\n<p>\n  Note: check out our Systems Design Fundamentals on SystemsExpert to learn more\n  about IP addresses!\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "1921680"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\n  "1.9.216.80",\n  "1.92.16.80",\n  "1.92.168.0",\n  "19.2.16.80",\n  "19.2.168.0",\n  "19.21.6.80",\n  "19.21.68.0",\n  "19.216.8.0",\n  "192.1.6.80",\n  "192.1.68.0",\n  "192.16.8.0"\n]\n<span class="CodeEditor-promptComment">// The IP addresses could be ordered differently.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nHow can you split this problem into subproblems to make it easier?\n</p>\n',
      '\n<p>\nEach IP address is comprised of four parts; try finding one valid part at a time and then combining sets of four valid parts to create one valid IP address.\n</p>\n',
      "\n<p>\nGo through all possible combinations of valid IP-address parts. You'll do this by generating a valid first part, then generating all valid second parts given the first part, then finally all valid third and fourth parts given first and second parts. If you find a set of four valid parts, then simply combine them together and add that IP address to some final array. You can start by creating all the possible first parts of an IP address; these will be substrings of the main string that start at the first character and that have lengths 1, 2 and 3. Then you can repeat this process for the second part, where the substrings in this part will start where the first part ended. The same thing applies for the third and fourth parts. After going through all possible parts and storing valid IP addresses, you'll have found all of the IP addresses that can be formed from the input string.\n</p>",
    ],
    customInputVars: [
      {
        name: 'string',
        example: '1921680',
        schema: { maxLength: 12, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function validIPAddresses(string) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.validIPAddresses = validIPAddresses;\n',
      solutions: [
        "// O(1) time | O(1) space\nfunction validIPAddresses(string) {\n  const ipAddressesFound = [];\n\n  for (let i = 0; i < Math.min(string.length, 4); i++) {\n    const currentIPAddressParts = ['', '', '', ''];\n\n    currentIPAddressParts[0] = string.slice(0, i);\n    if (!isValidPart(currentIPAddressParts[0])) continue;\n\n    for (let j = i + 1; j < i + Math.min(string.length - i, 4); j++) {\n      currentIPAddressParts[1] = string.slice(i, j);\n      if (!isValidPart(currentIPAddressParts[1])) continue;\n\n      for (let k = j + 1; k < j + Math.min(string.length - j, 4); k++) {\n        currentIPAddressParts[2] = string.slice(j, k);\n        currentIPAddressParts[3] = string.slice(k);\n\n        if (isValidPart(currentIPAddressParts[2]) && isValidPart(currentIPAddressParts[3])) {\n          ipAddressesFound.push(currentIPAddressParts.join('.'));\n        }\n      }\n    }\n  }\n\n  return ipAddressesFound;\n}\n\nfunction isValidPart(string) {\n  const stringAsInt = parseInt(string);\n  if (stringAsInt > 255) return false;\n\n  return string.length === stringAsInt.toString().length;\n}\n\n// Do not edit the line below.\nexports.validIPAddresses = validIPAddresses;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = '1921680';\n  const expected = [\n    '1.9.216.80',\n    '1.92.16.80',\n    '1.92.168.0',\n    '19.2.16.80',\n    '19.2.168.0',\n    '19.21.6.80',\n    '19.21.68.0',\n    '19.216.8.0',\n    '192.1.6.80',\n    '192.1.68.0',\n    '192.16.8.0',\n  ];\n  const actual = program.validIPAddresses(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = '1921680';\n  const expected = [\n    '1.9.216.80',\n    '1.92.16.80',\n    '1.92.168.0',\n    '19.2.16.80',\n    '19.2.168.0',\n    '19.21.6.80',\n    '19.21.68.0',\n    '19.216.8.0',\n    '192.1.6.80',\n    '192.1.68.0',\n    '192.16.8.0',\n  ];\n  const actual = program.validIPAddresses(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(1) time | O(1) space',
    tests: [
      { string: '1921680' },
      { string: '3700100' },
      { string: '9743' },
      { string: '97430' },
      { string: '997430' },
      { string: '255255255255' },
      { string: '255255255256' },
      { string: '99999999' },
      { string: '33133313' },
      { string: '00010' },
      { string: '100100' },
      { string: '1072310' },
      { string: '1' },
      { string: '11' },
      { string: '111' },
      { string: '00001' },
    ],
  },
  {
    id: 'reverse-words-in-string',
    name: 'Reverse Words In String',
    category: 'Strings',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a string of words separated by one or more\n  whitespaces and returns a string that has these words in reverse order. For\n  example, given the string <span>"tim is great"</span>, your function should\n  return <span>"great is tim"</span>.\n</p>\n<p>\n  For this problem, a word can contain special characters, punctuation, and\n  numbers. The words in the string will be separated by one or more whitespaces,\n  and the reversed string must contain the same whitespaces as the original\n  string. For example, given the string\n  <span>"whitespaces    4"</span> you would be expected to return\n  <span>"4    whitespaces"</span>.\n</p>\n<p>\n  Note that you\'re <b><i>not</i></b> allowed to to use any built-in\n  <span>split</span> or <span>reverse</span> methods/functions. However, you\n  <b><i>are</i></b> allowed to use a built-in <span>join</span> method/function.\n</p>\n<p>Also note that the input string isn\'t guaranteed to always contain words.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "AlgoExpert is the best!"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"best! the is AlgoExpert"\n</pre>\n</div>',
    hints: [
      '<p>\n  There are at least two ways to solve this problem, and both require locating\n  the words in the string. How can you find all of the words in the string?\n</p>\n',
      "\n<p>\n  If you're able to locate all of the words in the string, the next step is to\n  figure out how many spaces are between them. If you can create a list that\n  contains all of the words in the string and all of the spaces between them,\n  then all you need to do is reverse the list and recreate the string using the\n  reversed list.\n</p>\n",
      "\n<p>\n  A potentially easier approach to this problem is to start by reversing the\n  entire string. Once the entire string has been reversed, the words will be in\n  the correct order, but each word will also be reversed. From here, all you\n  have to do is reverse all of the individual words in this new string. By doing\n  this, you'll restore each reversed word back to its original order, and\n  you'll have the desired output.\n</p>",
    ],
    customInputVars: [
      {
        name: 'string',
        example: 'AlgoExpert is the best!',
        schema: { type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        "function reverseWordsInString(string) {\n  // Write your code here.\n  return '';\n}\n\n// Do not edit the line below.\nexports.reverseWordsInString = reverseWordsInString;\n",
      solutions: [
        "// O(n) time | O(n) space - where n is the length of the string\nfunction reverseWordsInString(string) {\n  const words = [];\n  let startOfWord = 0;\n  for (let idx = 0; idx < string.length; idx++) {\n    const character = string[idx];\n\n    if (character === ' ') {\n      words.push(string.slice(startOfWord, idx));\n      startOfWord = idx;\n    } else if (string[startOfWord] === ' ') {\n      words.push(' ');\n      startOfWord = idx;\n    }\n  }\n\n  words.push(string.slice(startOfWord));\n\n  reverseList(words);\n  return words.join('');\n}\n\nfunction reverseList(list) {\n  let start = 0,\n    end = list.length - 1;\n  while (start < end) {\n    const temp = list[start];\n    list[start] = list[end];\n    list[end] = temp;\n    start++;\n    end--;\n  }\n}\n\n// Do not edit the line below.\nexports.reverseWordsInString = reverseWordsInString;\n",
        "// O(n) time | O(n) space - where n is the length of the string\nfunction reverseWordsInString(string) {\n  const characters = [];\n  for (const char of string) {\n    characters.push(char);\n  }\n  reverseListRange(characters, 0, characters.length - 1);\n\n  let startOfWord = 0;\n  while (startOfWord < characters.length) {\n    let endOfWord = startOfWord;\n    while (endOfWord < characters.length && characters[endOfWord] != ' ') {\n      endOfWord++;\n    }\n\n    reverseListRange(characters, startOfWord, endOfWord - 1);\n    startOfWord = endOfWord + 1;\n  }\n  return characters.join('');\n}\n\nfunction reverseListRange(list, start, end) {\n  while (start < end) {\n    const temp = list[start];\n    list[start] = list[end];\n    list[end] = temp;\n    start++;\n    end--;\n  }\n}\n\n// Do not edit the line below.\nexports.reverseWordsInString = reverseWordsInString;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 'AlgoExpert is the best!';\n  const expected = 'best! the is AlgoExpert';\n  const actual = program.reverseWordsInString(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 'AlgoExpert is the best!';\n  const expected = 'best! the is AlgoExpert';\n  const actual = program.reverseWordsInString(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the string',
    tests: [
      { string: 'AlgoExpert is the best!' },
      { string: 'Reverse These Words' },
      { string: '..H,, hello 678' },
      { string: 'this this words this this this words this' },
      { string: '1 12 23 34 56' },
      { string: 'APPLE PEAR PLUM ORANGE' },
      { string: 'this-is-one-word' },
      { string: 'a' },
      { string: 'ab' },
      { string: '' },
      {
        string:
          'algoexpert is the best platform to use to prepare for coding interviews!',
      },
      { string: 'words, separated, by, commas' },
      { string: 'this      string     has a     lot of   whitespace' },
      { string: 'a ab a' },
      { string: 'test        ' },
      { string: ' ' },
    ],
  },
  {
    id: 'common-characters',
    name: 'Common Characters',
    category: 'Strings',
    complexity: 0,
    prompt:
      '<div class="html">\n  <p>\n    Write a function that takes in a non-empty list of non-empty strings and\n    returns a list of characters that are common to all strings in the list,\n    ignoring multiplicity.\n  </p>\n\n  <p>\n    Note that the strings are not guaranteed to only contain alphanumeric characters. The list\n    you return can be in any order.\n  </p>\n\n  <h3>Sample Input</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">strings</span> = ["abc", "bcd", "cbaccd"]\n</pre>\n  <h3>Sample Output</h3>\n  <pre>\n["b", "c"] <span class="CodeEditor-promptComment">// The characters could be ordered differently.</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  What data structure could be helpful to remember characters we've seen and\n  how many strings contained those characters?\n</p>\n",
      '\n<p>\n  We can use a map to keep track of the characters we have seen and how many strings\n  we have seen them in. If a character is seen <span>len(strings)</span> times, then\n  it must be in every string.\n</p>\n',
      '\n<p>\n  Converting a string to a set can quickly get all of the unique characters from\n  that string, which can be helpful since we are ignoring multiplicity in this\n  problem.\n</p>',
    ],
    customInputVars: [
      {
        name: 'strings',
        example: ['abc', 'bcd', 'cbad'],
        schema: {
          items: { minLength: 1, type: 'string' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function commonCharacters(strings) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.commonCharacters = commonCharacters;\n',
      solutions: [
        '// O(n * m) time | O(c) space - where n is the number of strings, m is the\n// length of the longest string, and c is the number of unique characters across\n// all strings\nfunction commonCharacters(strings) {\n  const characterCounts = {};\n  for (const string of strings) {\n    const uniqueStringCharacters = new Set(string);\n    for (const character of uniqueStringCharacters) {\n      if (!(character in characterCounts)) {\n        characterCounts[character] = 0;\n      }\n      characterCounts[character]++;\n    }\n  }\n\n  const finalCharacters = [];\n  for (const [character, count] of Object.entries(characterCounts)) {\n    if (count === strings.length) {\n      finalCharacters.push(character);\n    }\n  }\n\n  return finalCharacters;\n}\n\n// Do not edit the line below.\nexports.commonCharacters = commonCharacters;\n',
        '// O(n * m) time | O(m) space - where n is the number of strings, and m is the\n// length of the longest string\nfunction commonCharacters(strings) {\n  const smallestString = getSmallestString(strings);\n  const potentialCommonCharacters = new Set(smallestString);\n\n  for (const string of strings) {\n    removeNonexistentCharacters(string, potentialCommonCharacters);\n  }\n\n  return Array.from(potentialCommonCharacters);\n}\n\nfunction getSmallestString(strings) {\n  let smallestString = strings[0];\n  for (const string of strings) {\n    if (string.length < smallestString.length) {\n      smallestString = string;\n    }\n  }\n\n  return smallestString;\n}\n\nfunction removeNonexistentCharacters(string, potentialCommonCharacters) {\n  const uniqueStringCharacters = new Set(string);\n\n  for (const character of Array.from(potentialCommonCharacters)) {\n    if (!uniqueStringCharacters.has(character)) {\n      potentialCommonCharacters.delete(character);\n    }\n  }\n}\n\n// Do not edit the line below.\nexports.commonCharacters = commonCharacters;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['abc', 'bcd', 'cbad'];\n  const expected = ['b', 'c'];\n  const actual = program.commonCharacters(input);\n  actual.sort();\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['abc', 'bcd', 'cbad'];\n  const expected = ['b', 'c'];\n  const actual = program.commonCharacters(input);\n  actual.sort();\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * m) time | O(m) space - where n is the number of strings, and m is the length of the longest string',
    tests: [
      { strings: ['abc', 'bcd', 'cbad'] },
      { strings: ['a'] },
      { strings: ['a', 'b', 'c'] },
      { strings: ['aa', 'aa'] },
      { strings: ['aaaa', 'a'] },
      {
        strings: [
          'abcde',
          'aa',
          'foobar',
          'foobaz',
          'and this is a string',
          'aaaaaaaa',
          'eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeea',
        ],
      },
      {
        strings: [
          'abcdef',
          'fedcba',
          'abcefd',
          'aefbcd',
          'efadbc',
          'effffffffffffbcda',
          'eeeeeffffffbbbbbaaaaaccccdddd',
          '**************abdcef************',
        ],
      },
      {
        strings: [
          'ab&cdef!',
          'f!ed&cba',
          'a&bce!d',
          'ae&fb!cd',
          'efa&!dbc',
          'eff!&fff&fffffffbcda',
          'eeee!efff&fffbbbbbaaaaaccccdddd',
          '*******!***&****abdcef************',
          '*******!***&****a***********f*',
          '*******!***&****b***********c*',
        ],
      },
      { strings: ['*abcd', 'def*', '******d*****'] },
      { strings: ['*abc!d', 'de!f*', '**!!!****d*****'] },
    ],
  },
  {
    id: 'generate-document',
    name: 'Generate Document',
    category: 'Strings',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a string of available characters and a string representing a\n  document that you need to generate. Write a function that determines if you\n  can generate the document using the available characters. If you can generate\n  the document, your function should return <span>true</span>; otherwise, it\n  should return <span>false</span>.\n</p>\n<p>\n  You\'re only able to generate the document if the frequency of unique\n  characters in the characters string is greater than or equal to the frequency\n  of unique characters in the document string. For example, if you\'re given\n  <span>characters = "abcabc"</span> and <span>document = "aabbccc"</span> you\n  <b>cannot</b> generate the document because you\'re missing one <span>c</span>.\n</p>\n<p>\n  The document that you need to create may contain any characters, including\n  special characters, capital letters, numbers, and spaces.\n</p>\n<p>Note: you can always generate the empty string (<span>""</span>).</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">characters</span> = "Bste!hetsi ogEAxpelrt x "\n<span class="CodeEditor-promptParameter">document</span> = "AlgoExpert is the Best!"\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      '<p>\n  There are multiple ways to the solve this problem, but not all approaches have\n  an optimal time complexity. Is there any way to solve this problem in better\n  than <span>O(m * (n + m))</span> or <span>O(n * (n + m))</span> time, where\n  <span>n</span> is the length of the <span>characters</span> string and\n  <span>m</span> is the length of the <span>document</span> string?\n</p>\n',
      '\n<p>\n  One of the simplest ways to solve this problem is to loop through the\n  <span>document</span> string, one character at a time. At every character, you\n  can count how many times it occurs in the <span>document</span> string and in\n  the <span>characters</span> string. If it occurs more times in the\n  <span>document</span> string than in the <span>characters</span> string, then\n  you cannot generate the document. What is the time complexity of this\n  approach?\n</p>\n',
      '\n<p>\n  The approach discussed in Hint #2 runs in <span>O(m * (n + m))</span> time.\n  Can you use some external space to optimize this time complexity?\n</p>\n',
      "\n<p>\n  You can solve this problem in <span>O(n + m)</span> time. To do so, you need\n  to use a hash table. Start by counting all of the characters in the\n  <span>characters</span> string and storing these counts in a hash table. Then,\n  loop through the <span>document</span> string, and check if each character is\n  in the hash table and has a value greater than zero. If a character isn't in\n  the hash table or doesn't have a value greater than zero, then you cannot\n  generate the document. If a character is in the hash table and has a value\n  greater than zero, then decrement its value in the hash table to indicate that\n  you've \"used\" one of these available characters. If you make it through the\n  entire <span>document</span> string without returning <span>false</span>, then\n  you can generate the document.\n</p>",
    ],
    customInputVars: [
      {
        name: 'characters',
        example: 'Bste!hetsi ogEAxpelrt x ',
        schema: { type: 'string' },
      },
      {
        name: 'document',
        example: 'AlgoExpert is the Best!',
        schema: { type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function generateDocument(characters, document) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.generateDocument = generateDocument;\n',
      solutions: [
        '// O(m * (n + m)) time | O(1) space - where n is the number\n// of characters and m is the length of the document\nfunction generateDocument(characters, document) {\n  for (const character of document) {\n    const documentFrequency = countCharacterFrequency(character, document);\n    const charactersFrequency = countCharacterFrequency(character, characters);\n    if (documentFrequency > charactersFrequency) return false;\n  }\n\n  return true;\n}\n\nfunction countCharacterFrequency(character, target) {\n  let frequency = 0;\n  for (const char of target) {\n    if (char === character) frequency++;\n  }\n\n  return frequency;\n}\n\n// Do not edit the line below.\nexports.generateDocument = generateDocument;\n',
        '// O(c * (n + m)) time | O(c) space - where n is the number of characters, m is\n// the length of the document, and c is the number of unique characters in the document\nfunction generateDocument(characters, document) {\n  const alreadyCounted = new Set();\n\n  for (const character of document) {\n    if (character in alreadyCounted) continue;\n\n    const documentFrequency = countCharacterFrequency(character, document);\n    const charactersFrequency = countCharacterFrequency(character, characters);\n    if (documentFrequency > charactersFrequency) return false;\n\n    alreadyCounted.add(character);\n  }\n\n  return true;\n}\n\nfunction countCharacterFrequency(character, target) {\n  let frequency = 0;\n  for (const char of target) {\n    if (char === character) frequency++;\n  }\n\n  return frequency;\n}\n\n// Do not edit the line below.\nexports.generateDocument = generateDocument;\n',
        '// O(n + m) time | O(c) space - where n is the number of characters, m is\n// the length of the document, and c is the number of unique characters in the characters string\nfunction generateDocument(characters, document) {\n  const characterCounts = {};\n\n  for (const character of characters) {\n    if (!(character in characterCounts)) characterCounts[character] = 0;\n\n    characterCounts[character]++;\n  }\n\n  for (const character of document) {\n    if (!(character in characterCounts) || characterCounts[character] === 0) return false;\n\n    characterCounts[character]--;\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.generateDocument = generateDocument;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const characters = 'Bste!hetsi ogEAxpelrt x ';\n  const document = 'AlgoExpert is the Best!';\n  const expected = true;\n  const actual = program.generateDocument(characters, document);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const characters = 'Bste!hetsi ogEAxpelrt x ';\n  const document = 'AlgoExpert is the Best!';\n  const expected = true;\n  const actual = program.generateDocument(characters, document);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n + m) time | O(c) space - where n is the number of characters, m is the length of the document, and c is the number of unique characters in the characters string',
    tests: [
      {
        characters: 'Bste!hetsi ogEAxpelrt x ',
        document: 'AlgoExpert is the Best!',
      },
      { characters: 'A', document: 'a' },
      { characters: 'a', document: 'a' },
      { characters: 'a hsgalhsa sanbjksbdkjba kjx', document: '' },
      { characters: ' ', document: 'hello' },
      { characters: '     ', document: '     ' },
      { characters: 'aheaollabbhb', document: 'hello' },
      { characters: 'aheaolabbhb', document: 'hello' },
      { characters: 'estssa', document: 'testing' },
      {
        characters: 'Bste!hetsi ogEAxpert',
        document: 'AlgoExpert is the Best!',
      },
      { characters: 'helloworld ', document: 'hello wOrld' },
      { characters: 'helloworldO', document: 'hello wOrld' },
      { characters: 'helloworldO ', document: 'hello wOrld' },
      {
        characters: '&*&you^a%^&8766 _=-09     docanCMakemthisdocument',
        document: 'Can you make this document &',
      },
      { characters: 'abcabcabcacbcdaabc', document: 'bacaccadac' },
    ],
  },
  {
    id: 'first-non-repeating-character',
    name: 'First Non-Repeating Character',
    category: 'Strings',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a string of lowercase English-alphabet letters\n  and returns the index of the string\'s first non-repeating character.\n</p>\n<p>\n  The first non-repeating character is the first character in a string that\n  occurs only once.\n</p>\n<p>\n  If the input string doesn\'t have any non-repeating characters, your function\n  should return <span>-1</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "abcdcaf"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 <span class="CodeEditor-promptComment">// The first non-repeating character is "b" and is found at index 1.</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  How can you determine if a character only appears once in the entire input\n  string? What would be the brute-force approach to solve this problem?\n</p>\n',
      "\n<p>\n  One way to solve this problem is with nested traversals of the string: you\n  start by traversing the string, and for each character that you traverse, you\n  traverse through the entire string again to see if the character appears\n  anywhere else. The first index at which you find a character that doesn't\n  appear anywhere else in the string is the index that you return. This approach\n  works, but it's not optimal. Are there any data structures that you can use to\n  improve the time complexity of this approach?\n</p>\n",
      "\n<p>\n  Hash tables are very commonly used to keep track of frequencies. Build a hash\n  table, where every key is a character in the string and every value is the\n  corresponding character's frequency in the input string. You can traverse the\n  entire string once to fill the hash table, and then with a second traversal\n  through the string (not a nested traversal), you can use the hash table's\n  constant-time lookups to find the first character with a frequency of\n  <span>1</span>.\n</p>",
    ],
    customInputVars: [
      { name: 'string', example: 'abcdcaf', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function firstNonRepeatingCharacter(string) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.firstNonRepeatingCharacter = firstNonRepeatingCharacter;\n',
      solutions: [
        '// O(n^2) time | O(1) space - where n is the length of the input string\nfunction firstNonRepeatingCharacter(string) {\n  for (let idx = 0; idx < string.length; idx++) {\n    let foundDuplicate = false;\n    for (let idx2 = 0; idx2 < string.length; idx2++) {\n      if (string[idx] === string[idx2] && idx !== idx2) foundDuplicate = true;\n    }\n\n    if (!foundDuplicate) return idx;\n  }\n\n  return -1;\n}\n\n// Do not edit the line below.\nexports.firstNonRepeatingCharacter = firstNonRepeatingCharacter;\n',
        '// O(n) time | O(1) space - where n is the length of the input string\n// The constant space is because the input string only has lowercase\n// English-alphabet letters; thus, our hash table will never have more\n// than 26 character frequencies.\nfunction firstNonRepeatingCharacter(string) {\n  const characterFrequencies = {};\n\n  for (const character of string) {\n    if (!(character in characterFrequencies)) characterFrequencies[character] = 0;\n    characterFrequencies[character]++;\n  }\n\n  for (let idx = 0; idx < string.length; idx++) {\n    const character = string[idx];\n    if (characterFrequencies[character] === 1) return idx;\n  }\n\n  return -1;\n}\n\n// Do not edit the line below.\nexports.firstNonRepeatingCharacter = firstNonRepeatingCharacter;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 'abcdcaf';\n  const expected = 1;\n  const actual = program.firstNonRepeatingCharacter(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 'abcdcaf';\n  const expected = 1;\n  const actual = program.firstNonRepeatingCharacter(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input string\nThe constant space is because the input string only has lowercase\nEnglish-alphabet letters; thus, our hash table will never have more\nthan 26 character frequencies.',
    tests: [
      { string: 'abcdcaf' },
      { string: 'faadabcbbebdf' },
      { string: 'a' },
      { string: 'ab' },
      { string: 'abc' },
      { string: 'abac' },
      { string: 'ababac' },
      { string: 'ababacc' },
      { string: 'lmnopqldsafmnopqsa' },
      { string: 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy' },
      { string: 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz' },
      { string: '' },
      { string: 'ggyllaylacrhdzedddjsc' },
      {
        string:
          'aaaaaaaaaaaaaaaaaaaabbbbbbbbbbcccccccccccdddddddddddeeeeeeeeffghgh',
      },
      { string: 'aabbccddeeff' },
    ],
  },
  {
    id: 'minimum-characters-for-words',
    name: 'Minimum Characters For Words',
    category: 'Strings',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of words and returns the smallest\n  array of characters needed to form all of the words. The characters don\'t need\n  to be in any particular order.\n</p>\n<p>\n  For example, the characters <span>["y", "r", "o", "u"]</span> are needed to\n  form the words <span>["your", "you", "or", "yo"]</span>.\n</p>\n<p>\n  Note: the input words won\'t contain any spaces; however, they might contain\n  punctuation and/or special characters.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">words</span> = ["this", "that", "did", "deed", "them!", "a"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["t", "t", "h", "i", "s", "a", "d", "d", "e", "e", "m", "!"]\n<span class="CodeEditor-promptComment">// The characters could be ordered differently.</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  There are a few different ways to solve this problem, but all of them use the\n  same general approach. You'll need to determine not only all of the unique\n  characters required to form the input words, but also their required\n  frequencies. What determines the required frequencies of characters to form\n  multiple words?\n</p>\n",
      '\n<p>\n  The word that contains the highest frequency of any character dictates how\n  many of those characters are required. For example, given\n  <span>words = ["A", "AAAA"]</span> you need 4 <span>A</span>s, because the\n  word that contains the most of amount of <span>A</span>s has 4.\n</p>\n',
      "\n<p>\n  Use a hash table to keep track of the maximum frequencies of all unique\n  characters that occur across all words. Count the frequency of each character\n  in each word, and use those per-word frequencies to update your\n  maximum-character-frequency hash table. Once you've determined the maximum\n  frequency of each character across all words, you can use the built-up hash\n  table to generate your output array.\n</p>",
    ],
    customInputVars: [
      {
        name: 'words',
        example: ['this', 'that', 'did', 'deed', 'them!', 'a'],
        schema: { items: { type: 'string' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function minimumCharactersForWords(words) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.minimumCharactersForWords = minimumCharactersForWords;\n',
      solutions: [
        '// O(n * l) time | O(c) space - where n is the number of words,\n// l is the length of the longest word, and c is the number of\n// unique characters across all words\n// See notes under video explanation for details about the space complexity.\nfunction minimumCharactersForWords(words) {\n  const maximumCharacterFrequencies = {};\n\n  for (const word of words) {\n    const characterFrequencies = countCharacterFrequencies(word);\n    updateMaximumFrequencies(characterFrequencies, maximumCharacterFrequencies);\n  }\n\n  return makeArrayFromCharacterFrequencies(maximumCharacterFrequencies);\n}\n\nfunction countCharacterFrequencies(string) {\n  const characterFrequencies = {};\n\n  for (const character of string) {\n    if (!(character in characterFrequencies)) {\n      characterFrequencies[character] = 0;\n    }\n\n    characterFrequencies[character] += 1;\n  }\n\n  return characterFrequencies;\n}\n\nfunction updateMaximumFrequencies(frequencies, maximumFrequencies) {\n  for (const character in frequencies) {\n    const frequency = frequencies[character];\n\n    if (character in maximumFrequencies) {\n      maximumFrequencies[character] = Math.max(frequency, maximumFrequencies[character]);\n    } else {\n      maximumFrequencies[character] = frequency;\n    }\n  }\n}\n\nfunction makeArrayFromCharacterFrequencies(characterFrequencies) {\n  const characters = [];\n\n  for (const character in characterFrequencies) {\n    const frequency = characterFrequencies[character];\n\n    for (let idx = 0; idx < frequency; idx++) {\n      characters.push(character);\n    }\n  }\n\n  return characters;\n}\n\n// Do not edit the line below.\nexports.minimumCharactersForWords = minimumCharactersForWords;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['this', 'that', 'did', 'deed', 'them!', 'a'];\n  const expected = ['t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!'];\n  const actual = program.minimumCharactersForWords(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['this', 'that', 'did', 'deed', 'them!', 'a'];\n  const expected = ['t', 't', 'h', 'i', 's', 'a', 'd', 'd', 'e', 'e', 'm', '!'];\n  const actual = program.minimumCharactersForWords(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * l) time | O(c) space - where n is the number of words, l is the length of the longest word, and c is the number of unique characters across all words\nSee notes under video explanation for details about the space complexity.',
    tests: [
      { words: ['this', 'that', 'did', 'deed', 'them!', 'a'] },
      { words: ['a', 'abc', 'ab', 'boo'] },
      { words: ['a'] },
      { words: ['abc', 'ab', 'b', 'bac', 'c'] },
      { words: ['!!!2', '234', '222', '432'] },
      {
        words: ['this', 'that', 'they', 'them', 'their', 'there', 'time', 'is'],
      },
      { words: ['tim', 'is', 'great'] },
      { words: ['abc', 'bavcc', 'aaaa', 'cde', 'efg', 'gead'] },
      { words: ['a', 'a', 'a'] },
      {
        words: [
          'them',
          'they',
          'that',
          'that',
          'yes',
          'yo',
          'no',
          'boo',
          'you',
          'okay',
          'too',
        ],
      },
      { words: ['cta', 'cat', 'tca', 'tac', 'a', 'c', 't'] },
      { words: ['my', 'coding', 'skills', 'are', 'great'] },
      { words: [] },
      { words: ['168712hn3;nlsdjhahjdksaxa097918@#$RT%T^&*()_'] },
      { words: ['cat', 'cAt', 'tAc', 'Act', 'Cat'] },
      { words: ['Abc', 'baVcc', 'aaaa', 'cdeE', 'efg', 'gead'] },
      {
        words: [
          'mississippi',
          'piper',
          'icing',
          'ice',
          'pickle',
          'piping',
          'pie',
          'pi',
          'sassy',
          'serpent',
          'python',
          'ascii',
          'sister',
          'mister',
        ],
      },
    ],
  },
  {
    id: 'bubble-sort',
    name: 'Bubble Sort',
    category: 'Sorting',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Bubble Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Bubble Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>',
    hints: [
      '<p>\nTraverse the input array, swapping any two numbers that are out of order and keeping track of any swaps that you make. Once you arrive at the end of the array, check if you have made any swaps; if not, the array is sorted and you are done; otherwise, repeat the steps laid out in this hint until the array is sorted.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8, 5, 2, 9, 5, 6, 3],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function bubbleSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.bubbleSort = bubbleSort;\n',
      solutions: [
        '// Best: O(n) time | O(1) space\n// Average: O(n^2) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nfunction bubbleSort(array) {\n  let isSorted = false;\n  let counter = 0;\n  while (!isSorted) {\n    isSorted = true;\n    for (let i = 0; i < array.length - 1 - counter; i++) {\n      if (array[i] > array[i + 1]) {\n        swap(i, i + 1, array);\n        isSorted = false;\n      }\n    }\n    counter++;\n  }\n  return array;\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.bubbleSort = bubbleSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.bubbleSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.bubbleSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
    },
    bigO: 'Best: O(n) time | O(1) space - where n is the length of the input array\nAverage: O(n^2) time | O(1) space - where n is the length of the input array\nWorst: O(n^2) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [8, 5, 2, 9, 5, 6, 3] },
      { array: [1] },
      { array: [1, 2] },
      { array: [2, 1] },
      { array: [1, 3, 2] },
      { array: [3, 1, 2] },
      { array: [1, 2, 3] },
      {
        array: [
          -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6, -7,
          8,
        ],
      },
      {
        array: [
          -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
        ],
      },
      {
        array: [
          8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2, 7,
          -2, 4,
        ],
      },
      { array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1] },
      {
        array: [
          2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9, 8,
          1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
        ],
      },
      {
        array: [
          4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
          -2, -7, 4,
        ],
      },
      {
        array: [
          427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246, 12,
          -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348, -474,
          -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565, 892, 970,
          -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
        ],
      },
      {
        array: [
          991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998, 847,
          80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435, -269,
          652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980, 913,
          -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519, 906,
        ],
      },
      {
        array: [
          384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
          -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204, 776,
          -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367, -609,
          662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67, -389, 508,
          777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755, -978, 515,
          -68, -559, 489, 732, -19, -489, 737, 924,
        ],
      },
      {
        array: [
          544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
          -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
          -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568, -702,
          551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153, 788,
          844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150, -656, 528,
          61, 94, -581,
        ],
      },
      {
        array: [
          -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
          268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437, -453,
          -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67, 834,
          619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296, -90,
          401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505, -415,
          -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373, 915, -885,
          879, 391, -158, 588, -641, -937, 986, 949, -321,
        ],
      },
      {
        array: [
          -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
          842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
          -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
          892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
          341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800, -950,
          -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265, 746, 355,
          -578, -441, -254, -941, -738, -469, -167, -420, -126, -410, 59,
        ],
      },
    ],
  },
  {
    id: 'insertion-sort',
    name: 'Insertion Sort',
    category: 'Sorting',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Insertion Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Insertion Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>',
    hints: [
      '<p>\nDivide the input array into two subarrays in place. The first subarray should be sorted at all times and should start with a length of 1, while the second subarray should be unsorted. Iterate through the unsorted subarray, inserting all of its elements into the sorted subarray in the correct position by swapping them into place. Eventually, the entire array will be sorted.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8, 5, 2, 9, 5, 6, 3],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function insertionSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.insertionSort = insertionSort;\n',
      solutions: [
        '// Best: O(n) time | O(1) space\n// Average: O(n^2) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nfunction insertionSort(array) {\n  for (let i = 1; i < array.length; i++) {\n    let j = i;\n    while (j > 0 && array[j] < array[j - 1]) {\n      swap(j, j - 1, array);\n      j -= 1;\n    }\n  }\n  return array;\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.insertionSort = insertionSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.insertionSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.insertionSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
    },
    bigO: 'Best: O(n) time | O(1) space - where n is the length of the input array\nAverage: O(n^2) time | O(1) space - where n is the length of the input array\nWorst: O(n^2) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [8, 5, 2, 9, 5, 6, 3] },
      { array: [1] },
      { array: [1, 2] },
      { array: [2, 1] },
      { array: [1, 3, 2] },
      { array: [3, 1, 2] },
      { array: [1, 2, 3] },
      {
        array: [
          -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6, -7,
          8,
        ],
      },
      {
        array: [
          -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
        ],
      },
      {
        array: [
          8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2, 7,
          -2, 4,
        ],
      },
      { array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1] },
      {
        array: [
          2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9, 8,
          1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
        ],
      },
      {
        array: [
          4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
          -2, -7, 4,
        ],
      },
      {
        array: [
          427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246, 12,
          -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348, -474,
          -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565, 892, 970,
          -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
        ],
      },
      {
        array: [
          991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998, 847,
          80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435, -269,
          652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980, 913,
          -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519, 906,
        ],
      },
      {
        array: [
          384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
          -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204, 776,
          -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367, -609,
          662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67, -389, 508,
          777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755, -978, 515,
          -68, -559, 489, 732, -19, -489, 737, 924,
        ],
      },
      {
        array: [
          544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
          -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
          -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568, -702,
          551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153, 788,
          844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150, -656, 528,
          61, 94, -581,
        ],
      },
      {
        array: [
          -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
          268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437, -453,
          -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67, 834,
          619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296, -90,
          401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505, -415,
          -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373, 915, -885,
          879, 391, -158, 588, -641, -937, 986, 949, -321,
        ],
      },
      {
        array: [
          -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
          842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
          -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
          892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
          341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800, -950,
          -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265, 746, 355,
          -578, -441, -254, -941, -738, -469, -167, -420, -126, -410, 59,
        ],
      },
    ],
  },
  {
    id: 'selection-sort',
    name: 'Selection Sort',
    category: 'Sorting',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Selection Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Selection Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>',
    hints: [
      '<p>\nDivide the input array into two subarrays in place. The first subarray should be sorted at all times and should start with a length of 0, while the second subarray should be unsorted. Find the smallest (or largest) element in the unsorted subarray and insert it into the sorted subarray with a swap. Repeat this process of finding the smallest (or largest) element in the unsorted subarray and inserting it in its correct position in the sorted subarray with a swap until the entire array is sorted.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8, 5, 2, 9, 5, 6, 3],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function selectionSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.selectionSort = selectionSort;\n',
      solutions: [
        '// Best: O(n^2) time | O(1) space\n// Average: O(n^2) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nfunction selectionSort(array) {\n  let startIdx = 0;\n  while (startIdx < array.length - 1) {\n    let smallestIdx = startIdx;\n    for (let i = startIdx + 1; i < array.length; i++) {\n      if (array[smallestIdx] > array[i]) smallestIdx = i;\n    }\n    swap(startIdx, smallestIdx, array);\n    startIdx++;\n  }\n  return array;\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.selectionSort = selectionSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.selectionSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.selectionSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
    },
    bigO: 'Best: O(n^2) time | O(1) space - where n is the length of the input array\nAverage: O(n^2) time | O(1) space - where n is the length of the input array\nWorst: O(n^2) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [8, 5, 2, 9, 5, 6, 3] },
      { array: [1] },
      { array: [1, 2] },
      { array: [2, 1] },
      { array: [1, 3, 2] },
      { array: [3, 1, 2] },
      { array: [1, 2, 3] },
      {
        array: [
          -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6, -7,
          8,
        ],
      },
      {
        array: [
          -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
        ],
      },
      {
        array: [
          8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2, 7,
          -2, 4,
        ],
      },
      { array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1] },
      {
        array: [
          2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9, 8,
          1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
        ],
      },
      {
        array: [
          4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
          -2, -7, 4,
        ],
      },
      {
        array: [
          427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246, 12,
          -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348, -474,
          -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565, 892, 970,
          -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
        ],
      },
      {
        array: [
          991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998, 847,
          80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435, -269,
          652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980, 913,
          -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519, 906,
        ],
      },
      {
        array: [
          384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
          -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204, 776,
          -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367, -609,
          662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67, -389, 508,
          777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755, -978, 515,
          -68, -559, 489, 732, -19, -489, 737, 924,
        ],
      },
      {
        array: [
          544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
          -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
          -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568, -702,
          551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153, 788,
          844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150, -656, 528,
          61, 94, -581,
        ],
      },
      {
        array: [
          -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
          268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437, -453,
          -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67, 834,
          619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296, -90,
          401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505, -415,
          -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373, 915, -885,
          879, 391, -158, 588, -641, -937, 986, 949, -321,
        ],
      },
      {
        array: [
          -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
          842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
          -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
          892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
          341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800, -950,
          -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265, 746, 355,
          -578, -441, -254, -941, -738, -469, -167, -420, -126, -410, 59,
        ],
      },
    ],
  },
  {
    id: 'merge-sort',
    name: 'Merge Sort',
    category: 'Sorting',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Merge Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Merge Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>',
    hints: [
      '<p>\nMerge Sort works by cutting an array in two halves, respectively sorting those two halves by performing some special logic, and then merging the two newly-sorted halves into one sorted array. The respective sorting of the two halves is done by reapplying the Merge Sort algorithm / logic on each half until single-element halves are obtained; these single-element arrays are sorted by nature and can very easily be merged back together.\n</p>\n',
      '\n<p>\nDivide the input array in two halves by finding the middle-most index in the array and slicing the two halves around that index. Then, recursively apply Merge Sort to each half, and finally merge them into one single, sorted array by iterating through their values and progressively adding them to the new array in ascending order.\n</p>\n',
      '\n<p>\nYour implementation of Merge Sort almost certainly uses a lot of auxiliary space and likely does not sort the input array in place. What is the space complexity of your algorithm? Can you implement a version of the algorithm using only one additional array of the same length as the input array, and can this version sort the input array in place?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8, 5, 2, 9, 5, 6, 3],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function mergeSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.mergeSort = mergeSort;\n',
      solutions: [
        '// Best: O(nlog(n)) time | O(nlog(n)) space\n// Average: O(nlog(n)) time | O(nlog(n)) space\n// Worst: O(nlog(n)) time | O(nlog(n)) space\nfunction mergeSort(array) {\n  if (array.length <= 1) return array;\n  const middleIdx = Math.floor(array.length / 2);\n  const leftHalf = array.slice(0, middleIdx);\n  const rightHalf = array.slice(middleIdx);\n  return mergeSortedArrays(mergeSort(leftHalf), mergeSort(rightHalf));\n}\n\nfunction mergeSortedArrays(leftHalf, rightHalf) {\n  const sortedArray = new Array(leftHalf.length + rightHalf.length);\n  let k = 0;\n  let i = 0;\n  let j = 0;\n  while (i < leftHalf.length && j < rightHalf.length) {\n    if (leftHalf[i] <= rightHalf[j]) {\n      sortedArray[k++] = leftHalf[i++];\n    } else {\n      sortedArray[k++] = rightHalf[j++];\n    }\n  }\n  while (i < leftHalf.length) {\n    sortedArray[k++] = leftHalf[i++];\n  }\n  while (j < rightHalf.length) {\n    sortedArray[k++] = rightHalf[j++];\n  }\n  return sortedArray;\n}\n\nexports.mergeSort = mergeSort;\n',
        '// Best: O(nlog(n)) time | O(n) space\n// Average: O(nlog(n)) time | O(n) space\n// Worst: O(nlog(n)) time | O(n) space\nfunction mergeSort(array) {\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray);\n  return array;\n}\n\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray);\n}\n\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n  while (i <= middleIdx && j <= endIdx) {\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n  while (i <= middleIdx) {\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n  while (j <= endIdx) {\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n}\n\nexports.mergeSort = mergeSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.mergeSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.mergeSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
    },
    bigO: 'Best: O(nlog(n)) time | O(n) space - where n is the length of the input array\nAverage: O(nlog(n)) time | O(n) space - where n is the length of the input array\nWorst: O(nlog(n)) time | O(n) space - where n is the length of the input array',
    tests: [
      { array: [8, 5, 2, 9, 5, 6, 3] },
      { array: [1] },
      { array: [1, 2] },
      { array: [2, 1] },
      { array: [1, 3, 2] },
      { array: [3, 1, 2] },
      { array: [1, 2, 3] },
      {
        array: [
          -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6, -7,
          8,
        ],
      },
      {
        array: [
          -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
        ],
      },
      {
        array: [
          8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2, 7,
          -2, 4,
        ],
      },
      { array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1] },
      {
        array: [
          2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9, 8,
          1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
        ],
      },
      {
        array: [
          4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
          -2, -7, 4,
        ],
      },
      {
        array: [
          427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246, 12,
          -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348, -474,
          -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565, 892, 970,
          -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
        ],
      },
      {
        array: [
          991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998, 847,
          80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435, -269,
          652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980, 913,
          -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519, 906,
        ],
      },
      {
        array: [
          384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
          -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204, 776,
          -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367, -609,
          662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67, -389, 508,
          777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755, -978, 515,
          -68, -559, 489, 732, -19, -489, 737, 924,
        ],
      },
      {
        array: [
          544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
          -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
          -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568, -702,
          551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153, 788,
          844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150, -656, 528,
          61, 94, -581,
        ],
      },
      {
        array: [
          -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
          268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437, -453,
          -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67, 834,
          619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296, -90,
          401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505, -415,
          -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373, 915, -885,
          879, 391, -158, 588, -641, -937, 986, 949, -321,
        ],
      },
      {
        array: [
          -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
          842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
          -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
          892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
          341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800, -950,
          -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265, 746, 355,
          -578, -441, -254, -941, -738, -469, -167, -420, -126, -410, 59,
        ],
      },
    ],
  },
  {
    id: 'quick-sort',
    name: 'Quick Sort',
    category: 'Sorting',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Quick Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Quick Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>',
    hints: [
      '<p>\nQuick Sort works by picking a "pivot" number from an array, positioning every other number in the array in sorted order with respect to the pivot (all smaller numbers to the pivot\'s left; all bigger numbers to the pivot\'s right), and then repeating the same two steps on both sides of the pivot until the entire array is sorted.\n</p>\n',
      '\n<p>\nPick a random number from the input array (the first number, for instance) and let that number be the pivot. Iterate through the rest of the array using two pointers, one starting at the left extremity of the array and progressively moving to the right, and the other one starting at the right extremity of the array and progressively moving to the left. As you iterate through the array, compare the left and right pointer numbers to the pivot. If the left number is greater than the pivot and the right number is less than the pivot, swap them; this will effectively sort these numbers with respect to the pivot at the end of the iteration. If the left number is ever less than or equal to the pivot, increment the left pointer; similarly, if the right number is ever greater than or equal to the pivot, decrement the right pointer. Do this until the pointers pass each other, at which point swapping the pivot with the right number should position the pivot in its final, sorted position, where every number to its left is smaller and every number to its right is greater.\n</p>\n',
      '\n<p>\nRepeat the process mentioned in Hint #2 on the respective subarrays located to the left and right of your pivot, and keep on repeating the process thereafter until the input array is fully sorted.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8, 5, 2, 9, 5, 6, 3],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function quickSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.quickSort = quickSort;\n',
      solutions: [
        '// Best: O(nlog(n)) time | O(log(n)) space\n// Average: O(nlog(n)) time | O(log(n)) space\n// Worst: O(n^2) time | O(log(n)) space\nfunction quickSort(array) {\n  quickSortHelper(array, 0, array.length - 1);\n  return array;\n}\n\nfunction quickSortHelper(array, startIdx, endIdx) {\n  if (startIdx >= endIdx) return;\n  const pivotIdx = startIdx;\n  let leftIdx = startIdx + 1;\n  let rightIdx = endIdx;\n  while (rightIdx >= leftIdx) {\n    if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n      swap(leftIdx, rightIdx, array);\n    }\n    if (array[leftIdx] <= array[pivotIdx]) leftIdx++;\n    if (array[rightIdx] >= array[pivotIdx]) rightIdx--;\n  }\n  swap(pivotIdx, rightIdx, array);\n  const leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1);\n  if (leftSubarrayIsSmaller) {\n    quickSortHelper(array, startIdx, rightIdx - 1);\n    quickSortHelper(array, rightIdx + 1, endIdx);\n  } else {\n    quickSortHelper(array, rightIdx + 1, endIdx);\n    quickSortHelper(array, startIdx, rightIdx - 1);\n  }\n}\n\nfunction swap(i, j, array) {\n  let temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.quickSort = quickSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.quickSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.quickSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
    },
    bigO: 'Best: O(nlog(n)) time | O(log(n)) space - where n is the length of the input array\nAverage: O(nlog(n)) time | O(log(n)) space - where n is the length of the input array\nWorst: O(n^2) time | O(log(n)) space - where n is the length of the input array',
    tests: [
      { array: [8, 5, 2, 9, 5, 6, 3] },
      { array: [1] },
      { array: [1, 2] },
      { array: [2, 1] },
      { array: [1, 3, 2] },
      { array: [3, 1, 2] },
      { array: [1, 2, 3] },
      {
        array: [
          -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6, -7,
          8,
        ],
      },
      {
        array: [
          -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
        ],
      },
      {
        array: [
          8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2, 7,
          -2, 4,
        ],
      },
      { array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1] },
      {
        array: [
          2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9, 8,
          1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
        ],
      },
      {
        array: [
          4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
          -2, -7, 4,
        ],
      },
      {
        array: [
          427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246, 12,
          -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348, -474,
          -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565, 892, 970,
          -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
        ],
      },
      {
        array: [
          991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998, 847,
          80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435, -269,
          652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980, 913,
          -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519, 906,
        ],
      },
      {
        array: [
          384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
          -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204, 776,
          -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367, -609,
          662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67, -389, 508,
          777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755, -978, 515,
          -68, -559, 489, 732, -19, -489, 737, 924,
        ],
      },
      {
        array: [
          544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
          -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
          -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568, -702,
          551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153, 788,
          844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150, -656, 528,
          61, 94, -581,
        ],
      },
      {
        array: [
          -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
          268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437, -453,
          -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67, 834,
          619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296, -90,
          401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505, -415,
          -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373, 915, -885,
          879, 391, -158, 588, -641, -937, 986, 949, -321,
        ],
      },
      {
        array: [
          -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
          842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
          -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
          892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
          341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800, -950,
          -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265, 746, 355,
          -578, -441, -254, -941, -738, -469, -167, -420, -126, -410, 59,
        ],
      },
    ],
  },
  {
    id: 'heap-sort',
    name: 'Heap Sort',
    category: 'Sorting',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a sorted\n  version of that array. Use the Heap Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Heap Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 5, 6, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 3, 5, 5, 6, 8, 9]\n</pre>\n</div>',
    hints: [
      '<p>\nDivide the input array into two subarrays in place. The second subarray should be sorted at all times and should start with a length of 0, while the first subarray should be transformed into a max (or min) heap and should satisfy the heap property at all times.\n</p>\n',
      '\n<p>\nNote that the largest (or smallest) value of the heap should be at the very beginning of the newly-built heap. Start by swapping this value with the last value in the heap; the largest (or smallest) value in the array should now be in its correct position in the sorted subarray, which should now have a length of 1; the heap should now be one element smaller, with its first element out of place. Apply the "sift down" method of the heap to re-position this out-of-place value.\n</p>\n',
      '\n<p>\nRepeat the step mentioned in Hint #2 until the heap is left with only one value, at which point the entire array should be sorted.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8, 5, 2, 9, 5, 6, 3],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function heapSort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.heapSort = heapSort;\n',
      solutions: [
        '// Best: O(nlog(n)) time | O(1) space\n// Average: O(nlog(n)) time | O(1) space\n// Worst: O(nlog(n)) time | O(1) space\nfunction heapSort(array) {\n  buildMaxHeap(array);\n  for (let endIdx = array.length - 1; endIdx > 0; endIdx--) {\n    swap(0, endIdx, array);\n    siftDown(0, endIdx - 1, array);\n  }\n  return array;\n}\n\nfunction buildMaxHeap(array) {\n  const firstParentIdx = Math.floor((array.length - 2) / 2);\n  for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n    siftDown(currentIdx, array.length - 1, array);\n  }\n}\n\nfunction siftDown(currentIdx, endIdx, heap) {\n  let childOneIdx = currentIdx * 2 + 1;\n  while (childOneIdx <= endIdx) {\n    const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n    let idxToSwap;\n    if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\n      idxToSwap = childTwoIdx;\n    } else {\n      idxToSwap = childOneIdx;\n    }\n    if (heap[idxToSwap] > heap[currentIdx]) {\n      swap(currentIdx, idxToSwap, heap);\n      currentIdx = idxToSwap;\n      childOneIdx = currentIdx * 2 + 1;\n    } else {\n      return;\n    }\n  }\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.heapSort = heapSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.heapSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8, 5, 2, 9, 5, 6, 3];\n  chai.expect(program.heapSort(input)).to.deep.equal([2, 3, 5, 5, 6, 8, 9]);\n});\n",
    },
    bigO: 'Best: O(nlog(n)) time | O(1) space - where n is the length of the input array\nAverage: O(nlog(n)) time | O(1) space - where n is the length of the input array\nWorst: O(nlog(n)) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [8, 5, 2, 9, 5, 6, 3] },
      { array: [1] },
      { array: [1, 2] },
      { array: [2, 1] },
      { array: [1, 3, 2] },
      { array: [3, 1, 2] },
      { array: [1, 2, 3] },
      {
        array: [
          -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6, -7,
          8,
        ],
      },
      {
        array: [
          -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
        ],
      },
      {
        array: [
          8, -6, 7, 10, 8, -1, 6, 2, 4, -5, 1, 10, 8, -10, -9, -10, 8, 9, -2, 7,
          -2, 4,
        ],
      },
      { array: [5, -2, 2, -8, 3, -10, -6, -1, 2, -2, 9, 1, 1] },
      {
        array: [
          2, -2, -6, -10, 10, 4, -8, -1, -8, -4, 7, -4, 0, 9, -9, 0, -9, -9, 8,
          1, -4, 4, 8, 5, 1, 5, 0, 0, 2, -10,
        ],
      },
      {
        array: [
          4, 1, 5, 0, -9, -3, -3, 9, 3, -4, -9, 8, 1, -3, -7, -4, -9, -1, -7,
          -2, -7, 4,
        ],
      },
      {
        array: [
          427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246, 12,
          -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348, -474,
          -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565, 892, 970,
          -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
        ],
      },
      {
        array: [
          991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998, 847,
          80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435, -269,
          652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980, 913,
          -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519, 906,
        ],
      },
      {
        array: [
          384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
          -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204, 776,
          -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367, -609,
          662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67, -389, 508,
          777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755, -978, 515,
          -68, -559, 489, 732, -19, -489, 737, 924,
        ],
      },
      {
        array: [
          544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
          -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
          -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568, -702,
          551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153, 788,
          844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150, -656, 528,
          61, 94, -581,
        ],
      },
      {
        array: [
          -19, 759, 168, 306, 270, -602, 558, -821, -599, 328, 753, -50, -568,
          268, -92, 381, -96, 730, 629, 678, -837, 351, 896, 63, -85, 437, -453,
          -991, 294, -384, -628, -529, 518, 613, -319, -519, -220, -67, 834,
          619, 802, 207, 946, -904, 295, 718, -740, -557, -560, 80, 296, -90,
          401, 407, 798, 254, 154, 387, 434, 491, 228, 307, 268, 505, -415,
          -976, 676, -917, 937, -609, 593, -36, 881, 607, 121, -373, 915, -885,
          879, 391, -158, 588, -641, -937, 986, 949, -321,
        ],
      },
      {
        array: [
          -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
          842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
          -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
          892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
          341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800, -950,
          -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265, 746, 355,
          -578, -441, -254, -941, -738, -469, -167, -420, -126, -410, 59,
        ],
      },
    ],
  },
  {
    id: 'three-number-sort',
    name: 'Three Number Sort',
    category: 'Sorting',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an array of integers and another array of three distinct\n  integers. The first array is guaranteed to only contain integers that are in\n  the second array, and the second array represents a desired order for the\n  integers in the first array. For example, a second array of\n  <span>[x, y, z]</span> represents a desired order of\n  <span>[x, x, ..., x, y, y, ..., y, z, z, ..., z]</span> in the first array.\n</p>\n<p>\n  Write a function that sorts the first array according to the desired order in\n  the second array.\n</p>\n<p>\n  The function should perform this in place (i.e., it should mutate the input\n  array), and it shouldn\'t use any auxiliary space (i.e., it should run with\n  constant space: <span>O(1)</span> space).\n</p>\n<p>\n  Note that the desired order won\'t necessarily be ascending or descending and\n  that the first array won\'t necessarily contain all three integers found in the\n  second arrayit might only contain one or two.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 0, 0, -1, -1, 0, 1, 1]\n<span class="CodeEditor-promptParameter">order</span> = [0, 1, -1]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[0, 0, 0, 1, 1, 1, -1, -1]\n</pre>\n</div>',
    hints: [
      '<p>\nWhat advantage does knowing the three values contained in the array give you, and how can you use that to solve this problem in linear time?\n</p>\n',
      '\n<p>\nTry counting how many times each of the three values appears in the input array. Once you have these counts, you can repopulate the input array as need be.\n</p>\n',
      "\n<p>\nPutting aside the first two hints, try conceptually splitting the original array into three subarrays and moving elements of each unique value into the correct subarray. You'll need to keep track of the respective starting indices of these subarrays.\n</p>\n",
      "\n<p>\nGoing off of Hint #3, you can solve this problem either with two passes through the input array or with a single pass. If you do two passes through the array, you'll specifically be positioning the first ordered element during the first pass and the third ordered element during the second pass. You'll be swapping elements from the left side of the array whenever you encounter the first element, and you'll be swapping elements from the right side of the array whenever you encounter the third element. You'll have to keep track of where you last placed a first element or a third element. With a single pass through the array, you'll have to implement both of these strategies and a little more all at once.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 0, 0, -1, -1, 0, 1, 1],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      {
        name: 'order',
        example: [0, 1, -1],
        schema: {
          items: { type: 'integer' },
          maxItems: 3,
          minItems: 3,
          type: 'array',
          uniqueItems: true,
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function threeNumberSort(array, order) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.threeNumberSort = threeNumberSort;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the length of the array\nfunction threeNumberSort(array, order) {\n  const valueCounts = [0, 0, 0];\n\n  for (const element of array) {\n    const orderIdx = order.indexOf(element);\n    valueCounts[orderIdx]++;\n  }\n\n  for (let idx = 0; idx < 3; idx++) {\n    const value = order[idx];\n    const count = valueCounts[idx];\n\n    const numElementsBefore = valueCounts.slice(0, idx).reduce((a, b) => a + b, 0);\n    for (let n = 0; n < count; n++) {\n      const currentIdx = numElementsBefore + n;\n      array[currentIdx] = value;\n    }\n  }\n\n  return array;\n}\n\n// Do not edit the line below.\nexports.threeNumberSort = threeNumberSort;\n',
        '// O(n) time | O(1) space - where n is the length of the array\nfunction threeNumberSort(array, order) {\n  const firstValue = order[0];\n  const thirdValue = order[2];\n\n  let firstIdx = 0;\n  for (let idx = 0; idx < array.length; idx++) {\n    if (array[idx] === firstValue) {\n      swap(firstIdx, idx, array);\n      firstIdx++;\n    }\n  }\n\n  let thirdIdx = array.length - 1;\n  for (let idx = array.length - 1; idx > -1; idx--) {\n    if (array[idx] === thirdValue) {\n      swap(thirdIdx, idx, array);\n      thirdIdx--;\n    }\n  }\n\n  return array;\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\n// Do not edit the line below.\nexports.threeNumberSort = threeNumberSort;\n',
        '// O(n) time | O(1) space - where n is the length of the array\nfunction threeNumberSort(array, order) {\n  const firstValue = order[0];\n  const secondValue = order[1];\n\n  // Keep track of the indices where the values are stored\n  let firstIdx = 0;\n  let secondIdx = 0;\n  let thirdIdx = array.length - 1;\n\n  while (secondIdx <= thirdIdx) {\n    const value = array[secondIdx];\n\n    if (value === firstValue) {\n      swap(firstIdx, secondIdx, array);\n      firstIdx++;\n      secondIdx++;\n    } else if (value === secondValue) {\n      secondIdx++;\n    } else {\n      swap(secondIdx, thirdIdx, array);\n      thirdIdx -= 1;\n    }\n  }\n\n  return array;\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\n// Do not edit the line below.\nexports.threeNumberSort = threeNumberSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [1, 0, 0, -1, -1, 0, 1, 1];\n  const order = [0, 1, -1];\n  const expected = [0, 0, 0, 1, 1, 1, -1, -1];\n  const actual = program.threeNumberSort(array, order);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [1, 0, 0, -1, -1, 0, 1, 1];\n  const order = [0, 1, -1];\n  const expected = [0, 0, 0, 1, 1, 1, -1, -1];\n  const actual = program.threeNumberSort(array, order);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the array',
    tests: [
      { array: [1, 0, 0, -1, -1, 0, 1, 1], order: [0, 1, -1] },
      { array: [7, 8, 9, 7, 8, 9, 9, 9, 9, 9, 9, 9], order: [8, 7, 9] },
      { array: [], order: [0, 7, 9] },
      { array: [-2, -3, -3, -3, -3, -3, -2, -2, -3], order: [-2, -3, 0] },
      {
        array: [0, 10, 10, 10, 10, 10, 25, 25, 25, 25, 25],
        order: [25, 10, 0],
      },
      { array: [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], order: [4, 5, 6] },
      {
        array: [1, 3, 4, 4, 4, 4, 3, 3, 3, 4, 1, 1, 1, 4, 4, 1, 3, 1, 4, 4],
        order: [1, 4, 3],
      },
      { array: [1, 2, 3], order: [3, 1, 2] },
      { array: [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 1, 2], order: [1, 2, 0] },
      { array: [7, 7, 7, 11, 11, 7, 11, 7], order: [11, 7, 9] },
      { array: [9, 9, 9, 7, 9, 7, 9, 9, 7, 9], order: [11, 7, 9] },
      { array: [9, 9, 9, 7, 9, 7, 9, 9, 7, 9], order: [7, 11, 9] },
      { array: [1], order: [0, 1, 2] },
      { array: [0, 1], order: [1, 2, 0] },
    ],
  },
  {
    id: 'count-inversions',
    name: 'Count Inversions',
    category: 'Sorting',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns the number of\n  inversions in the array. An inversion occurs if for any valid indices\n  <span>i</span> and <span>j</span>, <span>i &lt; j</span> and\n  <span>array[i] > array[j]</span>.\n</p>\n<p>\n  For example, given <span>array = [3, 4, 1, 2]</span>, there are\n  <span>4</span> inversions. The following pairs of indices represent\n  inversions: <span>[0, 2], [0, 3], [1, 2], [1, 3]</span>.\n</p>\n<p>\n  Intuitively, the number of inversions is a measure of how unsorted the array\n  is.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 3, 3, 1, 9, 5, 6]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5\n<span class="CodeEditor-promptComment">// The following pairs of indices represent inversions:</span>\n<span class="CodeEditor-promptComment">// [0, 3], [1, 3], [2, 3], [4, 5], [4, 6]</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  The brute-force approach to solve this problem is to simply compare every pair\n  of indices in the array and to determine how many of them represent\n  inversions. This approach takes <span>O(n^2)</span> time, where n is the\n  length of the array. Can you do better than this?\n</p>\n',
      '\n<p>\n  If the number of inversions is the degree to which the array is unsorted, and\n  it if it takes <span>O(nlog(n))</span> time to sort an array using an optimal\n  sorting algorithm, can you determine how unsorted the array is with a solution\n  that runs in that time complexity?\n</p>\n',
      "\n<p>\n  Try thinking about how you would solve this problem if, instead of being given\n  one array, you were given two separate arrays representing the main array's\n  two halves. You would need to determine the number of inversions in the array\n  created by merging the left array and the right array. The number of\n  inversions in this example is actually equal to the number of inversions in\n  the left array, the number of inversions in the right array, <b>and</b> the\n  number of inversions when you merge the <b>sorted</b> left array and the\n  <b>sorted</b> right array. Recall how Merge Sort works for a hint about how\n  you can solve this problem.\n</p>\n",
      "\n<p>\n  Once you understand the information stated in Hint #3, you can use an\n  algorithm that's very similar to Merge Sort to determine the number of\n  inversions in any array. You'll recursively determine the number of inversions\n  in the left and right halves of an array while sorting both the left and right\n  halves, just like you do in Merge Sort. Once your two halves are sorted,\n  you'll merge them together and count the number of inversions in the merged\n  array. Take the example of these two sorted arrays:\n  <span>a1 = [1, 3, 4]</span> and <span>a2 = [2, 2, 5]</span>. When you merge\n  these two sorted arrays, you insert elements from the left and right array\n  into one larger array. Whenever you insert an element from the right array\n  before inserting an element from the left array, that means an inversion or\n  multiple inversions have occurred. This is because elements in the right array\n  are positioned after all elements in the left array (if these two arrays were\n  originally left and right halves of another array). The remaining elements to\n  be inserted from the left array when we insert an element from the right array\n  are all inverted with this right-array element. See the Conceptual Overview\n  section of this question's video explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [2, 3, 3, 1, 9, 5, 6],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function countInversions(array) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.countInversions = countInversions;\n',
      solutions: [
        '// O(nlogn) time | O(n) space - where n is the length of the array\nfunction countInversions(array) {\n  return countSubArrayInversions(array, 0, array.length);\n}\n\nfunction countSubArrayInversions(array, start, end) {\n  if (end - start <= 1) return 0;\n\n  const middle = start + Math.floor((end - start) / 2);\n  const leftInversions = countSubArrayInversions(array, start, middle);\n  const rightInversions = countSubArrayInversions(array, middle, end);\n  const mergedArrayInversions = mergeSortAndCountInversions(array, start, middle, end);\n  return leftInversions + rightInversions + mergedArrayInversions;\n}\n\nfunction mergeSortAndCountInversions(array, start, middle, end) {\n  const sortedArray = [];\n  let left = start;\n  let right = middle;\n  let inversions = 0;\n\n  while (left < middle && right < end) {\n    if (array[left] <= array[right]) {\n      sortedArray.push(array[left]);\n      left++;\n    } else {\n      inversions += middle - left;\n      sortedArray.push(array[right]);\n      right++;\n    }\n  }\n\n  sortedArray.push(...array.slice(left, middle), ...array.slice(right, end));\n  for (let idx = 0; idx < sortedArray.length; idx++) {\n    const num = sortedArray[idx];\n    array[start + idx] = num;\n  }\n\n  return inversions;\n}\n\n// Do not edit the line below.\nexports.countInversions = countInversions;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 3, 3, 1, 9, 5, 6];\n  const expected = 5;\n  const actual = program.countInversions(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 3, 3, 1, 9, 5, 6];\n  const expected = 5;\n  const actual = program.countInversions(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlogn) time | O(n) space - where n is the length of the array',
    tests: [
      { array: [2, 3, 3, 1, 9, 5, 6] },
      { array: [] },
      { array: [1, 2, 3, 4, 5, 6, -1] },
      { array: [0, 2, 4, 5, 76] },
      { array: [54, 1, 2, 3, 4] },
      { array: [1, 10, 2, 8, 3, 7, 4, 6, 5] },
      { array: [2, -18] },
      { array: [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1] },
      { array: [5, -1, 2, -4, 3, 4, 19, 87, 762, -8, 0] },
      { array: [1, 1, 1, 1, 1, 1, 1, 1] },
      { array: [1, 1, 1, 1, 0, 1, 1, 1] },
      { array: [2, 2, 2, 2, 1, 1, 1, 1, 3, 3, 3, 3] },
      { array: [3, 1, 2] },
      { array: [3, 2, 1, 1] },
      {
        array: [10, 7, 2, 3, 1, -9, -86, -862, 234, 312, 3421, 23, 0, 2, 1, 2],
      },
    ],
  },
  {
    id: 'radix-sort',
    name: 'Radix Sort',
    category: 'Sorting',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of non-negative integers and returns a\n  sorted version of that array. Use the Radix Sort algorithm to sort the array.\n</p>\n<p>\n  If you\'re unfamiliar with Radix Sort, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8762, 654, 3008, 345, 87, 65, 234, 12, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 12, 65, 87, 234, 345, 654, 3008, 8762]\n</pre>\n</div>',
    hints: [
      "<p>\n  Radix Sort sorts numbers by looking only at one of their digits at a time. It\n  first sorts all of the given numbers by their ones' column, then by their\n  tens' column, then by their hundreds' column, and so on and so forth until\n  they're fully sorted.\n</p>\n",
      "\n<p>\n  Radix Sort uses an intermediary sorting algorithm to sort numbers one digits'\n  column at a time. The goal of Radix Sort is to perform a more efficient sort\n  than popular sorting algorithms like Merge Sort or Quick Sort for inputs that\n  are well suited to be sorted by their individual digits' columns. With this in\n  mind, what intermediary sorting algorithm should we use with Radix Sort? Keep\n  in mind that this sorting algorithm will run multiple times, sorting one\n  digits' column at a time.\n</p>\n",
      "\n<p>\n  The most popular sorting algorithm to use with Radix Sort is Counting Sort.\n  Counting Sort takes advantage of the fact that we know the range of possible\n  values that we need to sort. When sorting numbers, we know that we only need\n  to sort digits, which will always be in the range <span>0-9</span>. Therefore,\n  we can count how many times these digits occur and use those counts to\n  populate a new sorted array. We'll perform counting sort multiple times, once\n  for each digits' column that we're sorting, starting with the ones' column. We\n  need to ensure that our counting sort performs a stable sort, so that we don't\n  lose information from previous iterations of sorting. Counting sort runs in\n  <span>O(n)</span> time, which means that we might have a much more efficient\n  sorting algorithm if the largest number in our input contains few digits. See\n  the Conceptual Overview section of this question's video explanation for a\n  more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8762, 654, 3008, 345, 87, 65, 234, 12, 2],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function radixSort(array) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.radixSort = radixSort;\n',
      solutions: [
        '// O(d * (n + b)) time | O(n + b) space - where n is the length of the input array,\n// d is the max number of digits, and b is the base of the numbering system used\nfunction radixSort(array) {\n  if (array.length === 0) return array;\n\n  const maxNumber = Math.max(...array);\n\n  let digit = 0;\n  while (maxNumber / 10 ** digit > 0) {\n    countingSort(array, digit);\n    digit++;\n  }\n\n  return array;\n}\n\nfunction countingSort(array, digit) {\n  const sortedArray = new Array(array.length).fill(0);\n  const countArray = new Array(10).fill(0);\n\n  const digitColumn = 10 ** digit;\n  for (const num of array) {\n    const countIndex = Math.floor(num / digitColumn) % 10;\n    countArray[countIndex]++;\n  }\n\n  for (let idx = 1; idx < 10; idx++) {\n    countArray[idx] += countArray[idx - 1];\n  }\n\n  for (let idx = array.length - 1; idx > -1; idx--) {\n    const countIndex = Math.floor(array[idx] / digitColumn) % 10;\n    countArray[countIndex]--;\n    const sortedIndex = countArray[countIndex];\n    sortedArray[sortedIndex] = array[idx];\n  }\n\n  for (let idx = 0; idx < array.length; idx++) {\n    array[idx] = sortedArray[idx];\n  }\n}\n\n// Do not edit the line below.\nexports.radixSort = radixSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8762, 654, 3008, 345, 87, 65, 234, 12, 2];\n  const expected = [2, 12, 65, 87, 234, 345, 654, 3008, 8762];\n  const actual = program.radixSort(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [8762, 654, 3008, 345, 87, 65, 234, 12, 2];\n  const expected = [2, 12, 65, 87, 234, 345, 654, 3008, 8762];\n  const actual = program.radixSort(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(d * (n + b)) time | O(n + b) space - where n is the length of the input array, d is the max number of digits, and b is the base of the numbering system used',
    tests: [
      { array: [8762, 654, 3008, 345, 87, 65, 234, 12, 2] },
      { array: [2, 12, 65, 87, 234, 345, 654, 3008, 8762] },
      { array: [111, 11, 11, 1, 0] },
      { array: [12, 123, 456, 986, 2, 3, 34, 543, 97654, 34200] },
      { array: [4, 44, 444, 888, 88, 33, 3, 22, 2222, 1111, 1234] },
      { array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] },
      { array: [] },
      { array: [100] },
      { array: [10000, 100001, 10001, 10101, 101, 11, 100, 10, 1, 0] },
      {
        array: [
          34, 56, 7373, 2321, 3421, 8272, 232, 23892831, 230983, 2312, 7878, 87,
          234, 23, 332, 4556,
        ],
      },
      {
        array: [
          10, 87, 2321, 3221, 2312, 7632, 6542, 3223, 231, 2342, 321, 9, 1, 323,
          421, 325, 65, 789, 4002,
        ],
      },
      { array: [0, 1, 2, 22, 11, 3, 33, 0, 0, 0, 21, 21, 21, 1, 11, 111] },
      { array: [8, 4, 5, 34, 234, 987, 444, 23, 21, 8, 1, 0] },
      { array: [1, 11] },
      { array: [1, 11, 1, 11, 101, 9, 99, 432, 441] },
      { array: [1000, 100, 10, 1, 10, 100, 1000, 10001, 10201, 1001, 0, 1, 1] },
      { array: [9, 109, 908, 876, 1099, 190, 290, 999, 9999] },
      {
        array: [
          0, 999999, 234892, 10000009, 89892, 782731, 891932, 92012, 1892193,
          181730, 785239, 2314451, 1231421, 812723,
        ],
      },
    ],
  },
  {
    id: 'depth-first-search',
    name: 'Depth-first Search',
    category: 'Graphs',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a <span>Node</span> class that has a <span>name</span> and an\n  array of optional <span>children</span> nodes. When put together, nodes form\n  an acyclic tree-like structure.\n</p>\n<p>\n  Implement the <span>depthFirstSearch</span> method on the\n  <span>Node</span> class, which takes in an empty array, traverses the tree\n  using the Depth-first Search approach (specifically navigating the tree from\n  left to right), stores all of the nodes\' names in the input array, and returns\n  it.\n</p>\n<p>\n  If you\'re unfamiliar with Depth-first Search, we recommend watching the\n  Conceptual Overview section of this question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">graph</span> = A\n     /  |  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    B   C   D\n   / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  E   F   G   H\n     / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    I   J   K\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["A", "B", "E", "F", "I", "J", "C", "D", "G", "K", "H"]\n</pre>\n</div>',
    hints: [
      "<p>\nThe Depth-first Search algorithm works by traversing a graph branch by branch. In other words, before traversing any Node's sibling Nodes, its children nodes must be traversed. How can you simply and effectively keep track of Nodes' sibling Nodes as you traverse them, all the while retaining the order in which you must traverse them?\n</p>\n",
      "\n<p>\nStart at the root Node and try simply calling the depthFirstSearch method on all of its children Nodes. Then, call the depthFirstSearch method on all children Nodes of each child node. Keep applying this logic until the entire graph has been traversed. Don't forget to add the current Node's name to the input array at every call of depthFirstSearch.\n</p>",
    ],
    customInputVars: [
      {
        name: 'graph',
        example: {
          nodes: [
            { children: ['B', 'C', 'D'], id: 'A', value: 'A' },
            { children: ['E', 'F'], id: 'B', value: 'B' },
            { children: [], id: 'C', value: 'C' },
            { children: ['G', 'H'], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: ['I', 'J'], id: 'F', value: 'F' },
            { children: ['K'], id: 'G', value: 'G' },
            { children: [], id: 'H', value: 'H' },
            { children: [], id: 'I', value: 'I' },
            { children: [], id: 'J', value: 'J' },
            { children: [], id: 'K', value: 'K' },
          ],
          startNode: 'A',
        },
        schema: {
          description:
            "For the purpose of this question, a <span>graph</span> is represented by a list of <span>nodes</span> and a <span>startNode</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes' lists of <span>children</span> and by the <span>startNode</span>.\nThe searching function will be called on the <span>startNode</span>.<br />\nRemember that your graph shouldn't have cycles!\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  children: {
                    items: { type: 'string' },
                    type: 'array',
                    uniqueItems: true,
                  },
                  id: { type: 'string' },
                  value: { type: 'string' },
                },
                required: ['id', 'value', 'children'],
                type: 'object',
              },
              type: 'array',
            },
            startNode: { type: 'string' },
          },
          required: ['startNode', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Do not edit the class below except\n// for the depthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nclass Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  depthFirstSearch(array) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.Node = Node;\n',
      solutions: [
        'class Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  // O(v + e) time | O(v) space\n  depthFirstSearch(array) {\n    array.push(this.name);\n    for (const child of this.children) {\n      child.depthFirstSearch(array);\n    }\n    return array;\n  }\n}\n\nexports.Node = Node;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai\n    .expect(graph.depthFirstSearch([]))\n    .to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai\n    .expect(graph.depthFirstSearch([]))\n    .to.deep.equal(['A', 'B', 'E', 'F', 'I', 'J', 'C', 'D', 'G', 'K', 'H']);\n});\n",
    },
    bigO: 'O(v + e) time | O(v) space - where v is the number of vertices of the input graph and e is the number of edges of the input graph',
    tests: [
      {
        graph: {
          nodes: [
            { children: ['B', 'C', 'D'], id: 'A', value: 'A' },
            { children: ['E', 'F'], id: 'B', value: 'B' },
            { children: [], id: 'C', value: 'C' },
            { children: ['G', 'H'], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: ['I', 'J'], id: 'F', value: 'F' },
            { children: ['K'], id: 'G', value: 'G' },
            { children: [], id: 'H', value: 'H' },
            { children: [], id: 'I', value: 'I' },
            { children: [], id: 'J', value: 'J' },
            { children: [], id: 'K', value: 'K' },
          ],
          startNode: 'A',
        },
      },
      {
        graph: {
          nodes: [
            { children: ['B', 'C'], id: 'A', value: 'A' },
            { children: ['D'], id: 'B', value: 'B' },
            { children: [], id: 'C', value: 'C' },
            { children: [], id: 'D', value: 'D' },
          ],
          startNode: 'A',
        },
      },
      {
        graph: {
          nodes: [
            { children: ['B', 'C', 'D', 'E'], id: 'A', value: 'A' },
            { children: [], id: 'B', value: 'B' },
            { children: ['F'], id: 'C', value: 'C' },
            { children: [], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: [], id: 'F', value: 'F' },
          ],
          startNode: 'A',
        },
      },
      {
        graph: {
          nodes: [
            { children: ['B'], id: 'A', value: 'A' },
            { children: ['C'], id: 'B', value: 'B' },
            { children: ['D', 'E'], id: 'C', value: 'C' },
            { children: ['F'], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: [], id: 'F', value: 'F' },
          ],
          startNode: 'A',
        },
      },
      {
        graph: {
          nodes: [
            { children: ['B', 'C', 'D', 'E', 'F'], id: 'A', value: 'A' },
            { children: ['G', 'H', 'I'], id: 'B', value: 'B' },
            { children: ['J'], id: 'C', value: 'C' },
            { children: ['K', 'L'], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: ['M', 'N'], id: 'F', value: 'F' },
            { children: [], id: 'G', value: 'G' },
            { children: ['O', 'P', 'Q', 'R'], id: 'H', value: 'H' },
            { children: [], id: 'I', value: 'I' },
            { children: [], id: 'J', value: 'J' },
            { children: ['S'], id: 'K', value: 'K' },
            { children: [], id: 'L', value: 'L' },
            { children: [], id: 'M', value: 'M' },
            { children: [], id: 'N', value: 'N' },
            { children: [], id: 'O', value: 'O' },
            { children: ['T', 'U'], id: 'P', value: 'P' },
            { children: [], id: 'Q', value: 'Q' },
            { children: ['V'], id: 'R', value: 'R' },
            { children: [], id: 'S', value: 'S' },
            { children: [], id: 'T', value: 'T' },
            { children: [], id: 'U', value: 'U' },
            { children: ['W', 'X', 'Y'], id: 'V', value: 'V' },
            { children: [], id: 'W', value: 'W' },
            { children: ['Z'], id: 'X', value: 'X' },
            { children: [], id: 'Y', value: 'Y' },
            { children: [], id: 'Z', value: 'Z' },
          ],
          startNode: 'A',
        },
      },
    ],
  },
  {
    id: 'single-cycle-check',
    name: 'Single Cycle Check',
    category: 'Graphs',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an array of integers where each integer represents a jump of its\n  value in the array. For instance, the integer <span>2</span> represents a jump\n  of two indices forward in the array; the integer <span>-3</span> represents a\n  jump of three indices backward in the array.\n</p>\n<p>\n  If a jump spills past the array\'s bounds, it wraps over to the other side. For\n  instance, a jump of <span>-1</span> at index <span>0</span> brings us to the last index in\n  the array. Similarly, a jump of <span>1</span> at the last index in the array brings us to\n  index <span>0</span>.\n</p>\n<p>\n  Write a function that returns a boolean representing whether the jumps in the\n  array form a single cycle. A single cycle occurs if, starting at any index in\n  the array and following the jumps, every element in the array is visited\n  exactly once before landing back on the starting index.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 3, 1, -4, -4, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      "<p>\nIn order to check if the input array has a single cycle, you have to jump through all of the elements in the array. Could you keep a counter, jump through elements in the array, and stop once you've jumped through as many elements as are contained in the array?\n</p>\n",
      "\n<p>\nAssume the input array has length n. If you start at index 0 and jump through n elements, what are the simplest conditions that you can check to see if the array doesn't have a single cycle?\n</p>\n",
      "\n<p>\nGiven Hint #2, there are 2 conditions that need to be met for the input array to have a single cycle. First, the starting element (in this case, the element at index 0) cannot be jumped through more than once, at the very beginning, so long as you haven't jumped through all of the other elements in the array. Second, the (n + 1)th element you jump through, where n is the length of the array, must be the first element you visited: the element at index 0 in this case.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [2, 3, 1, -4, -4, 2],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function hasSingleCycle(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.hasSingleCycle = hasSingleCycle;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction hasSingleCycle(array) {\n  let numElementsVisited = 0;\n  let currentIdx = 0;\n  while (numElementsVisited < array.length) {\n    if (numElementsVisited > 0 && currentIdx === 0) return false;\n    numElementsVisited++;\n    currentIdx = getNextIdx(currentIdx, array);\n  }\n  return currentIdx === 0;\n}\n\nfunction getNextIdx(currentIdx, array) {\n  const jump = array[currentIdx];\n  const nextIdx = (currentIdx + jump) % array.length;\n  return nextIdx >= 0 ? nextIdx : nextIdx + array.length;\n}\n\nexports.hasSingleCycle = hasSingleCycle;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.hasSingleCycle([2, 3, 1, -4, -4, 2])).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.hasSingleCycle([2, 3, 1, -4, -4, 2])).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [2, 3, 1, -4, -4, 2] },
      { array: [2, 2, -1] },
      { array: [2, 2, 2] },
      { array: [1, 1, 1, 1, 1] },
      { array: [-1, 2, 2] },
      { array: [0, 1, 1, 1, 1] },
      { array: [1, 1, 0, 1, 1] },
      { array: [1, 1, 1, 1, 2] },
      { array: [3, 5, 6, -5, -2, -5, -12, -2, -1, 2, -6, 1, 1, 2, -5, 2] },
      { array: [3, 5, 5, -5, -2, -5, -12, -2, -1, 2, -6, 1, 1, 2, -5, 2] },
      { array: [1, 2, 3, 4, -2, 3, 7, 8, 1] },
      { array: [1, 2, 3, 4, -2, 3, 7, 8, -8] },
      { array: [1, 2, 3, 4, -2, 3, 7, 8, -26] },
      { array: [10, 11, -6, -23, -2, 3, 88, 908, -26] },
      { array: [10, 11, -6, -23, -2, 3, 88, 909, -26] },
      { array: [1, -1, 1, -1] },
    ],
  },
  {
    id: 'breadth-first-search',
    name: 'Breadth-first Search',
    category: 'Graphs',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a <span>Node</span> class that has a <span>name</span> and an\n  array of optional <span>children</span> nodes. When put together, nodes form\n  an acyclic tree-like structure.\n</p>\n<p>\n  Implement the <span>breadthFirstSearch</span> method on the\n  <span>Node</span> class, which takes in an empty array, traverses the tree\n  using the Breadth-first Search approach (specifically navigating the tree from\n  left to right), stores all of the nodes\' names in the input array, and returns\n  it.\n</p>\n<p>\n  If you\'re unfamiliar with Breadth-first Search, we recommend watching the\n  Conceptual Overview section of this question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">graph</span> = A\n     /  |  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    B   C   D\n   / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  E   F   G   H\n     / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    I   J   K\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"]\n</pre>\n</div>',
    hints: [
      "<p>\nThe Breadth-first Search algorithm works by traversing a graph level by level. In other words, before traversing any Node's children Nodes, its sibling nodes must be traversed. How can you simply and effectively keep track of Nodes' children Nodes as you traverse them, all the while retaining the order in which you must traverse them?\n</p>\n",
      "\n<p>\nTry using a queue to store all of the future Nodes that you will need to explore as your traverse the graph. By adding Nodes' children Nodes to the queue every time you explore them and by using the First-In-First-Out property of the queue, you can traverse the graph in a Breadth-first Search way. Don't forget to add every Node's name to the input array as you traverse the graph.\n</p>",
    ],
    customInputVars: [
      {
        name: 'graph',
        example: {
          nodes: [
            { children: ['B', 'C', 'D'], id: 'A', value: 'A' },
            { children: ['E', 'F'], id: 'B', value: 'B' },
            { children: [], id: 'C', value: 'C' },
            { children: ['G', 'H'], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: ['I', 'J'], id: 'F', value: 'F' },
            { children: ['K'], id: 'G', value: 'G' },
            { children: [], id: 'H', value: 'H' },
            { children: [], id: 'I', value: 'I' },
            { children: [], id: 'J', value: 'J' },
            { children: [], id: 'K', value: 'K' },
          ],
          startNode: 'A',
        },
        schema: {
          description:
            "For the purpose of this question, a <span>graph</span> is represented by a list of <span>nodes</span> and a <span>startNode</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes' lists of <span>children</span> and by the <span>startNode</span>.\nThe searching function will be called on the <span>startNode</span>.<br />\nRemember that your graph shouldn't have cycles!\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  children: {
                    items: { type: 'string' },
                    type: 'array',
                    uniqueItems: true,
                  },
                  id: { type: 'string' },
                  value: { type: 'string' },
                },
                required: ['id', 'value', 'children'],
                type: 'object',
              },
              type: 'array',
            },
            startNode: { type: 'string' },
          },
          required: ['startNode', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Do not edit the class below except\n// for the breadthFirstSearch method.\n// Feel free to add new properties\n// and methods to the class.\nclass Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  breadthFirstSearch(array) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.Node = Node;\n',
      solutions: [
        'class Node {\n  constructor(name) {\n    this.name = name;\n    this.children = [];\n  }\n\n  addChild(name) {\n    this.children.push(new Node(name));\n    return this;\n  }\n\n  // O(v + e) time | O(v) space\n  breadthFirstSearch(array) {\n    const queue = [this];\n    while (queue.length > 0) {\n      const current = queue.shift();\n      array.push(current.name);\n      for (const child of current.children) {\n        queue.push(child);\n      }\n    }\n    return array;\n  }\n}\n\nexports.Node = Node;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai\n    .expect(graph.breadthFirstSearch([]))\n    .to.deep.equal(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const graph = new program.Node('A');\n  graph.addChild('B').addChild('C').addChild('D');\n  graph.children[0].addChild('E').addChild('F');\n  graph.children[2].addChild('G').addChild('H');\n  graph.children[0].children[1].addChild('I').addChild('J');\n  graph.children[2].children[0].addChild('K');\n  chai\n    .expect(graph.breadthFirstSearch([]))\n    .to.deep.equal(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']);\n});\n",
    },
    bigO: 'O(v + e) time | O(v) space - where v is the number of vertices of the input graph and e is the number of edges of the input graph',
    tests: [
      {
        graph: {
          nodes: [
            { children: ['B', 'C', 'D'], id: 'A', value: 'A' },
            { children: ['E', 'F'], id: 'B', value: 'B' },
            { children: [], id: 'C', value: 'C' },
            { children: ['G', 'H'], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: ['I', 'J'], id: 'F', value: 'F' },
            { children: ['K'], id: 'G', value: 'G' },
            { children: [], id: 'H', value: 'H' },
            { children: [], id: 'I', value: 'I' },
            { children: [], id: 'J', value: 'J' },
            { children: [], id: 'K', value: 'K' },
          ],
          startNode: 'A',
        },
      },
      {
        graph: {
          nodes: [
            { children: ['B', 'C'], id: 'A', value: 'A' },
            { children: ['D'], id: 'B', value: 'B' },
            { children: [], id: 'C', value: 'C' },
            { children: [], id: 'D', value: 'D' },
          ],
          startNode: 'A',
        },
      },
      {
        graph: {
          nodes: [
            { children: ['B', 'C', 'D', 'E'], id: 'A', value: 'A' },
            { children: [], id: 'B', value: 'B' },
            { children: ['F'], id: 'C', value: 'C' },
            { children: [], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: [], id: 'F', value: 'F' },
          ],
          startNode: 'A',
        },
      },
      {
        graph: {
          nodes: [
            { children: ['B'], id: 'A', value: 'A' },
            { children: ['C'], id: 'B', value: 'B' },
            { children: ['D', 'E'], id: 'C', value: 'C' },
            { children: ['F'], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: [], id: 'F', value: 'F' },
          ],
          startNode: 'A',
        },
      },
      {
        graph: {
          nodes: [
            { children: ['B', 'C', 'D', 'E', 'F'], id: 'A', value: 'A' },
            { children: ['G', 'H', 'I'], id: 'B', value: 'B' },
            { children: ['J'], id: 'C', value: 'C' },
            { children: ['K', 'L'], id: 'D', value: 'D' },
            { children: [], id: 'E', value: 'E' },
            { children: ['M', 'N'], id: 'F', value: 'F' },
            { children: [], id: 'G', value: 'G' },
            { children: ['O', 'P', 'Q', 'R'], id: 'H', value: 'H' },
            { children: [], id: 'I', value: 'I' },
            { children: [], id: 'J', value: 'J' },
            { children: ['S'], id: 'K', value: 'K' },
            { children: [], id: 'L', value: 'L' },
            { children: [], id: 'M', value: 'M' },
            { children: [], id: 'N', value: 'N' },
            { children: [], id: 'O', value: 'O' },
            { children: ['T', 'U'], id: 'P', value: 'P' },
            { children: [], id: 'Q', value: 'Q' },
            { children: ['V'], id: 'R', value: 'R' },
            { children: [], id: 'S', value: 'S' },
            { children: [], id: 'T', value: 'T' },
            { children: [], id: 'U', value: 'U' },
            { children: ['W', 'X', 'Y'], id: 'V', value: 'V' },
            { children: [], id: 'W', value: 'W' },
            { children: ['Z'], id: 'X', value: 'X' },
            { children: [], id: 'Y', value: 'Y' },
            { children: [], id: 'Z', value: 'Z' },
          ],
          startNode: 'A',
        },
      },
    ],
  },
  {
    id: 'river-sizes',
    name: 'River Sizes',
    category: 'Graphs',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array (a matrix) of potentially unequal height\n  and width containing only <span>0</span>s and <span>1</span>s. Each\n  <span>0</span> represents land, and each <span>1</span> represents part of a\n  river. A river consists of any number of <span>1</span>s that are either\n  horizontally or vertically adjacent (but not diagonally adjacent). The number\n  of adjacent <span>1</span>s forming a river determine its size.\n</p>\n<p>\n  Note that a river can twist. In other words, it doesn\'t have to be a straight\n  vertical line or a straight horizontal line; it can be L-shaped, for example.\n</p>\n<p>\n  Write a function that returns an array of the sizes of all rivers represented\n  in the input matrix. The sizes don\'t need to be in any particular order.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">matrix</span> = [\n  [1, 0, 0, 1, 0],\n  [1, 0, 1, 0, 0],\n  [0, 0, 1, 0, 1],\n  [1, 0, 1, 0, 1],\n  [1, 0, 1, 1, 0],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 2, 2, 2, 5] <span class="CodeEditor-promptComment">// The numbers could be ordered differently.</span>\n\n<span class="CodeEditor-promptComment">// The rivers can be clearly seen here:</span>\n<span class="CodeEditor-promptComment">// [</span>\n<span class="CodeEditor-promptComment">//   [1,  ,  , 1,  ],</span>\n<span class="CodeEditor-promptComment">//   [1,  , 1,  ,  ],</span>\n<span class="CodeEditor-promptComment">//   [ ,  , 1,  , 1],</span>\n<span class="CodeEditor-promptComment">//   [1,  , 1,  , 1],</span>\n<span class="CodeEditor-promptComment">//   [1,  , 1, 1,  ],</span>\n<span class="CodeEditor-promptComment">// ]</span>\n</pre>\n</div>',
    hints: [
      '<p>\nSince you must return the sizes of rivers, which consist of horizontally and vertically adjacent 1s in the input matrix, you must somehow keep track of groups of neighboring 1s as you traverse the matrix. Try treating the matrix as a graph, where each element in the matrix is a node in the graph with up to 4 neighboring nodes (above, below, to the left, and to the right), and traverse it using a popular graph-traversal algorithm like Depth-first Search or Breadth-first Search.\n</p>\n',
      "\n<p>\nBy traversing the matrix using DFS or BFS as mentioned in Hint #1, any time that you encounter a 1 you can traverse the entire river that this 1 is a part of (and keep track of its size) by simply iterating through the given node's neighboring nodes and their own neighboring nodes so long as the nodes are 1s.\n</p>\n",
      "\n<p>\nNaturally, many nodes in the graph mentioned in Hint #1 will have overlapping neighboring nodes, and as you traverse the matrix, you will undoubtedly encounter nodes that you have previously visited. In order to prevent mistakenly calculating the same river's size multiple times and to avoid doing needless computational work, try keeping track of every node that you visit in an auxiliary data structure and only performing important computations on unvisited nodes. What data structure would be ideal here?\n</p>",
    ],
    customInputVars: [
      {
        name: 'matrix',
        example: [
          [1, 0, 0, 1, 0],
          [1, 0, 1, 0, 0],
          [0, 0, 1, 0, 1],
          [1, 0, 1, 0, 1],
          [1, 0, 1, 1, 0],
        ],
        schema: {
          items: {
            items: { maximum: 1, minimum: 0, type: 'integer' },
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: true,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function riverSizes(matrix) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.riverSizes = riverSizes;\n',
      solutions: [
        '// O(wh) time | O(wh) space\nfunction riverSizes(matrix) {\n  const sizes = [];\n  const visited = matrix.map(row => row.map(value => false));\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[i].length; j++) {\n      if (visited[i][j]) continue;\n      traverseNode(i, j, matrix, visited, sizes);\n    }\n  }\n  return sizes;\n}\n\nfunction traverseNode(i, j, matrix, visited, sizes) {\n  let currentRiverSize = 0;\n  const nodesToExplore = [[i, j]];\n  while (nodesToExplore.length) {\n    const currentNode = nodesToExplore.pop();\n    i = currentNode[0];\n    j = currentNode[1];\n    if (visited[i][j]) continue;\n    visited[i][j] = true;\n    if (matrix[i][j] === 0) continue;\n    currentRiverSize++;\n    const unvisitedNeighbors = getUnvisitedNeighbors(i, j, matrix, visited);\n    for (const neighbor of unvisitedNeighbors) {\n      nodesToExplore.push(neighbor);\n    }\n  }\n  if (currentRiverSize > 0) sizes.push(currentRiverSize);\n}\n\nfunction getUnvisitedNeighbors(i, j, matrix, visited) {\n  const unvisitedNeighbors = [];\n  if (i > 0 && !visited[i - 1][j]) unvisitedNeighbors.push([i - 1, j]);\n  if (i < matrix.length - 1 && !visited[i + 1][j]) unvisitedNeighbors.push([i + 1, j]);\n  if (j > 0 && !visited[i][j - 1]) unvisitedNeighbors.push([i, j - 1]);\n  if (j < matrix[0].length - 1 && !visited[i][j + 1]) unvisitedNeighbors.push([i, j + 1]);\n  return unvisitedNeighbors;\n}\n\nexports.riverSizes = riverSizes;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const testInput = [\n    [1, 0, 0, 1, 0],\n    [1, 0, 1, 0, 0],\n    [0, 0, 1, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 0],\n  ];\n  const expected = [1, 2, 2, 2, 5];\n  chai.expect(program.riverSizes(testInput).sort((a, b) => a - b)).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const testInput = [\n    [1, 0, 0, 1, 0],\n    [1, 0, 1, 0, 0],\n    [0, 0, 1, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 1, 1, 0],\n  ];\n  const expected = [1, 2, 2, 2, 5];\n  chai.expect(program.riverSizes(testInput).sort((a, b) => a - b)).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(wh) time | O(wh) space - where w and h are the width and height of the input matrix',
    tests: [
      {
        matrix: [
          [1, 0, 0, 1, 0],
          [1, 0, 1, 0, 0],
          [0, 0, 1, 0, 1],
          [1, 0, 1, 0, 1],
          [1, 0, 1, 1, 0],
        ],
      },
      { matrix: [[0]] },
      { matrix: [[1]] },
      { matrix: [[1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0]] },
      {
        matrix: [
          [1, 0, 0, 1],
          [1, 0, 1, 0],
          [0, 0, 1, 0],
          [1, 0, 1, 0],
        ],
      },
      {
        matrix: [
          [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0],
          [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0],
          [0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1],
          [1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0],
          [1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 0, 0, 0, 0, 1],
          [0, 1, 0, 0, 0, 1, 0],
          [0, 0, 1, 0, 1, 0, 0],
          [0, 0, 0, 1, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 0],
          [0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 0, 0, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 0, 0, 0, 0, 1],
          [0, 1, 0, 0, 0, 1, 0],
          [0, 0, 1, 0, 1, 0, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 1, 0, 1, 0, 0],
          [0, 1, 0, 0, 0, 1, 0],
          [1, 0, 0, 0, 0, 0, 1],
        ],
      },
      {
        matrix: [
          [0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
        ],
      },
      {
        matrix: [
          [1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1],
        ],
      },
      {
        matrix: [
          [1, 1, 0, 0, 0, 0, 1, 1],
          [1, 0, 1, 1, 1, 1, 0, 1],
          [0, 1, 1, 0, 0, 0, 1, 1],
        ],
      },
      {
        matrix: [
          [1, 1, 0],
          [1, 0, 1],
          [1, 1, 1],
          [1, 1, 0],
          [1, 0, 1],
          [0, 1, 0],
          [1, 0, 0],
          [1, 0, 0],
          [0, 0, 0],
          [1, 0, 0],
          [1, 0, 1],
          [1, 1, 1],
        ],
      },
    ],
  },
  {
    id: 'boggle-board',
    name: 'Boggle Board',
    category: 'Graphs',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array (a matrix) of potentially unequal height\n  and width containing letters; this matrix represents a boggle board. You\'re\n  also given a list of words.\n</p>\n<p>\n  Write a function that returns an array of all the words contained in the\n  boggle board. The final words don\'t need to be in any particular order.\n</p>\n<p>\n  A word is constructed in the boggle board by connecting adjacent\n  (horizontally, vertically, or diagonally) letters, without using any single\n  letter at a given position more than once; while a word can of course have\n  repeated letters, those repeated letters must come from different positions in\n  the boggle board in order for the word to be contained in the board. Note that\n  two or more words are allowed to overlap and use the same letters in the\n  boggle board.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">board</span> = [\n  ["t", "h", "i", "s", "i", "s", "a"],\n  ["s", "i", "m", "p", "l", "e", "x"],\n  ["b", "x", "x", "x", "x", "e", "b"],\n  ["x", "o", "g", "g", "l", "x", "o"],\n  ["x", "x", "x", "D", "T", "r", "a"],\n  ["R", "E", "P", "E", "A", "d", "x"],\n  ["x", "x", "x", "x", "x", "x", "x"],\n  ["N", "O", "T", "R", "E", "-", "P"],\n  ["x", "x", "D", "E", "T", "A", "E"],\n],\n<span class="CodeEditor-promptParameter">words</span> = [\n  "this", "is", "not", "a", "simple", "boggle",\n  "board", "test", "REPEATED", "NOTRE-PEATED",\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["this", "is", "a", "simple", "boggle", "board", "NOTRE-PEATED"]\n<span class="CodeEditor-promptComment">// The words could be ordered differently.</span>\n</pre>\n</div>',
    hints: [
      "<p>\nYou can divide this question into two separate problems: one part involves traversing the boggle board in such a way that allows you to construct strings letter by letter; the other part involves actually comparing the strings you construct in the board against the words in the list that you're given. For the second part, what data structure lends itself very well to matching characters to multiple strings at once?\n</p>\n",
      '\n<p>\nTry creating a trie out of the input list of words. This will allow you to compare letters in the boggle board against all input words in constant time. How can you efficiently traverse the boggle board to construct all potentially valid strings, without counting letters twice in any string?\n</p>\n',
      "\n<p>\nTreat the board as a graph, where each element in the board is a node with up to 8 neighboring nodes. Traverse it in a depth-first-search-like fashion, checking if letters are contained in the trie and traversing the trie simultaneously if it makes sense to do so. How can you keep track of letters that you've already visited in order to avoid erroneously counting some of them twice in a single string? Could you keep track of visited nodes in an auxiliary data structure?\n</p>\n",
      "\n<p>\nKeeping in mind that you only want to mark nodes as visited in a single branch of the graph that you're traversing (i.e., you don't want the state of visited nodes in one branch of the graph to spill into the state of another branch of the graph), try marking any node you traverse as unvisited at the end of the recursive call that actually traverses it, after traversing through all of the node's neighbors and performing the same actions on them recursively.\n</p>",
    ],
    customInputVars: [
      {
        name: 'board',
        example: [
          ['t', 'h', 'i', 's', 'i', 's', 'a'],
          ['s', 'i', 'm', 'p', 'l', 'e', 'x'],
          ['b', 'x', 'x', 'x', 'x', 'e', 'b'],
          ['x', 'o', 'g', 'g', 'l', 'x', 'o'],
          ['x', 'x', 'x', 'D', 'T', 'r', 'a'],
          ['R', 'E', 'P', 'E', 'A', 'd', 'x'],
          ['x', 'x', 'x', 'x', 'x', 'x', 'x'],
          ['N', 'O', 'T', 'R', 'E', '-', 'P'],
          ['x', 'x', 'D', 'E', 'T', 'A', 'E'],
        ],
        schema: {
          items: {
            items: { maxLength: 1, minLength: 1, type: 'string' },
            type: 'array',
          },
          type: 'array',
        },
      },
      {
        name: 'words',
        example: [
          'this',
          'is',
          'not',
          'a',
          'simple',
          'boggle',
          'board',
          'test',
          'REPEATED',
          'NOTRE-PEATED',
        ],
        schema: { items: { type: 'string' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function boggleBoard(board, words) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.boggleBoard = boggleBoard;\n',
      solutions: [
        "// O(nm*8^s + ws) time | O(nm + ws) space\nfunction boggleBoard(board, words) {\n  const trie = new Trie();\n  for (const word of words) {\n    trie.add(word);\n  }\n  const finalWords = {};\n  const visited = board.map(row => row.map(letter => false));\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[i].length; j++) {\n      explore(i, j, board, trie.root, visited, finalWords);\n    }\n  }\n  return Object.keys(finalWords);\n}\n\nfunction explore(i, j, board, trieNode, visited, finalWords) {\n  if (visited[i][j]) return;\n  const letter = board[i][j];\n  if (!(letter in trieNode)) return;\n  visited[i][j] = true;\n  trieNode = trieNode[letter];\n  if ('*' in trieNode) finalWords[trieNode['*']] = true;\n  const neighbors = getNeighbors(i, j, board);\n  for (const neighbor of neighbors) {\n    explore(neighbor[0], neighbor[1], board, trieNode, visited, finalWords);\n  }\n  visited[i][j] = false;\n}\n\nfunction getNeighbors(i, j, board) {\n  const neighbors = [];\n  if (i > 0 && j > 0) {\n    neighbors.push([i - 1, j - 1]);\n  }\n  if (i > 0 && j < board[0].length - 1) {\n    neighbors.push([i - 1, j + 1]);\n  }\n  if (i < board.length - 1 && j < board[0].length - 1) {\n    neighbors.push([i + 1, j + 1]);\n  }\n  if (i < board.length - 1 && j > 0) {\n    neighbors.push([i + 1, j - 1]);\n  }\n  if (i > 0) {\n    neighbors.push([i - 1, j]);\n  }\n  if (i < board.length - 1) {\n    neighbors.push([i + 1, j]);\n  }\n  if (j > 0) {\n    neighbors.push([i, j - 1]);\n  }\n  if (j < board[0].length - 1) {\n    neighbors.push([i, j + 1]);\n  }\n  return neighbors;\n}\n\nclass Trie {\n  constructor() {\n    this.root = {};\n    this.endSymbol = '*';\n  }\n\n  add(word) {\n    let current = this.root;\n    for (const letter of word) {\n      if (!(letter in current)) current[letter] = {};\n      current = current[letter];\n    }\n    current[this.endSymbol] = word;\n  }\n}\n\nexports.boggleBoard = boggleBoard;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const board = [\n    ['t', 'h', 'i', 's', 'i', 's', 'a'],\n    ['s', 'i', 'm', 'p', 'l', 'e', 'x'],\n    ['b', 'x', 'x', 'x', 'x', 'e', 'b'],\n    ['x', 'o', 'g', 'g', 'l', 'x', 'o'],\n    ['x', 'x', 'x', 'D', 'T', 'r', 'a'],\n    ['R', 'E', 'P', 'E', 'A', 'd', 'x'],\n    ['x', 'x', 'x', 'x', 'x', 'x', 'x'],\n    ['N', 'O', 'T', 'R', 'E', '-', 'P'],\n    ['x', 'x', 'D', 'E', 'T', 'A', 'E'],\n  ];\n  const words = [\n    'this',\n    'is',\n    'not',\n    'a',\n    'simple',\n    'boggle',\n    'board',\n    'test',\n    'REPEATED',\n    'NOTRE-PEATED',\n  ];\n  const expected = ['this', 'is', 'a', 'simple', 'boggle', 'board', 'NOTRE-PEATED'];\n  const actual = program.boggleBoard(board, words);\n  chai.expect(actual.length).to.deep.equal(expected.length);\n  for (const word of actual) {\n    chai.expect(actual.includes(word)).to.deep.equal(true);\n  }\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const board = [\n    ['t', 'h', 'i', 's', 'i', 's', 'a'],\n    ['s', 'i', 'm', 'p', 'l', 'e', 'x'],\n    ['b', 'x', 'x', 'x', 'x', 'e', 'b'],\n    ['x', 'o', 'g', 'g', 'l', 'x', 'o'],\n    ['x', 'x', 'x', 'D', 'T', 'r', 'a'],\n    ['R', 'E', 'P', 'E', 'A', 'd', 'x'],\n    ['x', 'x', 'x', 'x', 'x', 'x', 'x'],\n    ['N', 'O', 'T', 'R', 'E', '-', 'P'],\n    ['x', 'x', 'D', 'E', 'T', 'A', 'E'],\n  ];\n  const words = [\n    'this',\n    'is',\n    'not',\n    'a',\n    'simple',\n    'boggle',\n    'board',\n    'test',\n    'REPEATED',\n    'NOTRE-PEATED',\n  ];\n  const expected = ['this', 'is', 'a', 'simple', 'boggle', 'board', 'NOTRE-PEATED'];\n  const actual = program.boggleBoard(board, words);\n  chai.expect(actual.length).to.deep.equal(expected.length);\n  for (const word of actual) {\n    chai.expect(actual.includes(word)).to.deep.equal(true);\n  }\n});\n",
    },
    bigO: 'O(nm*8^s + ws) time | O(nm + ws) space - where n is the width the board, m is the height of the board, w is the number of words, and s is the length of the longest word',
    tests: [
      {
        board: [
          ['t', 'h', 'i', 's', 'i', 's', 'a'],
          ['s', 'i', 'm', 'p', 'l', 'e', 'x'],
          ['b', 'x', 'x', 'x', 'x', 'e', 'b'],
          ['x', 'o', 'g', 'g', 'l', 'x', 'o'],
          ['x', 'x', 'x', 'D', 'T', 'r', 'a'],
          ['R', 'E', 'P', 'E', 'A', 'd', 'x'],
          ['x', 'x', 'x', 'x', 'x', 'x', 'x'],
          ['N', 'O', 'T', 'R', 'E', '-', 'P'],
          ['x', 'x', 'D', 'E', 'T', 'A', 'E'],
        ],
        words: [
          'this',
          'is',
          'not',
          'a',
          'simple',
          'boggle',
          'board',
          'test',
          'REPEATED',
          'NOTRE-PEATED',
        ],
      },
      {
        board: [
          ['y', 'g', 'f', 'y', 'e', 'i'],
          ['c', 'o', 'r', 'p', 'o', 'u'],
          ['j', 'u', 'z', 's', 'e', 'l'],
          ['s', 'y', 'u', 'r', 'h', 'p'],
          ['e', 'a', 'e', 'g', 'n', 'd'],
          ['h', 'e', 'l', 's', 'a', 't'],
        ],
        words: [
          'san',
          'sana',
          'at',
          'vomit',
          'yours',
          'help',
          'end',
          'been',
          'bed',
          'danger',
          'calm',
          'ok',
          'chaos',
          'complete',
          'rear',
          'going',
          'storm',
          'face',
          'epual',
          'dangerous',
        ],
      },
      {
        board: [
          ['a', 'b', 'c', 'd', 'e'],
          ['f', 'g', 'h', 'i', 'j'],
          ['k', 'l', 'm', 'n', 'o'],
          ['p', 'q', 'r', 's', 't'],
          ['u', 'v', 'w', 'x', 'y'],
        ],
        words: [
          'agmsy',
          'agmsytojed',
          'agmsytojedinhcbgl',
          'agmsytojedinhcbfl',
        ],
      },
      {
        board: [
          ['a', 'b'],
          ['c', 'd'],
        ],
        words: ['abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'abca'],
      },
      {
        board: [
          ['f', 't', 'r', 'o', 'p', 'i', 'k', 'b', 'o'],
          ['r', 'w', 'l', 'p', 'e', 'u', 'e', 'a', 'b'],
          ['j', 'o', 't', 's', 'e', 'l', 'f', 'l', 'p'],
          ['s', 'z', 'u', 't', 'h', 'u', 'o', 'p', 'i'],
          ['k', 'a', 'e', 'g', 'n', 'd', 'r', 'g', 'a'],
          ['h', 'n', 'l', 's', 'a', 't', 'e', 't', 'x'],
        ],
        words: [
          'frozen',
          'rotten',
          'teleport',
          'city',
          'zutgatz',
          'kappa',
          'before',
          'rope',
          'obligate',
          'annoying',
        ],
      },
      {
        board: [
          ['c', 'o', 'm'],
          ['r', 'p', 'l'],
          ['c', 'i', 't'],
          ['o', 'a', 'e'],
          ['f', 'o', 'd'],
          ['z', 'r', 'b'],
          ['g', 'i', 'a'],
          ['o', 'a', 'g'],
          ['f', 's', 'z'],
          ['t', 'e', 'i'],
          ['t', 'w', 'd'],
        ],
        words: [
          'commerce',
          'complicated',
          'twisted',
          'zigzag',
          'comma',
          'foobar',
          'baz',
          'there',
        ],
      },
      {
        board: [
          ['c', 'o', 'm'],
          ['r', 'p', 'l'],
          ['c', 'i', 't'],
          ['o', 'a', 'e'],
          ['f', 'o', 'd'],
          ['z', 'r', 'b'],
          ['g', 'i', 'a'],
          ['o', 'a', 'g'],
          ['f', 's', 'z'],
          ['t', 'e', 'i'],
          ['t', 'w', 'd'],
        ],
        words: [
          'cr',
          'oc',
          'ml',
          'iao',
          'opo',
          'zrb',
          'big',
          'fs',
          'ogiagao',
          'dwd',
          'twt',
        ],
      },
      {
        board: [
          ['c', 'o', 'm'],
          ['r', 'p', 'l'],
          ['c', 'i', 't'],
          ['o', 'a', 'e'],
          ['f', 'o', 'd'],
          ['z', 'r', 'b'],
          ['g', 'i', 'a'],
          ['o', 'a', 'g'],
          ['f', 's', 'z'],
          ['t', 'e', 'i'],
          ['t', 'w', 'd'],
        ],
        words: [
          'comlpriteacoofziraagsizefttw',
          'comlpriteacoofzirabagsizefottw',
          'comlpriteacoofziraagsizefottw',
          'comlpriteacoofzirabagsizeftttw',
        ],
      },
    ],
  },
  {
    id: 'youngest-common-ancestor',
    name: 'Youngest Common Ancestor',
    category: 'Graphs',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given three inputs, all of which are instances of an\n  <span>AncestralTree</span> class that have an <span>ancestor</span> property\n  pointing to their youngest ancestor. The first input is the top ancestor in an\n  ancestral tree (i.e., the only instance that has no ancestor--its\n  <span>ancestor</span> property points to <span>None</span> /\n  <span>null</span>), and the other two inputs are descendants in the ancestral\n  tree.\n</p>\n<p>\n  Write a function that returns the youngest common ancestor to the two\n  descendants.\n</p>\n<p>\n  Note that a descendant is considered its own ancestor. So in the simple\n  ancestral tree below, the youngest common ancestor to nodes A and B is node A.\n</p>\n<pre>\n<span class="CodeEditor-promptComment">// The youngest common ancestor to nodes A and B is node A.</span>\n  A\n /\nB\n</pre>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptComment">// The nodes are from the ancestral tree below.</span>\n<span class="CodeEditor-promptParameter">topAncestor</span> = node A\n<span class="CodeEditor-promptParameter">descendantOne</span> = node E\n<span class="CodeEditor-promptParameter">descendantTwo</span> = node I\n          A\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      B       C\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   D     E F     G\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nH     I\n</pre>\n<h3>Sample Output</h3>\n<pre>\nnode B\n</pre>\n</div>',
    hints: [
      "<p>\nYou could try to simultaneously iterate through the ancestors of both input descendants until you find a common ancestor; however, if one of the descendants has more ancestors than the other (i.e., is lower in the ancestral tree), you won't find the youngest common ancestor. How can you get around this problem?\n</p>\n",
      "\n<p>\nStart by finding the two input descendants' depths in the ancestral tree. If one of them is deeper, iterate up through its ancestors until you reach the depth of the higher descendant. Then, iterate through both descendants' ancestors in tandem until you find the first common ancestor. Note that at this point, one of the descendants will be the ancestor of the lower descendant that is at the same level as the higher descendant.\n</p>",
    ],
    customInputVars: [
      { name: 'topAncestor', example: 'A', schema: { type: 'string' } },
      { name: 'descendantOne', example: 'E', schema: { type: 'string' } },
      { name: 'descendantTwo', example: 'I', schema: { type: 'string' } },
      {
        name: 'ancestralTree',
        example: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'B', id: 'D', name: 'D' },
            { ancestor: 'B', id: 'E', name: 'E' },
            { ancestor: 'C', id: 'F', name: 'F' },
            { ancestor: 'C', id: 'G', name: 'G' },
            { ancestor: 'D', id: 'H', name: 'H' },
            { ancestor: 'D', id: 'I', name: 'I' },
          ],
        },
        schema: {
          description:
            "An <span>AncestralTree</span> is represented by a list of <span>nodes</span>. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>ancestor</span> pointers and by the\n<span>topAncestor</span>, the <span>descendantOne</span>, and the <span>descendantTwo</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  ancestor: { type: ['string', 'null'] },
                  id: { type: 'string' },
                  name: { type: 'string' },
                },
                required: ['id', 'name', 'ancestor'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass AncestralTree {\n  constructor(name) {\n    this.name = name;\n    this.ancestor = null;\n  }\n}\n\nfunction getYoungestCommonAncestor(topAncestor, descendantOne, descendantTwo) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.AncestralTree = AncestralTree;\nexports.getYoungestCommonAncestor = getYoungestCommonAncestor;\n',
      solutions: [
        'class AncestralTree {\n  constructor(name) {\n    this.name = name;\n    this.ancestor = null;\n  }\n}\n\n// O(d) time | O(1) space - where d is the depth (height) of the ancestral tree\nfunction getYoungestCommonAncestor(topAncestor, descendantOne, descendantTwo) {\n  const depthOne = getDescendantDepth(descendantOne, topAncestor);\n  const depthTwo = getDescendantDepth(descendantTwo, topAncestor);\n  if (depthOne > depthTwo) {\n    return backtrackAncestralTree(descendantOne, descendantTwo, depthOne - depthTwo);\n  } else {\n    return backtrackAncestralTree(descendantTwo, descendantOne, depthTwo - depthOne);\n  }\n}\n\nfunction getDescendantDepth(descendant, topAncestor) {\n  let depth = 0;\n  while (descendant !== topAncestor) {\n    depth++;\n    descendant = descendant.ancestor;\n  }\n  return depth;\n}\n\nfunction backtrackAncestralTree(lowerDescendant, higherDescendant, diff) {\n  while (diff > 0) {\n    lowerDescendant = lowerDescendant.ancestor;\n    diff--;\n  }\n  while (lowerDescendant !== higherDescendant) {\n    lowerDescendant = lowerDescendant.ancestor;\n    higherDescendant = higherDescendant.ancestor;\n  }\n  return lowerDescendant;\n}\n\nexports.AncestralTree = AncestralTree;\nexports.getYoungestCommonAncestor = getYoungestCommonAncestor;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass AncestralTree extends program.AncestralTree {\n  constructor(name) {\n    super(name);\n  }\n\n  addAsAncestor(descendants) {\n    for (const descendant of descendants) {\n      descendant.ancestor = this;\n    }\n  }\n}\n\nfunction getTrees() {\n  const trees = {};\n  const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n  for (const letter of ALPHABET) {\n    trees[letter] = new AncestralTree(letter);\n  }\n  return trees;\n}\n\nit('Test Case #1', function () {\n  const trees = getTrees();\n  trees['A'].addAsAncestor([trees['B'], trees['C']]);\n  trees['B'].addAsAncestor([trees['D'], trees['E']]);\n  trees['D'].addAsAncestor([trees['H'], trees['I']]);\n  trees['C'].addAsAncestor([trees['F'], trees['G']]);\n\n  const yca = program.getYoungestCommonAncestor(trees.A, trees.E, trees.I);\n  chai.expect(yca).to.deep.equal(trees.B);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass AncestralTree extends program.AncestralTree {\n  constructor(name) {\n    super(name);\n  }\n\n  addAsAncestor(descendants) {\n    for (const descendant of descendants) {\n      descendant.ancestor = this;\n    }\n  }\n}\n\nfunction getTrees() {\n  const trees = {};\n  const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n  for (const letter of ALPHABET) {\n    trees[letter] = new AncestralTree(letter);\n  }\n  return trees;\n}\n\nit('Test Case #1', function () {\n  const trees = getTrees();\n  trees['A'].addAsAncestor([trees['B'], trees['C']]);\n  trees['B'].addAsAncestor([trees['D'], trees['E']]);\n  trees['D'].addAsAncestor([trees['H'], trees['I']]);\n  trees['C'].addAsAncestor([trees['F'], trees['G']]);\n\n  const yca = program.getYoungestCommonAncestor(trees.A, trees.E, trees.I);\n  chai.expect(yca).to.deep.equal(trees.B);\n});\n",
    },
    bigO: 'O(d) time | O(1) space - where d is the depth (height) of the ancestral tree',
    tests: [
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'B', id: 'D', name: 'D' },
            { ancestor: 'B', id: 'E', name: 'E' },
            { ancestor: 'C', id: 'F', name: 'F' },
            { ancestor: 'C', id: 'G', name: 'G' },
            { ancestor: 'D', id: 'H', name: 'H' },
            { ancestor: 'D', id: 'I', name: 'I' },
          ],
        },
        descendantOne: 'E',
        descendantTwo: 'I',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'A',
        descendantTwo: 'B',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'B',
        descendantTwo: 'F',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'G',
        descendantTwo: 'M',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'U',
        descendantTwo: 'S',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'Z',
        descendantTwo: 'M',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'O',
        descendantTwo: 'I',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'T',
        descendantTwo: 'Z',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'T',
        descendantTwo: 'V',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'T',
        descendantTwo: 'H',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'W',
        descendantTwo: 'V',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'Z',
        descendantTwo: 'B',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'Q',
        descendantTwo: 'W',
        topAncestor: 'A',
      },
      {
        ancestralTree: {
          nodes: [
            { ancestor: null, id: 'A', name: 'A' },
            { ancestor: 'A', id: 'B', name: 'B' },
            { ancestor: 'A', id: 'C', name: 'C' },
            { ancestor: 'A', id: 'D', name: 'D' },
            { ancestor: 'A', id: 'E', name: 'E' },
            { ancestor: 'A', id: 'F', name: 'F' },
            { ancestor: 'B', id: 'G', name: 'G' },
            { ancestor: 'B', id: 'H', name: 'H' },
            { ancestor: 'B', id: 'I', name: 'I' },
            { ancestor: 'C', id: 'J', name: 'J' },
            { ancestor: 'D', id: 'K', name: 'K' },
            { ancestor: 'D', id: 'L', name: 'L' },
            { ancestor: 'F', id: 'M', name: 'M' },
            { ancestor: 'F', id: 'N', name: 'N' },
            { ancestor: 'H', id: 'O', name: 'O' },
            { ancestor: 'H', id: 'P', name: 'P' },
            { ancestor: 'H', id: 'Q', name: 'Q' },
            { ancestor: 'H', id: 'R', name: 'R' },
            { ancestor: 'K', id: 'S', name: 'S' },
            { ancestor: 'P', id: 'T', name: 'T' },
            { ancestor: 'P', id: 'U', name: 'U' },
            { ancestor: 'R', id: 'V', name: 'V' },
            { ancestor: 'V', id: 'W', name: 'W' },
            { ancestor: 'V', id: 'X', name: 'X' },
            { ancestor: 'V', id: 'Y', name: 'Y' },
            { ancestor: 'X', id: 'Z', name: 'Z' },
          ],
        },
        descendantOne: 'A',
        descendantTwo: 'Z',
        topAncestor: 'A',
      },
    ],
  },
  {
    id: 'rectangle-mania',
    name: 'Rectangle Mania',
    category: 'Graphs',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a list of Cartesian coordinates (i.e., (x, y)\n  coordinates) and returns the number of rectangles formed by these coordinates.\n</p>\n<p>\n  A rectangle must have its four corners amongst the coordinates in order to be\n  counted, and we only care about rectangles with sides parallel to the x and y\n  axes (i.e., with horizontal and vertical sides--no diagonal sides).\n</p>\n<p>\n  You can also assume that no coordinate will be farther than 100 units from the\n  origin.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">coords</span> = [\n  [0, 0], [0, 1], [1, 1], [1, 0],\n  [2, 1], [2, 0], [3, 1], [3, 0],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n6\n</pre>\n</div>',
    hints: [
      '<p>\nTry treating every coordinate as the potential lower left corner of a rectangle. What conditions would need to be met in order to actually have a rectangle with any given coordinate as its lower left corner?\n</p>\n',
      '\n<p>\nFollowing Hint #1, if you treat every coordinate as the potential lower left corner of a rectangle, you can move in a clockwise pattern (i.e., directly up, then directly right, then directly down, and finally directly left) to try to find a rectangle. There are a few ways to do this, one of which involves storing, for every coordinate, all other coordinates that are directly above it, directly to the right of it, directly below it, and directly to the left of it. With this information, you can iterate through all of the coordinates and then traverse through potential rectangles in an up-right-down-left pattern.\n</p>\n',
      '\n<p>\nFollowing Hint #2, do you actually need to store all of the coordinates above, to the right, below, and to the left of every coordinate?\n</p>\n',
      '\n<p>\nAnother, perhaps more clever way of solving this problem is to realize that, for any coordinate to be a valid lower left corner of a rectangle, there must be a corresponding upper right corner of the same rectangle, which is just another coordinate located to the upper right of the first coordinate. If you have two such coordinates, you should be able to easily find whether corresponding upper left and lower right corners exist.\n</p>',
    ],
    customInputVars: [
      {
        name: 'coords',
        example: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
          [3, 1],
          [3, 0],
        ],
        schema: {
          items: {
            items: { maximum: 100, minimum: -100, type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function rectangleMania(coords) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.rectangleMania = rectangleMania;\n',
      solutions: [
        "// O(n^2) time | O(n^2) space - where n is the number of coordinates\nfunction rectangleMania(coords) {\n  const coordsTable = getCoordsTable(coords);\n  return getRectangleCount(coords, coordsTable);\n}\n\nfunction getCoordsTable(coords) {\n  const coordsTable = {};\n  for (const coord1 of coords) {\n    const coord1Directions = {\n      [UP]: [],\n      [RIGHT]: [],\n      [DOWN]: [],\n      [LEFT]: [],\n    };\n    for (const coord2 of coords) {\n      const coord2Direction = getCoordDirection(coord1, coord2);\n      if (coord2Direction in coord1Directions) coord1Directions[coord2Direction].push(coord2);\n    }\n    const coord1String = coordToString(coord1);\n    coordsTable[coord1String] = coord1Directions;\n  }\n  return coordsTable;\n}\n\nfunction getCoordDirection(coord1, coord2) {\n  const [x1, y1] = coord1;\n  const [x2, y2] = coord2;\n  if (y2 === y1) {\n    if (x2 > x1) {\n      return RIGHT;\n    } else if (x2 < x1) {\n      return LEFT;\n    }\n  } else if (x2 === x1) {\n    if (y2 > y1) {\n      return UP;\n    } else if (y2 < y1) {\n      return DOWN;\n    }\n  }\n  return '';\n}\n\nfunction getRectangleCount(coords, coordsTable) {\n  let rectangleCount = 0;\n  for (const coord of coords) {\n    rectangleCount += clockwiseCountRectangles(coord, coordsTable, UP, coord);\n  }\n  return rectangleCount;\n}\n\nfunction clockwiseCountRectangles(coord, coordsTable, direction, origin) {\n  const coordString = coordToString(coord);\n  if (direction === LEFT) {\n    const rectangleFound = coordsTable[coordString][LEFT].includes(origin);\n    return rectangleFound ? 1 : 0;\n  } else {\n    let rectangleCount = 0;\n    const nextDirection = getNextClockwiseDirection(direction);\n    for (const nextCoord of coordsTable[coordString][direction]) {\n      rectangleCount += clockwiseCountRectangles(nextCoord, coordsTable, nextDirection, origin);\n    }\n    return rectangleCount;\n  }\n}\n\nfunction getNextClockwiseDirection(direction) {\n  if (direction === UP) return RIGHT;\n  if (direction === RIGHT) return DOWN;\n  if (direction === DOWN) return LEFT;\n  return '';\n}\n\nfunction coordToString(coord) {\n  const [x, y] = coord;\n  return `${x}-${y}`;\n}\n\nconst UP = 'up';\nconst RIGHT = 'right';\nconst DOWN = 'down';\nconst LEFT = 'left';\n\nexports.rectangleMania = rectangleMania;\n",
        "// O(n^2) time | O(n) space - where n is the number of coordinates\nfunction rectangleMania(coords) {\n  const coordsTable = getCoordsTable(coords);\n  return getRectangleCount(coords, coordsTable);\n}\n\nfunction getCoordsTable(coords) {\n  const coordsTable = {x: {}, y: {}};\n  for (const coord of coords) {\n    const [x, y] = coord;\n    coordsTable.x[x] = coordsTable.x[x] || [];\n    coordsTable.x[x].push(coord);\n    coordsTable.y[y] = coordsTable.y[y] || [];\n    coordsTable.y[y].push(coord);\n  }\n  return coordsTable;\n}\n\nfunction getRectangleCount(coords, coordsTable) {\n  let rectangleCount = 0;\n  for (const coord of coords) {\n    const lowerLeftY = coord[1];\n    rectangleCount += clockwiseCountRectangles(coord, coordsTable, UP, lowerLeftY);\n  }\n  return rectangleCount;\n}\n\nfunction clockwiseCountRectangles(coord1, coordsTable, direction, lowerLeftY) {\n  const [x1, y1] = coord1;\n  if (direction === DOWN) {\n    const relevantCoords = coordsTable.x[x1];\n    for (const coord2 of relevantCoords) {\n      const lowerRightY = coord2[1];\n      if (lowerRightY === lowerLeftY) return 1;\n    }\n    return 0;\n  } else {\n    let rectangleCount = 0;\n    if (direction === UP) {\n      const relevantCoords = coordsTable.x[x1];\n      for (const coord2 of relevantCoords) {\n        const y2 = coord2[1];\n        const isAbove = y2 > y1;\n        if (isAbove)\n          rectangleCount += clockwiseCountRectangles(coord2, coordsTable, RIGHT, lowerLeftY);\n      }\n    } else if (direction === RIGHT) {\n      const relevantCoords = coordsTable.y[y1];\n      for (const coord2 of relevantCoords) {\n        const x2 = coord2[0];\n        const isRight = x2 > x1;\n        if (isRight)\n          rectangleCount += clockwiseCountRectangles(coord2, coordsTable, DOWN, lowerLeftY);\n      }\n    }\n    return rectangleCount;\n  }\n}\n\nconst UP = 'up';\nconst RIGHT = 'right';\nconst DOWN = 'down';\n\nexports.rectangleMania = rectangleMania;\n",
        '// O(n^2) time | O(n) space - where n is the number of coordinates\nfunction rectangleMania(coords) {\n  const coordsTable = getCoordsTable(coords);\n  return getRectangleCount(coords, coordsTable);\n}\n\nfunction getCoordsTable(coords) {\n  const coordsTable = {};\n  for (const coord of coords) {\n    const coordString = coordToString(coord);\n    coordsTable[coordString] = true;\n  }\n  return coordsTable;\n}\n\nfunction getRectangleCount(coords, coordsTable) {\n  let rectangleCount = 0;\n  for (const [x1, y1] of coords) {\n    for (const [x2, y2] of coords) {\n      if (!isInUpperRight([x1, y1], [x2, y2])) continue;\n      const upperCoordString = coordToString([x1, y2]);\n      const rightCoordString = coordToString([x2, y1]);\n      if (upperCoordString in coordsTable && rightCoordString in coordsTable) rectangleCount++;\n    }\n  }\n  return rectangleCount;\n}\n\nfunction isInUpperRight(coord1, coord2) {\n  const [x1, y1] = coord1;\n  const [x2, y2] = coord2;\n  return x2 > x1 && y2 > y1;\n}\n\nfunction coordToString(coord) {\n  const [x, y] = coord;\n  return `${x}-${y}`;\n}\n\nexports.rectangleMania = rectangleMania;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const coords = [\n    [0, 0],\n    [0, 1],\n    [1, 1],\n    [1, 0],\n    [2, 1],\n    [2, 0],\n    [3, 1],\n    [3, 0],\n  ];\n  chai.expect(program.rectangleMania(coords)).to.deep.equal(6);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const coords = [\n    [0, 0],\n    [0, 1],\n    [1, 1],\n    [1, 0],\n    [2, 1],\n    [2, 0],\n    [3, 1],\n    [3, 0],\n  ];\n  chai.expect(program.rectangleMania(coords)).to.deep.equal(6);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the number of coordinates',
    tests: [
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
          [3, 1],
          [3, 0],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
          [3, 1],
          [3, 0],
          [1, 3],
          [3, 3],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
          [3, 1],
          [3, 0],
          [1, 3],
          [3, 3],
          [0, -4],
          [3, -4],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
          [3, 1],
          [3, 0],
          [1, 3],
          [3, 3],
          [0, -4],
          [3, -4],
          [1, -3],
          [3, -3],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
          [3, 1],
          [3, 0],
          [1, 3],
          [3, 3],
          [0, -4],
          [3, -4],
          [1, -3],
          [3, -3],
          [-1, 0],
          [-10, 0],
          [-1, -1],
          [2, -2],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
          [3, 1],
          [3, 0],
          [1, 3],
          [3, 3],
          [0, -4],
          [3, -4],
          [1, -3],
          [3, -3],
          [-1, 0],
          [-10, 0],
          [-1, -1],
          [2, -2],
          [0, -1],
          [1, -4],
          [-10, -4],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 0],
          [2, 1],
          [1, 3],
          [3, 3],
          [0, -4],
          [3, -5],
          [1, -3],
          [3, -2],
          [-1, 0],
          [-10, 0],
          [-1, -1],
          [2, -2],
        ],
      },
      {
        coords: [
          [0, 0],
          [0, 1],
          [1, 1],
        ],
      },
    ],
  },
  {
    id: 'remove-islands',
    name: 'Remove Islands',
    category: 'Graphs',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array (a matrix) of potentially unequal height\n  and width containing only <span>0</span>s and <span>1</span>s. The matrix\n  represents a two-toned image, where each <span>1</span> represents black and\n  each <span>0</span> represents white. An island is defined as any number of\n  <span>1</span>s that are horizontally or vertically adjacent (but not\n  diagonally adjacent) and that don\'t touch the border of the image. In other\n  words, a group of horizontally or vertically adjacent <span>1</span>s isn\'t an\n  island if any of those <span>1</span>s are in the first row, last row, first\n  column, or last column of the input matrix.\n</p>\n<p>\n  Note that an island can twist. In other words, it doesn\'t have to be a\n  straight vertical line or a straight horizontal line; it can be L-shaped, for\n  example.\n</p>\n<p>\n  You can think of islands as patches of black that don\'t touch the border of\n  the two-toned image.\n</p>\n<p>\n  Write a function that returns a modified version of the input matrix, where\n  all of the islands are removed. You remove an island by replacing it with\n  <span>0</span>s.\n</p>\n<p>Naturally, you\'re allowed to mutate the input matrix.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">matrix</span> = \n[\n  [1, 0, 0, 0, 0, 0],\n  [0, 1, 0, 1, 1, 1],\n  [0, 0, 1, 0, 1, 0],\n  [1, 1, 0, 0, 1, 0],\n  [1, 0, 1, 1, 0, 0],\n  [1, 0, 0, 0, 0, 1],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\n  [1, 0, 0, 0, 0, 0],\n  [0, 0, 0, 1, 1, 1],\n  [0, 0, 0, 0, 1, 0],\n  [1, 1, 0, 0, 1, 0],\n  [1, 0, 0, 0, 0, 0],\n  [1, 0, 0, 0, 0, 1],\n] \n<span class="CodeEditor-promptComment">// The islands that were removed can be clearly seen here:</span>\n<span class="CodeEditor-promptComment">// [</span>\n<span class="CodeEditor-promptComment">//   [ ,  ,  ,  ,  , ],</span>\n<span class="CodeEditor-promptComment">//   [ , 1,  ,  ,  , ],</span>\n<span class="CodeEditor-promptComment">//   [ ,  , 1,  ,  , ],</span>\n<span class="CodeEditor-promptComment">//   [ ,  ,  ,  ,  , ],</span>\n<span class="CodeEditor-promptComment">//   [ ,  , 1, 1,  , ],</span>\n<span class="CodeEditor-promptComment">//   [ ,  ,  ,  ,  , ], </span>\n<span class="CodeEditor-promptComment">// ]</span>\n</pre>\n</div>',
    hints: [
      '<p>\nHow would you solve this problem if you knew the positions of all the non-island 1s?\n</p>\n',
      '\n<p>\nFind and store the positions of all the non-island 1s. You can do this by performing a graph traversal (depth-first search, for example) on all the 1s that are on the border of the image. Afterwards, you can easily identify and remove all the island 1s from the input matrix by relying on the data structure that you used to store the positions of non-island 1s.\n</p>\n',
      '\n<p>\nYou can also solve this problem without the use of a data structure that stores the positions of non-islands 1s. Simply loop through the border of the image, and perform a depth-first search on all positions with the value 1. During this depth-first search, find all the 1s that are connected to the original position on the border, and change them from 1 to 2. After changing all non-island 1s to 2s, you can simply remove all the remaining 1s, which are guaranteed to be islands, from the matrix (by replacing them with 0s), and you can then change all the 2s back to 1s, since these were previously determined to be non-islands.\n</p>',
    ],
    customInputVars: [
      {
        name: 'matrix',
        example: [
          [1, 0, 0, 0, 0, 0],
          [0, 1, 0, 1, 1, 1],
          [0, 0, 1, 0, 1, 0],
          [1, 1, 0, 0, 1, 0],
          [1, 0, 1, 1, 0, 0],
          [1, 0, 0, 0, 0, 1],
        ],
        schema: {
          items: {
            items: { maximum: 1, minimum: 0, type: 'integer' },
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function removeIslands(matrix) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.removeIslands = removeIslands;\n',
      solutions: [
        '// O(wh) time | O(wh) space - where w and h\n// are the width and height of the input matrix\nfunction removeIslands(matrix) {\n  const onesConnectedToBorder = [];\n  for (let row = 0; row < matrix.length; row++) {\n    onesConnectedToBorder.push([]);\n    for (let col = 0; col < matrix[0].length; col++) {\n      onesConnectedToBorder[row].push(false);\n    }\n  }\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const rowIsBorder = row === 0 || row === matrix.length - 1;\n      const colIsBorder = col === 0 || col === matrix[row].length - 1;\n      const isBorder = rowIsBorder || colIsBorder;\n      if (!isBorder) continue;\n\n      if (matrix[row][col] != 1) continue;\n\n      findOnesConnectedToBorder(matrix, row, col, onesConnectedToBorder);\n    }\n  }\n\n  for (let row = 1; row < matrix.length - 1; row++) {\n    for (let col = 1; col < matrix[row].length - 1; col++) {\n      if (onesConnectedToBorder[row][col]) continue;\n\n      matrix[row][col] = 0;\n    }\n  }\n\n  return matrix;\n}\n\nfunction findOnesConnectedToBorder(matrix, startRow, startCol, onesConnectedToBorder) {\n  const stack = [[startRow, startCol]];\n\n  while (stack.length > 0) {\n    const currentPosition = stack.pop();\n    const [currentRow, currentCol] = currentPosition;\n\n    const alreadyVisited = onesConnectedToBorder[currentRow][currentCol];\n    if (alreadyVisited) continue;\n\n    onesConnectedToBorder[currentRow][currentCol] = true;\n\n    const neighbors = getNeighbors(matrix, currentRow, currentCol);\n    for (const neighbor of neighbors) {\n      const [row, col] = neighbor;\n\n      if (matrix[row][col] != 1) continue;\n\n      stack.push(neighbor);\n    }\n  }\n}\n\nfunction getNeighbors(matrix, row, col) {\n  const neighbors = [];\n\n  const numRows = matrix.length;\n  const numCols = matrix[row].length;\n\n  if (row - 1 >= 0) neighbors.push([row - 1, col]); // UP\n  if (row + 1 < numRows) neighbors.push([row + 1, col]); // DOWN\n  if (col - 1 >= 0) neighbors.push([row, col - 1]); // LEFT\n  if (col + 1 < numCols) neighbors.push([row, col + 1]); // RIGHT\n\n  return neighbors;\n}\n\n// Do not edit the line below.\nexports.removeIslands = removeIslands;\n',
        '// O(wh) time | O(wh) space - where w and h\n// are the width and height of the input matrix\nfunction removeIslands(matrix) {\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const rowIsBorder = row === 0 || row === matrix.length - 1;\n      const colIsBorder = col === 0 || col === matrix[row].length - 1;\n      const isBorder = rowIsBorder || colIsBorder;\n      if (!isBorder) continue;\n\n      if (matrix[row][col] != 1) continue;\n\n      changeOnesConnectedToBorderToTwos(matrix, row, col);\n    }\n  }\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const color = matrix[row][col];\n      if (color === 1) {\n        matrix[row][col] = 0;\n      } else if (color === 2) {\n        matrix[row][col] = 1;\n      }\n    }\n  }\n\n  return matrix;\n}\n\nfunction changeOnesConnectedToBorderToTwos(matrix, startRow, startCol) {\n  const stack = [[startRow, startCol]];\n\n  while (stack.length > 0) {\n    const currentPosition = stack.pop();\n    const [currentRow, currentCol] = currentPosition;\n\n    matrix[currentRow][currentCol] = 2;\n\n    const neighbors = getNeighbors(matrix, currentRow, currentCol);\n    for (const neighbor of neighbors) {\n      const [row, col] = neighbor;\n\n      if (matrix[row][col] != 1) continue;\n\n      stack.push(neighbor);\n    }\n  }\n}\n\nfunction getNeighbors(matrix, row, col) {\n  const neighbors = [];\n\n  const numRows = matrix.length;\n  const numCols = matrix[row].length;\n\n  if (row - 1 >= 0) neighbors.push([row - 1, col]); // UP\n  if (row + 1 < numRows) neighbors.push([row + 1, col]); // DOWN\n  if (col - 1 >= 0) neighbors.push([row, col - 1]); // LEFT\n  if (col + 1 < numCols) neighbors.push([row, col + 1]); // RIGHT\n\n  return neighbors;\n}\n\n// Do not edit the line below.\nexports.removeIslands = removeIslands;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 0, 0, 0, 0, 0],\n    [0, 1, 0, 1, 1, 1],\n    [0, 0, 1, 0, 1, 0],\n    [1, 1, 0, 0, 1, 0],\n    [1, 0, 1, 1, 0, 0],\n    [1, 0, 0, 0, 0, 1],\n  ];\n  const expected = [\n    [1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 0, 1, 0],\n    [1, 1, 0, 0, 1, 0],\n    [1, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 1],\n  ];\n  const actual = program.removeIslands(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 0, 0, 0, 0, 0],\n    [0, 1, 0, 1, 1, 1],\n    [0, 0, 1, 0, 1, 0],\n    [1, 1, 0, 0, 1, 0],\n    [1, 0, 1, 1, 0, 0],\n    [1, 0, 0, 0, 0, 1],\n  ];\n  const expected = [\n    [1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 0, 1, 0],\n    [1, 1, 0, 0, 1, 0],\n    [1, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 1],\n  ];\n  const actual = program.removeIslands(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(wh) time | O(wh) space - where w and h are the width and height of the input matrix',
    tests: [
      {
        matrix: [
          [1, 0, 0, 0, 0, 0],
          [0, 1, 0, 1, 1, 1],
          [0, 0, 1, 0, 1, 0],
          [1, 1, 0, 0, 1, 0],
          [1, 0, 1, 1, 0, 0],
          [1, 0, 0, 0, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 0, 0, 1],
          [0, 1, 0, 1, 0],
          [0, 0, 1, 0, 0],
          [0, 1, 0, 1, 0],
          [1, 0, 0, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 0, 1, 0],
          [0, 1, 0, 1, 0],
          [0, 0, 1, 1, 0],
        ],
      },
      {
        matrix: [
          [1, 1, 1, 1, 1],
          [1, 0, 0, 0, 1],
          [1, 0, 1, 0, 1],
          [1, 0, 0, 0, 1],
          [1, 0, 1, 0, 1],
          [1, 0, 1, 0, 1],
          [1, 0, 1, 1, 1],
          [1, 0, 1, 0, 1],
        ],
      },
      {
        matrix: [
          [0, 0, 0, 0, 0],
          [0, 1, 1, 1, 0],
          [0, 1, 1, 1, 0],
          [0, 1, 1, 1, 0],
          [0, 0, 0, 0, 0],
        ],
      },
      {
        matrix: [
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
        ],
      },
      { matrix: [[1]] },
      {
        matrix: [
          [1, 0, 0, 0, 1, 0, 0, 0],
          [1, 0, 1, 0, 1, 0, 1, 0],
          [1, 1, 0, 1, 0, 0, 1, 0],
          [1, 1, 0, 1, 1, 0, 1, 0],
          [1, 0, 0, 0, 1, 0, 0, 0],
        ],
      },
      {
        matrix: [
          [1, 1, 1, 1, 1],
          [1, 0, 0, 0, 1],
          [1, 0, 1, 0, 1],
          [1, 0, 0, 0, 1],
          [1, 1, 1, 1, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 1, 0, 1],
          [0, 0, 1, 0, 0],
          [1, 1, 0, 1, 1],
          [0, 0, 1, 0, 0],
          [1, 0, 1, 0, 1],
        ],
      },
      {
        matrix: [
          [0, 0, 0, 0, 0],
          [0, 0, 1, 0, 0],
          [0, 1, 1, 1, 0],
          [0, 0, 1, 0, 0],
          [0, 0, 0, 0, 0],
        ],
      },
      {
        matrix: [
          [1, 0, 1, 0, 1, 0],
          [0, 1, 0, 1, 0, 1],
          [1, 0, 1, 0, 1, 0],
          [0, 1, 0, 1, 0, 1],
          [1, 0, 1, 0, 1, 0],
          [0, 1, 0, 1, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 1, 1, 1, 0],
          [1, 1, 0, 1, 0, 1],
          [1, 0, 1, 0, 1, 0],
          [0, 1, 0, 1, 0, 1],
          [1, 0, 1, 0, 1, 0],
          [0, 1, 1, 1, 0, 1],
        ],
      },
      {
        matrix: [
          [0, 1, 0],
          [0, 1, 0],
          [1, 0, 0],
        ],
      },
      {
        matrix: [
          [1, 1],
          [1, 1],
        ],
      },
      {
        matrix: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ],
      },
    ],
  },
  {
    id: 'cycle-in-graph',
    name: 'Cycle In Graph',
    category: 'Graphs',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a list of <span>edges</span> representing an unweighted, directed\n  graph with at least one node. Write a function that returns a boolean\n  representing whether the given graph contains a cycle.\n</p>\n<p>\n  For the purpose of this question, a cycle is defined as any number of\n  vertices, including just one vertex, that are connected in a closed chain. A\n  cycle can also be defined as a chain of at least one vertex in which the first\n  vertex is the same as the last.\n</p>\n<p>\n  The given list is what\'s called an adjacency list, and it represents a graph.\n  The number of vertices in the graph is equal to the length of\n  <span>edges</span>, where each index <span>i</span> in\n  <span>edges</span> contains vertex <span>i</span>\'s outbound edges, in no\n  particular order. Each individual edge is represented by a positive integer\n  that denotes an index (a destination vertex) in the list that this vertex is\n  connected to. Note that these edges are directed, meaning that you can only\n  travel from a particular vertex to its destination, not the other way around\n  (unless the destination vertex itself has an outbound edge to the original\n  vertex).\n</p>\n<p>\n  Also note that this graph may contain self-loops. A self-loop is an edge that\n  has the same destination and origin; in other words, it\'s an edge that\n  connects a vertex to itself. For the purpose of this question, a self-loop is\n  considered a cycle.\n</p>\n<p>\n  For a more detailed explanation, please refer to the Conceptual Overview\n  section of this question\'s video explanation.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">edges</span> = [\n  [1, 3],\n  [2, 3, 4],\n  [0],\n  [],\n  [2, 5],\n  [],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue \n<span class="CodeEditor-promptComment">// There are multiple cycles in this graph: </span>\n<span class="CodeEditor-promptComment">// 1) 0 -> 1 -> 2 -> 0</span>\n<span class="CodeEditor-promptComment">// 2) 0 -> 1 -> 4 -> 2 -> 0</span>\n<span class="CodeEditor-promptComment">// 3) 1 -> 2 -> 0 -> 1</span>\n<span class="CodeEditor-promptComment">// These are just 3 examples; there are more.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nThere are multiple ways to solve this problem, and they all make use of a depth-first-search traversal.\n</p>\n',
      '\n<p>\nWhen traversing a graph using depth-first search, a back edge is an edge from a node to one of its ancestors in the depth-first-search tree, and a back edge denotes the presence of a cycle. How can you determine if a graph has any back edges?\n</p>\n',
      "\n<p>\nTo find back edges, you'll need to keep track of which nodes you've already visited and which nodes are ancestors of the current node in the depth-first-search tree. There are a few ways to do this, but one approach is to recursively traverse the graph and to keep track of which nodes have been visited in general and which nodes have been visited in the current recursion stack; you can do so with two separate data structures. If you reach a node that has an edge to a node that's already in the recursion stack, then you've detected a back edge, and there's a cycle in the graph.\n</p>\n",
      "\n<p>\nSimilar to the previous hint, you can also detect a back edge by performing a 3-color depth-first search. Each node is colored white to start; recursively traverse through the graph, coloring the current node grey and then calling the recursive traversal function on all of its neighbors. After traversing all the neighbors, color the current node black to signify that it's \"done.\" If you ever find an edge to a node that's grey, you've found a back edge, and there's a cycle in the graph.\n</p>",
    ],
    customInputVars: [
      {
        name: 'edges',
        example: [[1, 3], [2, 3, 4], [0], [], [2, 5], []],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function cycleInGraph(edges) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.cycleInGraph = cycleInGraph;\n',
      solutions: [
        '// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfunction cycleInGraph(edges) {\n  const numberOfNodes = edges.length;\n  const visited = new Array(numberOfNodes).fill(false);\n  const currentlyInStack = new Array(numberOfNodes).fill(false);\n\n  for (let node = 0; node < numberOfNodes; node++) {\n    if (visited[node]) continue;\n\n    const containsCycle = isNodeInCycle(node, edges, visited, currentlyInStack);\n    if (containsCycle) return true;\n  }\n\n  return false;\n}\n\nfunction isNodeInCycle(node, edges, visited, currentlyInStack) {\n  visited[node] = true;\n  currentlyInStack[node] = true;\n\n  const neighbors = edges[node];\n  for (const neighbor of neighbors) {\n    if (!visited[neighbor]) {\n      const containsCycle = isNodeInCycle(neighbor, edges, visited, currentlyInStack);\n      if (containsCycle) return true;\n    } else if (currentlyInStack[neighbor]) {\n      return true;\n    }\n  }\n\n  currentlyInStack[node] = false;\n  return false;\n}\n\n// Do not edit the line below.\nexports.cycleInGraph = cycleInGraph;\n',
        'const [WHITE, GREY, BLACK] = [0, 1, 2];\n\n// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfunction cycleInGraph(edges) {\n  const numberOfNodes = edges.length;\n  const colors = new Array(numberOfNodes).fill(WHITE);\n\n  for (let node = 0; node < numberOfNodes; node++) {\n    if (colors[node] != WHITE) continue;\n\n    const containsCycle = traverseAndColorNodes(node, edges, colors);\n    if (containsCycle) return true;\n  }\n\n  return false;\n}\n\nfunction traverseAndColorNodes(node, edges, colors) {\n  colors[node] = GREY;\n\n  const neighbors = edges[node];\n  for (const neighbor of neighbors) {\n    const neighborColor = colors[neighbor];\n\n    if (neighborColor === GREY) return true;\n\n    if (neighborColor === BLACK) continue;\n\n    const containsCycle = traverseAndColorNodes(neighbor, edges, colors);\n    if (containsCycle) return true;\n  }\n\n  colors[node] = BLACK;\n  return false;\n}\n\n// Do not edit the line below.\nexports.cycleInGraph = cycleInGraph;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[1, 3], [2, 3, 4], [0], [], [2, 5], []];\n  const expected = true;\n  const actual = program.cycleInGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[1, 3], [2, 3, 4], [0], [], [2, 5], []];\n  const expected = true;\n  const actual = program.cycleInGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(v + e) time | O(v) space - where v is the number of vertices and e is the number of edges in the graph',
    tests: [
      { edges: [[1, 3], [2, 3, 4], [0], [], [2, 5], []] },
      { edges: [[1, 2], [2], []] },
      { edges: [[1, 2], [2], [1]] },
      { edges: [[1, 2], [2], [1, 3], [3]] },
      { edges: [[], [0, 2], [0, 3], [0, 4], [0, 5], [0]] },
      { edges: [[0]] },
      { edges: [[8], [0, 2], [0, 3], [0, 4], [0, 5], [0], [7], [8], [6]] },
      { edges: [[1], [2, 3, 4, 5, 6, 7], [], [2, 7], [5], [], [4], []] },
      { edges: [[1], [2, 3, 4, 5, 6, 7], [], [2, 7], [5], [], [4], [0]] },
      { edges: [[0], [1]] },
      { edges: [[1, 2], [2], []] },
      { edges: [[], [0, 3], [0], [1, 2]] },
    ],
  },
  {
    id: 'detect-arbitrage',
    name: 'Detect Arbitrage',
    category: 'Graphs',
    complexity: 3,
    prompt:
      "<div class=\"html\">\n<p>\n  You're given a two-dimensional array (a matrix) of equal height and width that\n  represents the exchange rates of arbitrary currencies. The length of the array\n  is the number of currencies, and every currency can be converted to every\n  other currency. Each currency is represented by a row in the array, where\n  values in that row are the floating-point exchange rates between the row's\n  currency and all other currencies, as in the example below.\n</p>\n<pre>\n       0:USD 1:CAD  2:GBP \n0:USD [  1.0, 1.27, 0.718] \n1:CAD [ 0.74,  1.0,  0.56] \n2:GBP [ 1.39, 1.77,   1.0]\n</pre>\n<p>\n  In the matrix above, you can see that row <span>0</span> represents USD, which\n  means that row <span>0</span> contains the exchange rates for\n  <span>1</span> USD to all other currencies. Since row\n  <span>1</span> represents CAD, index <span>1</span> in the USD row contains\n  the exchange for <span>1</span> USD to CAD. The currency labels are listed\n  above to help you visualize the problem, but they won't actually be included\n  in any inputs and aren't relevant to solving this problem.\n</p>\n<p>\n  Write a function that returns a boolean representing whether an arbitrage\n  opportunity exists with the given exchange rates. An arbitrage occurs if you\n  can start with <span>C</span> units of one currency and execute a series of\n  exchanges that lead you to having more than <span>C</span> units of the same\n  currency you started with.\n</p>\n<p>\n  Note: currency exchange rates won't represent real-world exchange rates, and\n  there might be multiple ways to generate an arbitrage.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">exchangeRates</span> = [\n  [   1.0, 0.8631, 0.5903],\n  [1.1586,    1.0, 0.6849],\n  [1.6939,   1.46,    1.0],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue \n</pre>\n</div>",
    hints: [
      "<p>\n  Try treating this problem like a graph problem, where the currencies are the\n  vertices and the exchange rates are the edges. Think about what properties of\n  this graph would determine if there's an arbitrage opportunity.\n</p>\n",
      "\n<p>\n  If you're able to find a cycle in the graph whose edges multiply to more than\n  <span>1</span>, then you've found an arbitrage. If a cycle that fits this\n  criteria exists, there must be an arbitrage, because it means that you can\n  start at a certain currency in the cycle and return back to that original\n  currency with more units than you started with.\n</p>\n",
      "\n<p>\n  Finding a cycle whose edges multiply to more than <span>1</span> isn't a very\n  common problem in Computer Science. However, finding a cycle whose edges add\n  up to a negative value (a negative weight cycle) is much more common. Is there\n  a way that you can mutate the edge weights in your graph such that finding a\n  negative weight cycle in this mutated graph indicates an arbitrage? Hint:\n  think about logarithms and how <span>log(a * b) = log(a) + log(b)</span>.\n</p>\n",
      "\n<p>\n  Change all of the edge weights in the graph to be their negative logarithm. In\n  other words, create a new matrix of exchange rates, where every value is the\n  negative logarithm of the original exchange rate. Once this is done, you can\n  use the Bellman-Ford algorithm to detect the presence of a negative weight\n  cycle in the graph. If you detect a negative weight cycle, then an arbitrage\n  exists. See the Conceptual Overview section of this question's video\n  explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'exchangeRates',
        example: [
          [1, 0.8631, 0.5903],
          [1.1586, 1, 0.6849],
          [1.6939, 1.46, 1],
        ],
        schema: {
          items: { items: { type: 'number' }, type: 'array' },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function detectArbitrage(exchangeRates) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.detectArbitrage = detectArbitrage;\n',
      solutions: [
        "// O(n^3) time | O(n^2) space - where n is the number of currencies\nfunction detectArbitrage(exchangeRates) {\n  // To use exchange rates as edge weights, we must be able to add them.\n  // Since log(a*b) = log(a) + log(b), we can convert all rates to\n  // -log10(rate) to use them as edge weights.\n  const logExchangeRates = convertToLogMatrix(exchangeRates);\n\n  // A negative weight cycle indicates an arbitrage.\n  return foundNegativeWeightCycle(logExchangeRates, 0);\n}\n\n// Runs the BellmanFord Algorithm to detect any negative-weight cycles.\nfunction foundNegativeWeightCycle(graph, start) {\n  const distancesFromStart = new Array(graph.length).fill(Infinity);\n  distancesFromStart[start] = 0;\n\n  for (let idx = 0; idx < graph.length - 1; idx++) {\n    // If no update occurs, that means there's no negative cycle.\n    if (!relaxEdgesAndUpdateDistances(graph, distancesFromStart)) return false;\n  }\n\n  return relaxEdgesAndUpdateDistances(graph, distancesFromStart);\n}\n\n// Returns `true` if any distance was updated\nfunction relaxEdgesAndUpdateDistances(graph, distances) {\n  let updated = false;\n  for (let sourceIdx = 0; sourceIdx < graph.length; sourceIdx++) {\n    const edges = graph[sourceIdx];\n    for (let destinationIdx = 0; destinationIdx < edges.length; destinationIdx++) {\n      const edgeWeight = edges[destinationIdx];\n      const newDistanceToDestination = distances[sourceIdx] + edgeWeight;\n      if (newDistanceToDestination < distances[destinationIdx]) {\n        updated = true;\n        distances[destinationIdx] = newDistanceToDestination;\n      }\n    }\n  }\n\n  return updated;\n}\n\nfunction convertToLogMatrix(matrix) {\n  const newMatrix = [];\n  for (let row = 0; row < matrix.length; row++) {\n    const rates = matrix[row];\n    newMatrix.push([]);\n    for (const rate of rates) {\n      newMatrix[row].push(-Math.log10(rate));\n    }\n  }\n  return newMatrix;\n}\n\n// Do not edit the line below.\nexports.detectArbitrage = detectArbitrage;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1.0, 0.8631, 0.5903],\n    [1.1586, 1.0, 0.6849],\n    [1.6939, 1.46, 1.0],\n  ];\n  const expected = true;\n  const actual = program.detectArbitrage(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1.0, 0.8631, 0.5903],\n    [1.1586, 1.0, 0.6849],\n    [1.6939, 1.46, 1.0],\n  ];\n  const expected = true;\n  const actual = program.detectArbitrage(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n^3) time | O(n^2) space - where n is the number of currencies',
    tests: [
      {
        exchangeRates: [
          [1, 0.8631, 0.5903],
          [1.1586, 1, 0.6849],
          [1.6939, 1.46, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 106.6, 0.83],
          [0.0093, 1, 0.0078],
          [1.21, 128.69, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 2],
          [0.5, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 2],
          [0.6, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 2],
          [0.4, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 0.5, 0.25],
          [2, 1, 0.5],
          [4, 2, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 0.5, 0.25, 2],
          [2, 1, 0.5, 4],
          [4, 2, 1, 8],
          [0.5, 0.25, 0.0125, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 0.52, 0.25, 2],
          [2, 1, 0.5, 4],
          [4, 2, 1, 8],
          [0.5, 0.24, 0.0125, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 0.5, 0.25, 2, 4],
          [2, 1, 0.5, 4, 8],
          [4, 2, 1, 8, 16],
          [0.5, 0.25, 0.0125, 1, 2],
          [0.25, 0.0125, 0.00625, 0.5, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 0.523, 0.25, 2, 4],
          [2, 1.023, 0.512, 4, 8],
          [4.1, 2, 1, 8.02, 16],
          [0.5, 0.215, 0.01235, 1, 2],
          [0.25, 0.01251, 0.00625, 0.5, 1],
        ],
      },
      {
        exchangeRates: [
          [1, 0.5, 0.25, 2, 4],
          [2, 1, 0.5, 4, 8],
          [4, 2, 1, 8, 16],
          [0.5, 0.25, 0.0125, 1, 2],
          [0.25, 0.0125, 0.00625, 0.5, 1],
        ],
      },
    ],
  },
  {
    id: 'two-edge-connected-graph',
    name: 'Two-Edge-Connected Graph',
    category: 'Graphs',
    complexity: 3,
    prompt:
      "<div class=\"html\">\n<p>\n  You're given a list of <span>edges</span> representing an unweighted and\n  undirected graph. Write a function that returns a boolean representing whether\n  the given graph is two-edge-connected.\n</p>\n<p>\n  A graph is connected if, for every pair of vertices in the graph, there's a\n  path of one or more edges connecting the given vertices. A graph that isn't\n  connected is said to be disconnected.\n</p>\n<p>\n  A graph is two-edge-connected if, for every one of its edges, the edge's\n  removal from the graph doesn't cause the graph to become disconnected. If the\n  removal of any single edge disconnects the graph, then it isn't\n  two-edge-connected. If the given graph is already disconnected, then it also\n  isn't two-edge-connected. An empty graph is considered two-edge-connected.\n</p>\n<p>\n  The input list is what's called an adjacency list, and it represents a graph.\n  The number of vertices in the graph is equal to the length of\n  <span>edges</span>, where each index <span>i</span> in\n  <span>edges</span> contains vertex <span>i</span>'s outbound edges, in no\n  particular order. Each outbound edge is represented by a positive integer that\n  denotes an index (a destination vertex) in the list that this vertex is\n  connected to. Note that these edges are undirected, meaning that you can\n  travel from a particular vertex to its destination and from the destination\n  back to that vertex. Since these edges are undirected, if vertex\n  <span>i</span> has an outbound edge to vertex <span>j</span>, then vertex\n  <span>j</span> is guaranteed to have an outbound edge to vertex\n  <span>i</span>. For example, an undirected graph with two vertices and one\n  edge would be represented by the following adjacency list\n  <span>edges = [[1], [0]]</span>.\n</p>\n<p>\n  Note that the input graph will never contain parallel edges (edges that share\n  the same source and destination vertices). In other words, there will never be\n  more than one edge that connects the same two vertices to each other.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">edges</span> = [\n  [1, 2, 5],\n  [0, 2],\n  [0, 1, 3],\n  [2, 4, 5],\n  [3, 5],\n  [0, 3, 4],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue \n</pre>\n</div>",
    hints: [
      "<p>\n  The brute-force approach to solving this problem is to simply remove one edge\n  from the graph at a time and to then check if the resulting graph is\n  disconnected. This approach works, but is isn't optimal. Can you think of a\n  better approach?\n</p>\n",
      "\n<p>\n  It's easy to see that, if there's only one edge that connects a vertex or a\n  group of vertices to the rest of the graph, then this graph isn't\n  two-edge-connected. This is because, after the removal of that particular\n  edge, the graph would become disconnected. This type of edge is what's known\n  as a bridge; if you discover a bridge in the graph, the graph isn't\n  two-edge-connected.\n</p>\n",
      "\n<p>\n  In order for a graph to be two-edge-connected, it must be connected before the\n  removal of any edges, and it must not contain any bridges. To determine if a\n  graph is connected, you can simply run a depth-first search from any vertex\n  and see if you're able to visit every other vertex. To determine if a graph\n  contains any bridges is a little bit more difficult, but it can be done with a\n  modified depth-first search that considers the different types of edges in the\n  graph.\n</p>\n",
      "\n<p>\n  To confirm that no bridges exist in the graph, you need to see if there's an\n  edge from every vertex in the graph to a vertex that is visited before it in a\n  depth-first search (this is known as a back edge). A back edge indicates that\n  there's a way to reach a vertex other than from the original edge that reached\n  it. This means that if you remove the original edge that reached a vertex, it\n  can still be visited, and the original edge you've just removed isn't a\n  bridge. If every vertex in the graph (with the exception of the starting\n  vertex in a given depth-first search) has a back edge, then the graph is\n  two-edge-connected. See the Conceptual Overview section of this question's\n  video explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'edges',
        example: [
          [1, 2, 5],
          [0, 2],
          [0, 1, 3],
          [2, 4, 5],
          [3, 5],
          [0, 3, 4],
        ],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function twoEdgeConnectedGraph(edges) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.twoEdgeConnectedGraph = twoEdgeConnectedGraph;\n',
      solutions: [
        "// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfunction twoEdgeConnectedGraph(edges) {\n  if (edges.length === 0) return true;\n\n  const arrivalTimes = new Array(edges.length).fill(-1);\n  const startVertex = 0;\n\n  if (getMinimumArrivalTimeOfAncestors(startVertex, -1, 0, arrivalTimes, edges) === -1) {\n    return false;\n  }\n\n  return areAllVerticesVisited(arrivalTimes);\n}\n\nfunction areAllVerticesVisited(arrivalTimes) {\n  for (const time of arrivalTimes) {\n    if (time === -1) return false;\n  }\n\n  return true;\n}\n\nfunction getMinimumArrivalTimeOfAncestors(currentVertex, parent, currentTime, arrivalTimes, edges) {\n  arrivalTimes[currentVertex] = currentTime;\n\n  let minimumArrivalTime = currentTime;\n\n  for (const destination of edges[currentVertex]) {\n    if (arrivalTimes[destination] === -1) {\n      minimumArrivalTime = Math.min(\n        minimumArrivalTime,\n        getMinimumArrivalTimeOfAncestors(\n          destination,\n          currentVertex,\n          currentTime + 1,\n          arrivalTimes,\n          edges,\n        ),\n      );\n    } else if (destination !== parent) {\n      minimumArrivalTime = Math.min(minimumArrivalTime, arrivalTimes[destination]);\n    }\n  }\n\n  // A bridge was detected, which means the graph isn't two-edge-connected.\n  if (minimumArrivalTime === currentTime && parent !== -1) return -1;\n\n  return minimumArrivalTime;\n}\n\n// Do not edit the line below.\nexports.twoEdgeConnectedGraph = twoEdgeConnectedGraph;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 5],\n    [0, 2],\n    [0, 1, 3],\n    [2, 4, 5],\n    [3, 5],\n    [0, 3, 4],\n  ];\n  const expected = true;\n  const actual = program.twoEdgeConnectedGraph(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(v + e) time | O(v) space - where v is the number of vertices and e is the number of edges in the graph',
    tests: [
      {
        edges: [
          [1, 2, 5],
          [0, 2],
          [0, 1, 3],
          [2, 4, 5],
          [3, 5],
          [0, 3, 4],
        ],
      },
      { edges: [[1], [0, 2, 3], [1, 3], [1, 2]] },
      {
        edges: [
          [1, 2],
          [0, 2, 3],
          [1, 3, 0],
          [1, 2],
        ],
      },
      { edges: [[1], [0]] },
      { edges: [[], []] },
      {
        edges: [
          [1, 2, 3],
          [0, 2],
          [0, 1],
          [0, 4, 5],
          [3, 5],
          [3, 4],
        ],
      },
      {
        edges: [
          [1, 2, 3, 5],
          [0, 2],
          [0, 1],
          [0, 4, 5],
          [3, 5],
          [3, 4, 0],
        ],
      },
      { edges: [[]] },
      {
        edges: [
          [1, 5, 6],
          [0, 2, 6],
          [1, 6, 3],
          [6, 2, 4],
          [5, 6, 3],
          [4, 6, 0],
          [0, 1, 2, 3, 4, 5],
        ],
      },
      {
        edges: [
          [1, 5, 6],
          [0, 2, 6],
          [1, 6, 3],
          [6, 2, 4],
          [6, 3],
          [0],
          [0, 1, 2, 3, 4],
        ],
      },
      {
        edges: [
          [1, 2],
          [0, 2, 3],
          [1, 0, 4],
          [1, 4],
          [3, 2],
        ],
      },
      { edges: [[1, 2], [0, 2, 3], [1, 0, 4], [1, 4], [3, 2], []] },
      {
        edges: [
          [1, 7, 4],
          [0, 2, 7],
          [1, 6],
          [7, 5],
          [0, 7, 5],
          [4, 7, 6, 3],
          [5, 2, 7],
          [6, 0, 1, 3, 4, 5],
        ],
      },
      { edges: [] },
    ],
  },
  {
    id: 'minimum-passes-of-matrix',
    name: 'Minimum Passes Of Matrix',
    category: 'Graphs',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an integer matrix of potentially unequal height\n  and width and returns the minimum number of passes required to convert all\n  negative integers in the matrix to positive integers.\n</p>\n<p>\n  A negative integer in the matrix can only be converted to a positive integer\n  if one or more of its adjacent elements is positive. An adjacent element is an\n  element that is to the left, to the right, above, or below the current element\n  in the matrix. Converting a negative to a positive simply involves multiplying\n  it by <span>-1</span>.\n</p>\n<p>\n  Note that the <span>0</span> value is neither positive nor negative, meaning\n  that a <span>0</span> can\'t convert an adjacent negative to a positive.\n</p>\n<p>\n  A single pass through the matrix involves converting all the negative integers\n  that <i>can</i> be converted at a particular point in time. For example,\n  consider the following input matrix:\n</p>\n<pre>\n[ \n  [0, -2, -1], \n  [-5, 2, 0], \n  [-6, -2, 0],\n]\n</pre>\n<p>After a first pass, only 3 values can be converted to positives:</p>\n<pre>\n[ \n  [0, 2, -1], \n  [5, 2, 0], \n  [-6, 2, 0],\n]\n</pre>\n<p>\n  After a second pass, the remaining negative values can all be converted to\n  positives:\n</p>\n<pre>\n[ \n  [0, 2, 1], \n  [5, 2, 0], \n  [6, 2, 0],\n]\n</pre>\n<p>\n  Note that the input matrix will always contain at least one element. If the\n  negative integers in the input matrix can\'t all be converted to positives,\n  regardless of how many passes are run, your function should return\n  <span>-1</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">matrix</span> = [\n  [0, -1, -3, 2, 0],\n  [1, -2, -5, -1, -3],\n  [3, 0, 0, -4, -1],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3\n</pre>\n</div>',
    hints: [
      "<p>\n  The brute-force approach to solving this problem is to simply iterate through\n  the entire matrix, find all positive values, and change their negative\n  neighbors to positive. You then repeat this process until no more negative\n  neighbors exist. This approach works, but it doesn't run in an optimal time\n  complexity; can you think of a another way to solve this?\n</p>\n",
      '\n<p>\n  The approach discussed in Hint #1 has you look at the same elements in the\n  matrix multiple times. How can you ensure that you never process the same\n  element more than once?\n</p>\n',
      '\n<p>\n  Once a positive value has been found and you change its neighbors to\n  positives, this positive value can no longer lead to the conversion of any\n  more negative values. Instead, its neighbors (that you just changed to\n  positives) have the possibility of changing their own neighbors to positives.\n  After you change a negative value to positive, you should store its position\n  so that you can check if it can flip any of its neighbors in the next pass of\n  the matrix. Can something similar to a breadth-first search help you do this?\n</p>\n',
      '\n<p>\n  You can solve this problem in <span>O(w * h)</span> time, where\n  <span>w</span> and <span>h</span> are the width and height of the matrix, by\n  implementing a breadth-first search, starting from all the positive-value\n  positions in the array. Initialize a queue that stores the positions of all\n  positive values, iterate through the queue, dequeue elements out, and consider\n  all of their neighbors. If any of their neighbors are negative, change them to\n  positive, and store their positions in a secondary queue. Once the first queue\n  is empty, increment your number of passes, and iterate through the second\n  queue you created (the one with the positions of negatives that were changed\n  to positives). Repeat this process until no values are converted during a\n  pass.\n</p>\n',
      "\n<p>\n  The approach discussed in Hint #4 can work using either one or two queues. If\n  you decide to use only one queue, you'll need to differentiate the values that\n  were already positive when the current pass started from the values that were\n  changed to positive during the current pass. See the Conceptual Overview\n  section of this question's video explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'matrix',
        example: [
          [0, -1, -3, 2, 0],
          [1, -2, -5, -1, -3],
          [3, 0, 0, -4, -1],
        ],
        schema: {
          items: { items: { type: 'integer' }, minItems: 1, type: 'array' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function minimumPassesOfMatrix(matrix) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.minimumPassesOfMatrix = minimumPassesOfMatrix;\n',
      solutions: [
        "// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfunction minimumPassesOfMatrix(matrix) {\n  const passes = convertNegatives(matrix);\n  return !containsNegative(matrix) ? passes - 1 : -1;\n}\n\nfunction convertNegatives(matrix) {\n  let nextPassQueue = getAllPositivePositions(matrix);\n\n  let passes = 0;\n\n  while (nextPassQueue.length > 0) {\n    const currentPassQueue = nextPassQueue;\n    nextPassQueue = [];\n\n    while (currentPassQueue.length > 0) {\n      // In JavaScript, shifting elements from the start of an array is an O(n)-time operation.\n      // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n      // For our time complexity analysis, we'll assume this runs in O(1) time.\n      // Also, for this particular solution (Solution #1), we could actually\n      // just turn this queue into a stack and replace `.shift()` with the\n      // constant-time `.pop()` operation.\n      const [currentRow, currentCol] = currentPassQueue.shift();\n\n      const adjacentPositions = getAdjacentPositions(currentRow, currentCol, matrix);\n      for (const position of adjacentPositions) {\n        const [row, col] = position;\n\n        const value = matrix[row][col];\n        if (value < 0) {\n          matrix[row][col] *= -1;\n          nextPassQueue.push([row, col]);\n        }\n      }\n    }\n\n    passes++;\n  }\n\n  return passes;\n}\n\nfunction getAllPositivePositions(matrix) {\n  const positivePositions = [];\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const value = matrix[row][col];\n      if (value > 0) positivePositions.push([row, col]);\n    }\n  }\n\n  return positivePositions;\n}\n\nfunction getAdjacentPositions(row, col, matrix) {\n  const adjacentPositions = [];\n\n  if (row > 0) adjacentPositions.push([row - 1, col]);\n  if (row < matrix.length - 1) adjacentPositions.push([row + 1, col]);\n  if (col > 0) adjacentPositions.push([row, col - 1]);\n  if (col < matrix[0].length - 1) adjacentPositions.push([row, col + 1]);\n\n  return adjacentPositions;\n}\n\nfunction containsNegative(matrix) {\n  for (const row of matrix) {\n    for (const value of row) {\n      if (value < 0) return true;\n    }\n  }\n\n  return false;\n}\n\n// Do not edit the line below.\nexports.minimumPassesOfMatrix = minimumPassesOfMatrix;\n",
        "// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfunction minimumPassesOfMatrix(matrix) {\n  const passes = convertNegatives(matrix);\n  return !containsNegative(matrix) ? passes - 1 : -1;\n}\n\nfunction convertNegatives(matrix) {\n  const queue = getAllPositivePositions(matrix);\n\n  let passes = 0;\n\n  while (queue.length > 0) {\n    let currentSize = queue.length;\n\n    while (currentSize > 0) {\n      // In JavaScript, shifting elements from the start of an array is an O(n)-time operation.\n      // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n      // For our time complexity analysis, we'll assume this runs in O(1) time.\n      const [currentRow, currentCol] = queue.shift();\n\n      const adjacentPositions = getAdjacentPositions(currentRow, currentCol, matrix);\n      for (const position of adjacentPositions) {\n        const [row, col] = position;\n\n        const value = matrix[row][col];\n        if (value < 0) {\n          matrix[row][col] *= -1;\n          queue.push([row, col]);\n        }\n      }\n\n      currentSize--;\n    }\n\n    passes++;\n  }\n\n  return passes;\n}\n\nfunction getAllPositivePositions(matrix) {\n  const positivePositions = [];\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      const value = matrix[row][col];\n      if (value > 0) positivePositions.push([row, col]);\n    }\n  }\n\n  return positivePositions;\n}\n\nfunction getAdjacentPositions(row, col, matrix) {\n  const adjacentPositions = [];\n\n  if (row > 0) adjacentPositions.push([row - 1, col]);\n  if (row < matrix.length - 1) adjacentPositions.push([row + 1, col]);\n  if (col > 0) adjacentPositions.push([row, col - 1]);\n  if (col < matrix[0].length - 1) adjacentPositions.push([row, col + 1]);\n\n  return adjacentPositions;\n}\n\nfunction containsNegative(matrix) {\n  for (const row of matrix) {\n    for (const value of row) {\n      if (value < 0) return true;\n    }\n  }\n\n  return false;\n}\n\n// Do not edit the line below.\nexports.minimumPassesOfMatrix = minimumPassesOfMatrix;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, -1, -3, 2, 0],\n    [1, -2, -5, -1, -3],\n    [3, 0, 0, -4, -1],\n  ];\n  const expected = 3;\n  const actual = program.minimumPassesOfMatrix(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, -1, -3, 2, 0],\n    [1, -2, -5, -1, -3],\n    [3, 0, 0, -4, -1],\n  ];\n  const expected = 3;\n  const actual = program.minimumPassesOfMatrix(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(w * h) time | O(w * h) space - where w is the width of the matrix and h is the height',
    tests: [
      {
        matrix: [
          [0, -1, -3, 2, 0],
          [1, -2, -5, -1, -3],
          [3, 0, 0, -4, -1],
        ],
      },
      { matrix: [[1]] },
      {
        matrix: [
          [1, 0, 0, -2, -3],
          [-4, -5, -6, -2, -1],
          [0, 0, 0, 0, -1],
          [1, 2, 3, 0, -2],
        ],
      },
      {
        matrix: [
          [1, 0, 0, -2, -3],
          [-4, -5, -6, -2, -1],
          [0, 0, 0, 0, -1],
          [1, 2, 3, 0, 3],
        ],
      },
      {
        matrix: [
          [1, 0, 0, -2, -3],
          [-4, -5, -6, -2, -1],
          [0, 0, 0, 0, -1],
          [-1, 0, 3, 0, 3],
        ],
      },
      { matrix: [[-1]] },
      {
        matrix: [
          [1, 2, 3],
          [4, 5, 6],
        ],
      },
      {
        matrix: [
          [-1, -9, 0, -1, 0],
          [-9, -4, -5, 4, -8],
          [2, 0, 0, -3, 0],
          [0, -17, -4, 2, -5],
        ],
      },
      {
        matrix: [
          [-2, -3, -4, -1, -9],
          [-4, -3, -4, -1, -2],
          [-6, -7, -2, -1, -1],
          [0, 0, 0, 0, -3],
          [1, -2, -3, -6, -1],
        ],
      },
      {
        matrix: [
          [-1, 2, 3],
          [4, 5, 6],
        ],
      },
      {
        matrix: [
          [-1, 2, 3],
          [4, -5, -6],
        ],
      },
      {
        matrix: [
          [-1, 0, 3],
          [0, -5, -6],
        ],
      },
      {
        matrix: [
          [-1, 0, 3],
          [0, -5, -6],
        ],
      },
      {
        matrix: [
          [0, 0, -1, -2],
          [-2, -3, 4, -1],
          [-2, -3, 1, -3],
          [-14, -15, 2, 0],
          [0, 0, 0, 0],
          [1, -1, -1, -1],
        ],
      },
      {
        matrix: [
          [0, 0, -1, -2],
          [-2, -3, 4, -1],
          [-2, -3, 1, -3],
          [-14, -15, 2, 0],
          [0, 0, 0, 0],
          [1, -1, -1, 1],
        ],
      },
      {
        matrix: [
          [-2, 0, -2, 1],
          [-2, -1, -1, -1],
        ],
      },
    ],
  },
  {
    id: 'min-max-stack-construction',
    name: 'Min Max Stack Construction',
    category: 'Stacks',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a <span>MinMaxStack</span> class for a Min Max Stack. The class should\n  support:\n</p>\n<ul>\n  <li>Pushing and popping values on and off the stack.</li>\n  <li>Peeking at the value at the top of the stack.</li>\n  <li>\n    Getting both the minimum and the maximum values in the stack at any given\n    point in time.\n  </li>\n</ul>\n<p>\n  All class methods, when considered independently, should run in constant time\n  and with constant space.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class="CodeEditor-promptComment">// All operations below are performed sequentially.</span>\n<span class="CodeEditor-promptParameter">MinMaxStack</span>(): - <span class="CodeEditor-promptComment">// instantiate a MinMaxStack</span>\n<span class="CodeEditor-promptParameter">push</span>(5): -\n<span class="CodeEditor-promptParameter">getMin</span>(): 5\n<span class="CodeEditor-promptParameter">getMax</span>(): 5\n<span class="CodeEditor-promptParameter">peek</span>(): 5\n<span class="CodeEditor-promptParameter">push</span>(7): -\n<span class="CodeEditor-promptParameter">getMin</span>(): 5\n<span class="CodeEditor-promptParameter">getMax</span>(): 7\n<span class="CodeEditor-promptParameter">peek</span>(): 7\n<span class="CodeEditor-promptParameter">push</span>(2): -\n<span class="CodeEditor-promptParameter">getMin</span>(): 2\n<span class="CodeEditor-promptParameter">getMax</span>(): 7\n<span class="CodeEditor-promptParameter">peek</span>(): 2\n<span class="CodeEditor-promptParameter">pop</span>(): 2\n<span class="CodeEditor-promptParameter">pop</span>(): 7\n<span class="CodeEditor-promptParameter">getMin</span>(): 5\n<span class="CodeEditor-promptParameter">getMax</span>(): 5\n<span class="CodeEditor-promptParameter">peek</span>(): 5\n</pre>\n</div>',
    hints: [
      '<p>\nYou should be able to push values on, pop values off, and peek at values on top of the stack at any time and in constant time, using constant space. What data structure maintains order and would allow you to do this?\n</p>\n',
      '\n<p>\nYou should be able to get the minimum and maximum values in the stack at any time and in constant time, using constant space. What data structure would allow you to do this?\n</p>\n',
      '\n<p>\nSince the minimum and maximum values in the stack can change with every push and pop, you will likely need to keep track of all the mins and maxes at every value in the stack.\n</p>',
    ],
    customInputVars: [
      {
        name: 'classMethodsToCall',
        example: [
          { arguments: [5], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [7], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [2], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
        ],
        schema: {
          description:
            'These methods will be called in the order that they appear in below\non a <span>MinMaxStack</span> and with their respective arguments.\n',
          items: {
            properties: {
              arguments: { maxItems: 1, type: 'array' },
              method: {
                enum: ['getMax', 'getMin', 'peek', 'pop', 'push'],
                type: 'string',
              },
            },
            required: ['method', 'arguments'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Feel free to add new properties and methods to the class.\nclass MinMaxStack {\n  peek() {\n    // Write your code here.\n  }\n\n  pop() {\n    // Write your code here.\n  }\n\n  push(number) {\n    // Write your code here.\n  }\n\n  getMin() {\n    // Write your code here.\n  }\n\n  getMax() {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.MinMaxStack = MinMaxStack;\n',
      solutions: [
        'class MinMaxStack {\n  constructor() {\n    this.minMaxStack = [];\n    this.stack = [];\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  // O(1) time | O(1) space\n  pop() {\n    this.minMaxStack.pop();\n    return this.stack.pop();\n  }\n\n  // O(1) time | O(1) space\n  push(number) {\n    const newMinMax = {min: number, max: number};\n    if (this.minMaxStack.length) {\n      const lastMinMax = this.minMaxStack[this.minMaxStack.length - 1];\n      newMinMax.min = Math.min(lastMinMax.min, number);\n      newMinMax.max = Math.max(lastMinMax.max, number);\n    }\n    this.minMaxStack.push(newMinMax);\n    this.stack.push(number);\n  }\n\n  // O(1) time | O(1) space\n  getMin() {\n    return this.minMaxStack[this.minMaxStack.length - 1].min;\n  }\n\n  // O(1) time | O(1) space\n  getMax() {\n    return this.minMaxStack[this.minMaxStack.length - 1].max;\n  }\n}\n\n// Do not edit the line below.\nexports.MinMaxStack = MinMaxStack;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nfunction testMinMaxPeek(min, max, peek, stack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(7);\n  testMinMaxPeek(5, 7, 7, stack);\n  stack.push(2);\n  testMinMaxPeek(2, 7, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(5, 5, 5, stack);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nfunction testMinMaxPeek(min, max, peek, stack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(7);\n  testMinMaxPeek(5, 7, 7, stack);\n  stack.push(2);\n  testMinMaxPeek(2, 7, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(5, 5, 5, stack);\n});\n",
    },
    bigO: 'All methods: O(1) time | O(1) space',
    tests: [
      {
        classMethodsToCall: [
          { arguments: [5], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [7], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [2], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [2], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [7], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [1], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [8], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [3], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [9], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [5], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [5], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [5], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [8], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [8], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [0], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [8], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [9], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [5], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [2], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [0], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [5], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [4], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [4], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [11], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [-11], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
          { arguments: [6], method: 'push' },
          { arguments: [], method: 'getMin' },
          { arguments: [], method: 'getMax' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'pop' },
        ],
      },
    ],
  },
  {
    id: 'balanced-brackets',
    name: 'Balanced Brackets',
    category: 'Stacks',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a string made up of brackets (<span>(</span>,\n  <span>[</span>, <span>{</span>, <span>)</span>, <span>]</span>, and\n  <span>}</span>) and other optional characters. The function should return a\n  boolean representing whether the string is balanced with regards to brackets.\n</p>\n<p>\n  A string is said to be balanced if it has as many opening brackets of a\n  certain type as it has closing brackets of that type and if no bracket is\n  unmatched. Note that an opening bracket can\'t match a corresponding closing\n  bracket that comes before it, and similarly, a closing bracket can\'t match a\n  corresponding opening bracket that comes after it. Also, brackets can\'t\n  overlap each other as in\n  <span>[(])</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "([])(){}(())()()"\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue <span class="CodeEditor-promptComment">// it\'s balanced</span>\n</pre>\n</div>',
    hints: [
      "<p>\nIf you iterate through the input string one character at a time, there are two scenarios in which the string will be unbalanced: either you run into a closing bracket with no prior matching opening bracket or you get to the end of the string with some opening brackets that haven't been matched. Can you use an auxiliary data structure to keep track of all the brackets and efficiently check if you run into a unbalanced scenario at every iteration?\n</p>\n",
      "\n<p>\nConsider using a stack to store opening brackets as you traverse the string. The Last-In-First-Out property of the stack should allow you to match any closing brackets that you run into against the most recent opening bracket, if one exists, in which case you can simply pop it out of the stack. How can you check that there are no unmatched opening bracket once you've finished traversing through the string?\n</p>",
    ],
    customInputVars: [
      {
        name: 'string',
        example: '([])(){}(())()()',
        schema: { type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function balancedBrackets(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.balancedBrackets = balancedBrackets;\n',
      solutions: [
        "// O(n) time | O(n) space\nfunction balancedBrackets(string) {\n  const openingBrackets = '([{';\n  const closingBrackets = ')]}';\n  const matchingBrackets = {')': '(', ']': '[', '}': '{'};\n  const stack = [];\n  for (const char of string) {\n    if (openingBrackets.includes(char)) {\n      stack.push(char);\n    } else if (closingBrackets.includes(char)) {\n      if (stack.length == 0) {\n        return false;\n      }\n      if (stack[stack.length - 1] === matchingBrackets[char]) {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.length === 0;\n}\n\nexports.balancedBrackets = balancedBrackets;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.balancedBrackets('([])(){}(())()()')).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.balancedBrackets('([])(){}(())()()')).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input string',
    tests: [
      { string: '([])(){}(())()()' },
      { string: '()[]{}{' },
      { string: '(((((({{{{{[[[[[([)])]]]]]}}}}}))))))' },
      { string: '()()[{()})]' },
      { string: '(()())((()()()))' },
      { string: '{}()' },
      { string: '()([])' },
      { string: '((){{{{[]}}}})' },
      { string: '((({})()))' },
      { string: '(([]()()){})' },
      {
        string:
          '(((((([[[[[[{{{{{{{{{{{{()}}}}}}}}}}}}]]]]]]))))))((([])({})[])[])[]([]){}(())',
      },
      { string: '{[[[[({(}))]]]]}' },
      { string: '[((([])([]){}){}){}([])[]((())' },
      { string: ')[]}' },
      { string: '(a)' },
      { string: '(a(' },
      { string: '(141[])(){waga}((51afaw))()hh()' },
      { string: 'aafwgaga()[]a{}{gggg' },
      { string: '(((((({{{{{safaf[[[[[([)]safsafsa)]]]]]}}}gawga}}))))))' },
      { string: '()(agawg)[{()gawggaw})]' },
      { string: '(()agwg())((()agwga()())gawgwgag)' },
      { string: '{}gawgw()' },
      { string: '(agwgg)([ghhheah%&@Q])' },
    ],
  },
  {
    id: 'shorten-path',
    name: 'Shorten Path',
    category: 'Stacks',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty string representing a valid\n  Unix-shell path and returns a shortened version of that path.\n</p>\n<p>\n  A path is a notation that represents the location of a file or directory in a\n  file system.\n</p>\n<p>\n  A path can be an absolute path, meaning that it starts at the root directory\n  in a file system, or a relative path, meaning that it starts at the current\n  directory in a file system.\n</p>\n<p>In a Unix-like operating system, a path is bound by the following rules:</p>\n<ul>\n  <li>\n    The root directory is represented by a <span>/</span>. This means that if\n    a path <i>starts</i> with <span>/</span>, it\'s an absolute path; if it\n    doesn\'t, it\'s a relative path.\n  </li>\n  <li>\n    The symbol <span>/</span> otherwise represents the directory separator.\n    This means that the path <span>/foo/bar</span> is the location of the\n    directory <span>bar</span> inside the directory <span>foo</span>, which is\n    itself located inside the root directory.\n  </li>\n  <li>\n    The symbol <span>..</span> represents the parent directory. This means\n    that accessing files or directories in <span>/foo/bar/..</span> is\n    equivalent to accessing files or directories in <span>/foo</span>.\n  </li>\n  <li>\n    The symbol <span>.</span> represents the current directory. This means\n    that accessing files or directories in <span>/foo/bar/.</span> is equivalent\n    to accessing files or directories in <span>/foo/bar</span>.\n  </li>\n  <li>\n    The symbols <span>/</span> and <span>.</span> can be repeated sequentially\n    without consequence; the symbol <span>..</span> cannot, however, because\n    repeating it sequentially means going further up in parent directories. For\n    example, <span>/foo/bar/baz/././.</span> and <span>/foo/bar/baz</span> are\n    equivalent paths, but <span>/foo/bar/baz/../../../</span> and\n    <span>/foo/bar/baz</span> definitely aren\'t. The only exception is with the\n    root directory: <span>/../../..</span> and <span>/</span> are equivalent,\n    because the root directory has no parent directory, which means that\n    repeatedly accessing parent directories does nothing.\n  </li>\n</ul>\n<p>\n  Note that the shortened version of the path must be equivalent to the original\n  path. In other words, it must point to the same file or directory as the\n  original path.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">path</span> = "/foo/../test/../test/../foo//bar/./baz"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"/foo/bar/baz" <span class="CodeEditor-promptComment">// This path is equivalent to the input path.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nA path effectively consists of meaningful "tokens" (like directory names and symbols) that have been put together. Try transforming the string version of the path into a list of meaningful tokens that you can then analyze as you see fit.\n</p>\n',
      '\n<p>\nSplit the input path around the directory separator "/" using a native "split" function and try eliminating meaningless tokens from the resulting list of tokens. Meaningless tokens will include the empty string and the "." symbol, since the emptry string will represent sequential "/"s, which are effectively useless, and the "." symbol is also effectively useless.\n</p>\n',
      '\n<p>\nThe ".." symbol essentially requires you to remove the previous token in the list of tokens; try using a stack to implement the logic of parsing out ".." symbols and the relevant parent directories.\n</p>\n',
      '\n<p>\nYou\'ll need to handle two edge cases: the case where the path is an absolute one (for this, you\'ll have to identify if the path starts with a "/" at the beginning of your algorithm and then tweak other logic accordingly) and the case where the path is a relative one that starts with one or multiple ".." symbols (in this case, you\'ll want to keep these symbols, since they\'re meaningful to the path).\n</p>',
    ],
    customInputVars: [
      {
        name: 'path',
        example: '/foo/../test/../test/../foo//bar/./baz',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function shortenPath(path) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.shortenPath = shortenPath;\n',
      solutions: [
        "// O(n) time | O(n) space - where n is the length of the path\nfunction shortenPath(path) {\n  const startsWithSlash = path[0] === '/';\n  const tokens = path.split('/').filter(isImportantToken);\n  const stack = [];\n  if (startsWithSlash) stack.push('');\n  for (const token of tokens) {\n    if (token === '..') {\n      if (stack.length === 0 || stack[stack.length - 1] === '..') {\n        stack.push(token);\n      } else if (stack[stack.length - 1] !== '') {\n        stack.pop();\n      }\n    } else {\n      stack.push(token);\n    }\n  }\n\n  if (stack.length === 1 && stack[0] === '') return '/';\n  return stack.join('/');\n}\n\nfunction isImportantToken(token) {\n  return token.length > 0 && token !== '.';\n}\n\nexports.shortenPath = shortenPath;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = '/foo/../test/../test/../foo//bar/./baz';\n  chai.expect(program.shortenPath(input)).to.deep.equal('/foo/bar/baz');\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = '/foo/../test/../test/../foo//bar/./baz';\n  chai.expect(program.shortenPath(input)).to.deep.equal('/foo/bar/baz');\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the pathname',
    tests: [
      { path: '/foo/../test/../test/../foo//bar/./baz' },
      { path: '/foo/bar/baz' },
      { path: 'foo/bar/baz' },
      { path: '/../../foo/bar/baz' },
      { path: '../../foo/bar/baz' },
      { path: '/../../foo/../../bar/baz' },
      { path: '../../foo/../../bar/baz' },
      { path: '/foo/./././bar/./baz///////////test/../../../kappa' },
      {
        path: '../../../this////one/./../../is/../../going/../../to/be/./././../../../just/eight/double/dots/../../../../../..',
      },
      {
        path: '/../../../this////one/./../../is/../../going/../../to/be/./././../../../just/a/forward/slash/../../../../../..',
      },
      {
        path: '../../../this////one/./../../is/../../going/../../to/be/./././../../../just/eight/double/dots/../../../../../../foo',
      },
      {
        path: '/../../../this////one/./../../is/../../going/../../to/be/./././../../../just/a/forward/slash/../../../../../../foo',
      },
      { path: 'foo/bar/..' },
      { path: './foo/bar' },
      { path: 'foo/../..' },
      { path: '/' },
      { path: './..' },
    ],
  },
  {
    id: 'sunset-views',
    name: 'Sunset Views',
    category: 'Stacks',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Given an array of buildings and a direction that all of the buildings face,\n  return an array of the indices of the buildings that can see the sunset.\n</p>\n<p>\n  A building can see the sunset if it\'s strictly taller than all of the\n  buildings that come after it in the direction that it faces.\n</p>\n<p>\n  The input array named <span>buildings</span> contains positive, non-zero\n  integers representing the heights of the buildings. A building at index\n  <span>i</span> thus has a height denoted by <span>buildings[i]</span>. All of\n  the buildings face the same direction, and this direction is either east or\n  west, denoted by the input string named <span>direction</span>, which will\n  always be equal to either <span>"EAST"</span> or <span>"WEST"</span>. In\n  relation to the input array, you can interpret these directions as right for\n  east and left for west.\n</p>\n<p>\n  Important note: the indices in the ouput array should be sorted in ascending\n  order.\n</p>\n<h3>Sample Input #1</h3>\n<pre>\n<span class="CodeEditor-promptParameter">buildings</span> = [3, 5, 4, 4, 3, 1, 3, 2]\n<span class="CodeEditor-promptParameter">direction</span> = "EAST"\n</pre>\n<h3>Sample Output #1</h3>\n<pre>\n[1, 3, 6, 7]\n\n<span class="CodeEditor-promptComment">// Below is a visual representation of the sample input.</span>\n<span class="CodeEditor-promptComment">//    _</span>\n<span class="CodeEditor-promptComment">//   | |_ _</span>\n<span class="CodeEditor-promptComment">//  _| | | |_   _</span>\n<span class="CodeEditor-promptComment">// | | | | | | | |_</span>\n<span class="CodeEditor-promptComment">// | | | | | |_| | |</span>\n<span class="CodeEditor-promptComment">// |_|_|_|_|_|_|_|_|</span>\n</pre>\n<h3>Sample Input #2</h3>\n<pre>\n<span class="CodeEditor-promptParameter">buildings</span> = [3, 5, 4, 4, 3, 1, 3, 2]\n<span class="CodeEditor-promptParameter">direction</span> = "WEST"\n</pre>\n<h3>Sample Output #2</h3>\n<pre>\n[0, 1]\n\n<span class="CodeEditor-promptComment">// The buildings are the same as in the first sample</span>\n<span class="CodeEditor-promptComment">// input, but their direction is reversed.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nIs there a way to solve this problem in one loop?\n</p>\n',
      '\n<p>\nHow does your solution change based on the direction that the buildings are facing? You can use the same approach for each direction by simply changing the direction in which you traverse the array of buildings.\n</p>\n',
      "\n<p>\nThere are multiple ways to solve this problem, but one is to maintain a running maximum of building heights. Loop in the opposite direction that the buildings are facing, and keep track of the maximum building height that you've seen. At each iteration, compare the height of the current building to the running maximum; if the current building is taller, then it can see the sunset; otherwise, it can't. Finally, at each iteration, update the running maximum.\n</p>\n",
      '\n<p>\nAnother way to solve this problem is to use a stack. Loop in the direction that the buildings are facing, and add the index of the current building to the stack at the end of each iteration. Before adding elements to the stack, compare the current building height to buildings at the top of the stack. Pop off the top of the stack until the current building height is shorter than the height of the building at the top of the stack. This will remove all buildings that are blocked from seeing the sunset by the current building. At the end of the algorithm, the stack will only contain elements that can see the sunset.\n</p>',
    ],
    customInputVars: [
      {
        name: 'buildings',
        example: [3, 5, 4, 4, 3, 1, 3, 2],
        schema: { items: { minimum: 1, type: 'integer' }, type: 'array' },
      },
      {
        name: 'direction',
        example: 'EAST',
        schema: { enum: ['EAST', 'WEST'], type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function sunsetViews(buildings, direction) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.sunsetViews = sunsetViews;\n',
      solutions: [
        "// O(n) time | O(n) space - where n is the length of the input array\nfunction sunsetViews(buildings, direction) {\n  const buildingsWithSunsetViews = [];\n\n  const startIdx = direction === 'WEST' ? 0 : buildings.length - 1;\n  const step = direction === 'WEST' ? 1 : -1;\n\n  let idx = startIdx;\n  let runningMaxHeight = 0;\n  while (idx >= 0 && idx < buildings.length) {\n    const buildingHeight = buildings[idx];\n\n    if (buildingHeight > runningMaxHeight) buildingsWithSunsetViews.push(idx);\n\n    runningMaxHeight = Math.max(runningMaxHeight, buildingHeight);\n\n    idx = idx + step;\n  }\n\n  if (direction === 'EAST') buildingsWithSunsetViews.reverse();\n\n  return buildingsWithSunsetViews;\n}\n\n// Do not edit the line below.\nexports.sunsetViews = sunsetViews;\n",
        "// O(n) time | O(n) space - where n is the length of the input array\nfunction sunsetViews(buildings, direction) {\n  const candidateBuildings = [];\n\n  const startIdx = direction === 'EAST' ? 0 : buildings.length - 1;\n  const step = direction === 'EAST' ? 1 : -1;\n\n  let idx = startIdx;\n  while (idx >= 0 && idx < buildings.length) {\n    const buildingHeight = buildings[idx];\n\n    while (\n      candidateBuildings.length > 0 &&\n      buildings[candidateBuildings[candidateBuildings.length - 1]] <= buildingHeight\n    ) {\n      candidateBuildings.pop();\n    }\n\n    candidateBuildings.push(idx);\n\n    idx = idx + step;\n  }\n\n  if (direction === 'WEST') candidateBuildings.reverse();\n\n  return candidateBuildings;\n}\n\n// Do not edit the line below.\nexports.sunsetViews = sunsetViews;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const buildings = [3, 5, 4, 4, 3, 1, 3, 2];\n  const direction = 'EAST';\n  const expected = [1, 3, 6, 7];\n  const actual = program.sunsetViews(buildings, direction);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const buildings = [3, 5, 4, 4, 3, 1, 3, 2];\n  const direction = 'EAST';\n  const expected = [1, 3, 6, 7];\n  const actual = program.sunsetViews(buildings, direction);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input array',
    tests: [
      { buildings: [3, 5, 4, 4, 3, 1, 3, 2], direction: 'EAST' },
      { buildings: [3, 5, 4, 4, 3, 1, 3, 2], direction: 'WEST' },
      { buildings: [10, 11], direction: 'EAST' },
      { buildings: [2, 4], direction: 'WEST' },
      { buildings: [1], direction: 'EAST' },
      { buildings: [1], direction: 'WEST' },
      { buildings: [], direction: 'EAST' },
      { buildings: [], direction: 'WEST' },
      { buildings: [7, 1, 7, 8, 9, 8, 7, 6, 5, 4, 2, 5], direction: 'EAST' },
      { buildings: [1, 2, 3, 4, 5, 6], direction: 'EAST' },
      { buildings: [1, 2, 3, 4, 5, 6], direction: 'WEST' },
      {
        buildings: [1, 2, 3, 1, 5, 6, 9, 1, 9, 9, 11, 10, 9, 12, 8],
        direction: 'WEST',
      },
      {
        buildings: [20, 2, 3, 1, 5, 6, 9, 1, 9, 9, 11, 10, 9, 12, 8],
        direction: 'EAST',
      },
    ],
  },
  {
    id: 'largest-rectangle-under-skyline',
    name: 'Largest Rectangle Under Skyline',
    category: 'Stacks',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of positive integers representing the\n  heights of adjacent buildings and returns the area of the largest rectangle\n  that can be created by any number of adjacent buildings, including just one\n  building. Note that all buildings have the same width of <span>1</span> unit.\n</p>\n<p>\n  For example, given <span>buildings = [2, 1, 2]</span>, the area of the largest\n  rectangle that can be created is <span>3</span>, using all three buildings.\n  Since the minimum height of the three buildings is <span>1</span>, you can\n  create a rectangle that has a height of <span>1</span> and a width of\n  <span>3</span> (the number of buildings). You could also create rectangles of\n  area <span>2</span> by using only the first building or the last building, but\n  these clearly wouldn\'t be the largest rectangles. Similarly, you could create\n  rectangles of area <span>2</span> by using the first and second building or\n  the second and third building.\n</p>\n<p>\n  To clarify, the width of a created rectangle is the number of buildings used\n  to create the rectangle, and its height is the height of the smallest building\n  used to create it.\n</p>\n<p>\n  Note that if no rectangles can be created, your function should return\n  <span>0</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">buildings</span> = [1, 3, 3, 2, 4, 1, 5, 3, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n9\n\n<span class="CodeEditor-promptComment">// Below is a visual representation of the sample input.</span>\n<span class="CodeEditor-promptComment">//              _</span>\n<span class="CodeEditor-promptComment">//          _  | |</span>\n<span class="CodeEditor-promptComment">//    _ _  | | | |_</span>\n<span class="CodeEditor-promptComment">//   | | |_| | | | |_</span>\n<span class="CodeEditor-promptComment">//  _| | | | |_| | | |</span>\n<span class="CodeEditor-promptComment">// |_|_|_|_|_|_|_|_|_|</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  Try treating every building as a pillar of a rectangle that can be created\n  with the height of the building in question.\n</p>\n',
      "\n<p>\n  The brute-force approach to solve this problem involves treating every\n  building as a part of a potential rectangle to be created. As you loop through\n  all the buildings, simply expand to the left and right of the current\n  building, and determine the width of the longest rectangle that you can create\n  that has a height of the current building. Calculate the area of this longest\n  rectangle, and update a variable to store the area of the largest rectangle\n  that you've found so far. This approach has a time complexity of\n  <span>O(n^2)</span>; can you do better?\n</p>\n",
      "\n<p>\n  There's a way to solve this problem in linear (<span>O(n)</span>) time by\n  using a stack. When should you push and pop buildings on and off the stack if\n  you were to loop through the buildings from left to right? Try to think of\n  each building on the stack as a pillar of a potential rectangle.\n</p>\n",
      "\n<p>\n  The stack mentioned in Hint #3 will be used to determine the length of a\n  rectangle that has the height of a building that is currently on top of the\n  stack. Loop through all the buildings, and at each building, compare its\n  height to the height of the building on top of the stack. If the current\n  building's height is smaller than or the same as the height of the building on\n  top of the stack, pop the building off the stack. When you pop the building\n  off the stack, you've determined the rightmost position (your current\n  position) of a rectangle of that height (the height of the building you\n  popped) that uses that building. Then, to determine the leftmost position of\n  that rectangle, you look at the next building on top of the stack. This is the\n  index of the closest building to the left that has a smaller height than that\n  of the building that was just popped off. Now, you can calculate the area of\n  the rectangle that uses this building and update a variable to store the max\n  area. Continue popping buildings off the stack at each iteration until the\n  current building is taller than the one on top of the stack, and don't forget\n  to push each building on top of the stack at each iteration. See the\n  Conceptual Overview section of this question's video explanation for a more\n  in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'buildings',
        example: [1, 3, 3, 2, 4, 1, 5, 3, 2],
        schema: { items: { minimum: 1, type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function largestRectangleUnderSkyline(buildings) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.largestRectangleUnderSkyline = largestRectangleUnderSkyline;\n',
      solutions: [
        '// O(n^2) time | O(1) space - where n is the number of buildings\nfunction largestRectangleUnderSkyline(buildings) {\n  let maxArea = 0;\n  for (let pillarIdx = 0; pillarIdx < buildings.length; pillarIdx++) {\n    const currentHeight = buildings[pillarIdx];\n\n    let furthestLeft = pillarIdx;\n    while (furthestLeft > 0 && buildings[furthestLeft - 1] >= currentHeight) {\n      furthestLeft--;\n    }\n\n    let furthestRight = pillarIdx;\n    while (furthestLeft < buildings.length - 1 && buildings[furthestRight + 1] >= currentHeight) {\n      furthestRight++;\n    }\n\n    const areaWithCurrentBuilding = (furthestRight - furthestLeft + 1) * currentHeight;\n    maxArea = Math.max(areaWithCurrentBuilding, maxArea);\n  }\n\n  return maxArea;\n}\n\n// Do not edit the line below.\nexports.largestRectangleUnderSkyline = largestRectangleUnderSkyline;\n',
        '// O(n) time | O(n) space - where n is the number of buildings\nfunction largestRectangleUnderSkyline(buildings) {\n  const pillarIndices = [];\n  let maxArea = 0;\n\n  const extendedBuildings = buildings.concat([0]);\n  for (let idx = 0; idx < extendedBuildings.length; idx++) {\n    const height = extendedBuildings[idx];\n    while (\n      pillarIndices.length !== 0 &&\n      extendedBuildings[pillarIndices[pillarIndices.length - 1]] >= height\n    ) {\n      const pillarHeight = extendedBuildings[pillarIndices.pop()];\n      const width =\n        pillarIndices.length === 0 ? idx : idx - pillarIndices[pillarIndices.length - 1] - 1;\n      maxArea = Math.max(width * pillarHeight, maxArea);\n    }\n    pillarIndices.push(idx);\n  }\n\n  return maxArea;\n}\n\n// Do not edit the line below.\nexports.largestRectangleUnderSkyline = largestRectangleUnderSkyline;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [1, 3, 3, 2, 4, 1, 5, 3, 2];\n  const expected = 9;\n  const actual = program.largestRectangleUnderSkyline(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [1, 3, 3, 2, 4, 1, 5, 3, 2];\n  const expected = 9;\n  const actual = program.largestRectangleUnderSkyline(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the number of buildings',
    tests: [
      { buildings: [1, 3, 3, 2, 4, 1, 5, 3, 2] },
      { buildings: [4, 4, 4, 2, 2, 1] },
      { buildings: [1, 3, 3, 2, 4, 1, 5, 3] },
      { buildings: [5, 5, 2, 2, 4, 1] },
      { buildings: [1, 2, 3, 4, 5, 11] },
      { buildings: [25, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] },
      { buildings: [20, 2, 2, 2, 2, 2, 10, 5, 5, 5, 4, 4] },
      { buildings: [5, 10, 5, 15, 10, 25] },
      { buildings: [1, 1, 1, 1] },
      { buildings: [10, 21] },
      { buildings: [11, 21] },
      { buildings: [3, 3, 3, 4, 4, 4, 1, 3, 1, 2, 8, 9, 1] },
      { buildings: [5] },
      { buildings: [10, 1, 2, 3, 4, 5, 6, 7] },
      { buildings: [10, 1, 2, 3, 3, 5, 6, 7] },
      { buildings: [] },
    ],
  },
  {
    id: 'best-digits',
    name: 'Best Digits',
    category: 'Stacks',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes a positive integer represented as a string\n  <span>number</span> and an integer <span>numDigits</span>.\n  Remove <span>numDigits</span> from the string so that the number represented\n  by the string is as large as possible afterwards.\n</p>\n<p>\n  Note that the order of the remaining digits cannot be changed. You can assume\n  <span>numDigits</span> will always be less than the length of <span>number</span>\n  and greater than or equal to 0.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">number</span> = "462839"\n<span class="CodeEditor-promptParameter">numDigits</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"6839" <span class="CodeEditor-promptComment">// remove digits 4 and 2</span>\n</pre>\n</div>',
    hints: [
      '<p>\nIf we want the number to be as large as possible then which digits would we want to remove? Consider the importance\nof place values. For example if we\'re given <span>number = "191"</span> and <span>numDigits = 1</span> then which 1\nwould we remove?\n</p>\n',
      "\n<p>\nIt's most important that the largest place values have the highest value digits. If you traverse the string from left to\nright then you will be traversing the place values in order of importance. If you still have digits to remove then you\nneed to remove smaller digits in higher place values. The question then becomes how can you know what comes later on in\nthe string? If you want to solve this problem in linear time what data structure might help you in this situation?\n</p>\n",
      '\n<p>\nUse a stack to push digits onto while traversing the string from left to right. That way top of the stack will always\nhave the digit in the last highest place value. Compare the top of the stack to the current digit and if the current\ndigit is greater than the top of the stack, then pop from the stack. Utilizing a stack allows you to replace small\ndigits with largest digits that come later in the string because you can pop off of the stack in order of importance.\n\nYou will need to build a string to return from the final stack.\n</p>',
    ],
    customInputVars: [
      {
        name: 'numDigits',
        example: 2,
        schema: { minimum: 0, type: 'integer' },
      },
      {
        name: 'number',
        example: '462839',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        "function bestDigits(number, numDigits) {\n  // Write your code here.\n  return '';\n}\n\n// Do not edit the line below.\nexports.bestDigits = bestDigits;\n",
      solutions: [
        "// O(n) time | O(n) space - where n is the length of the input string\nfunction bestDigits(number, numDigits) {\n  const stack = [];\n\n  for (const digit of number) {\n    while (numDigits > 0 && stack.length > 0 && digit > stack[stack.length - 1]) {\n      numDigits--;\n      stack.pop();\n    }\n\n    stack.push(digit);\n  }\n\n  while (numDigits > 0) {\n    numDigits--;\n    stack.pop();\n  }\n\n  return stack.join('');\n}\n\n// Do not edit the line below.\nexports.bestDigits = bestDigits;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const number = '462839';\n  const numDigits = 2;\n  const expected = '6839';\n  const actual = program.bestDigits(number, numDigits);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const number = '462839';\n  const numDigits = 2;\n  const expected = '6839';\n  const actual = program.bestDigits(number, numDigits);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input string',
    tests: [
      { numDigits: 2, number: '462839' },
      { numDigits: 4, number: '129847563' },
      { numDigits: 1, number: '19' },
      { numDigits: 1, number: '22' },
      { numDigits: 1, number: '23' },
      { numDigits: 1, number: '123' },
      { numDigits: 1, number: '321' },
      { numDigits: 2, number: '123' },
      { numDigits: 2, number: '321' },
      { numDigits: 10, number: '11111111119999999999' },
      { numDigits: 9, number: '10000000002' },
      { numDigits: 10, number: '10000000002' },
      { numDigits: 5, number: '1020304050' },
      { numDigits: 4, number: '100300200004' },
      { numDigits: 9, number: '9999999999' },
      { numDigits: 3, number: '111221' },
      { numDigits: 0, number: '12345' },
      { numDigits: 0, number: '54321' },
    ],
  },
  {
    id: 'sort-stack',
    name: 'Sort Stack',
    category: 'Stacks',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers representing a stack,\n  recursively sorts the stack in place (i.e., doesn\'t create a brand new array),\n  and returns it.\n</p>\n<p>\n  The array must be treated as a stack, with the end of the array as the top of\n  the stack. Therefore, you\'re only allowed to\n</p>\n<ul>\n  <li>\n    Pop elements from the top of the stack by removing elements from the end of\n    the array using the built-in <span>.pop()</span> method in your programming\n    language of choice.\n  </li>\n  <li>\n    Push elements to the top of the stack by appending elements to the end of\n    the array using the built-in <span>.append()</span> method in your\n    programming language of choice.\n  </li>\n  <li>\n    Peek at the element on top of the stack by accessing the last element in the\n    array.\n  </li>\n</ul>\n<p>\n  You\'re not allowed to perform any other operations on the input array,\n  including accessing elements (except for the last element), moving elements,\n  etc.. You\'re also not allowed to use any other data structures, and your\n  solution must be recursive.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">stack</span> = [-5, 2, -2, 4, 3, 1]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[-5, -2, 1, 2, 3, 4]\n</pre>\n</div>',
    hints: [
      '<p>\n  If you had to insert a single item into an already sorted stack, all the while\n  abiding by the constraints of this problem, how would you do that?\n</p>\n',
      "\n<p>\n  Inserting a single item in an already sorted stack is fairly simple: you can\n  pop elements off of the stack until you find an element that's smaller than or\n  equal to the value that you want to add. Then, you can push that value on top\n  of the stack and reinsert all the previously popped items back on top of the\n  stack in the reverse order in which you popped them off. The resulting stack\n  will still be sorted.\n</p>\n",
      "\n<p>\n  You can easily insert multiple items in an already sorted stack by just\n  repeatedly performing what's described in Hint #2. However, you'll need to\n  have an already sorted stack. To get an already sorted stack, you'll need to\n  pop all of the elements off the <i>unsorted</i> stack until it's eventually\n  empty, and then you'll need to push all of the items back on the stack,\n  inserting them in their sorted order one at a time.\n</p>\n",
      "\n<p>\n  If you're thinking about Hint #3 recursively, the steps are the following:\n</p>\n<ol>\n  <li>Pop an item from the top of the stack, and hold onto it in memory.</li>\n  <li>\n    Sort the rest of the stack. To do so, repeat step #1 until the stack is\n    empty, at which point you've reached the base case since an empty stack is\n    always sorted.\n  </li>\n  <li>\n    Insert the most recently popped off item from step #1 back into the now\n    sorted stack but in its proper sorted position. The first time that you\n    reinsert an item, it'll be inserted in an empty stack.\n  </li>\n</ol>",
    ],
    customInputVars: [
      {
        name: 'stack',
        example: [-5, 2, -2, 4, 3, 1],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function sortStack(stack) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.sortStack = sortStack;\n',
      solutions: [
        '// O(n^2) time | O(n) space - where n is the length of the stack\nfunction sortStack(stack) {\n  if (stack.length === 0) return stack;\n\n  const top = stack.pop();\n\n  sortStack(stack);\n\n  insertInSortedOrder(stack, top);\n\n  return stack;\n}\n\nfunction insertInSortedOrder(stack, value) {\n  if (stack.length === 0 || stack[stack.length - 1] <= value) {\n    stack.push(value);\n    return;\n  }\n\n  const top = stack.pop();\n\n  insertInSortedOrder(stack, value);\n\n  stack.push(top);\n}\n\n// Do not edit the line below.\nexports.sortStack = sortStack;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [-5, 2, -2, 4, 3, 1];\n  const expected = [-5, -2, 1, 2, 3, 4];\n  const actual = program.sortStack(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [-5, 2, -2, 4, 3, 1];\n  const expected = [-5, -2, 1, 2, 3, 4];\n  const actual = program.sortStack(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the length of the stack',
    tests: [
      { stack: [-5, 2, -2, 4, 3, 1] },
      { stack: [3, 4, 5, 1, 2] },
      { stack: [0, -2, 3, 4, 1, -9, 8] },
      { stack: [2, 4, 22, 1, -9, 0, 6, 23, -2, 1] },
      { stack: [3, 4, 5, 1, 2] },
      { stack: [-1, 0, 2, 3, 4, 1, 1, 1] },
      { stack: [] },
      { stack: [1] },
      { stack: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] },
      { stack: [9, 2, 8, 1] },
      { stack: [2, 33, 44, 2, -9, -7, -5, -2, -2, -2, 0] },
      { stack: [3, 3, 3, 3, 3, 3] },
      { stack: [0, 0] },
      { stack: [2, 22, 222, 3, 33, 33, 9, 2, 3, 312, -9, -2, 3] },
      { stack: [3, 4, 5, 1, 2, 2, 2, 1, 3, 4, 5, 3, 1, 3, -1, 2, 3] },
    ],
  },
  {
    id: 'next-greater-element',
    name: 'Next Greater Element',
    category: 'Stacks',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a new array\n  containing, at each index, the next element in the input array that\'s greater\n  than the element at that index in the input array.\n</p>\n<p>\n  In other words, your function should return a new array where\n  <span>outputArray[i]</span> is the next element in the input array that\'s\n  greater than <span>inputArray[i]</span>. If there\'s no such next greater\n  element for a particular index, the value at that index in the output array\n  should be <span>-1</span>. For example, given <span>array = [1, 2]</span>,\n  your function should return <span>[2, -1]</span>.\n</p>\n<p>\n  Additionally, your function should treat the input array as a\n  <b>circular</b> array. A circular array wraps around itself as if it were\n  connected end-to-end. So the next index after the last index in a circular\n  array is the first index. This means that, for our problem, given\n  <span>array = [0, 0, 5, 0, 0, 3, 0, 0]</span>, the next greater element after\n  <span>3</span> is <span>5</span>, since the array is circular.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 5, -3, -4, 6, 7, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[5, 6, 6, 6, 7, -1, 5]\n</pre>\n</div>',
    hints: [
      '<p>\n  Solving this problem in <span>O(n^2)</span> time, where <span>n</span> is the\n  length of the array, is straightforward. Can you solve it with a better time\n  complexity?\n</p>\n',
      '\n<p>\n  How can a stack allow you to solve this problem in <span>O(n)</span> time?\n</p>\n',
      "\n<p>\n  There are a couple of ways to solve this problem in linear time with a stack.\n  One approach is to push onto the stack the indices of elements for which you\n  haven't yet found the next greater element. If you go with this index\n  approach, you need to loop through the array twice (since it's circular) and\n  compare the value of the current element in the array to the one represented\n  by the index on top of the stack. If the element on the top of the stack is\n  smaller than the current element, then the current element is next greater\n  element for the top-of-stack element, and you can pop the index off the top of\n  the stack and use it to store the current element in the correct position in\n  your result array. You then continue to pop elements off the top of the stack\n  until the current element is no longer greater than the top-of-stack element.\n  At this point, you add the index of the current element to the top of the\n  stack, and you continue iterating through the array, repeating the same\n  process.\n</p>\n",
      "\n<p>\n  The approach discussed in Hint #3 assumes that you loop through the array from\n  left to right. You could loop through the array backwards using a very similar\n  approach, storing the actual values of elements on the stack rather than their\n  indices. See the Conceptual Overview section of this question's video\n  explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [2, 5, -3, -4, 6, 7, 2],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function nextGreaterElement(array) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.nextGreaterElement = nextGreaterElement;\n',
      solutions: [
        '// O(n) time | O(n) space - where n is the length of the array\nfunction nextGreaterElement(array) {\n  const result = new Array(array.length).fill(-1);\n  const stack = [];\n\n  for (let idx = 0; idx < 2 * array.length; idx++) {\n    const circularIdx = idx % array.length;\n\n    while (stack.length > 0 && array[stack[stack.length - 1]] < array[circularIdx]) {\n      const top = stack.pop();\n      result[top] = array[circularIdx];\n    }\n\n    stack.push(circularIdx);\n  }\n\n  return result;\n}\n\n// Do not edit the line below.\nexports.nextGreaterElement = nextGreaterElement;\n',
        '// O(n) time | O(n) space - where n is the length of the array\nfunction nextGreaterElement(array) {\n  const result = new Array(array.length).fill(-1);\n  const stack = [];\n\n  for (let idx = 2 * array.length - 1; idx > -1; idx--) {\n    const circularIdx = idx % array.length;\n\n    while (stack.length > 0) {\n      if (stack[stack.length - 1] <= array[circularIdx]) {\n        stack.pop();\n      } else {\n        result[circularIdx] = stack[stack.length - 1];\n        break;\n      }\n    }\n\n    stack.push(array[circularIdx]);\n  }\n\n  return result;\n}\n\n// Do not edit the line below.\nexports.nextGreaterElement = nextGreaterElement;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 5, -3, -4, 6, 7, 2];\n  const expected = [5, 6, 6, 6, 7, -1, 5];\n  const actual = program.nextGreaterElement(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 5, -3, -4, 6, 7, 2];\n  const expected = [5, 6, 6, 6, 7, -1, 5];\n  const actual = program.nextGreaterElement(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the array',
    tests: [
      { array: [2, 5, -3, -4, 6, 7, 2] },
      { array: [0, 1, 2, 3, 4] },
      { array: [6, 4, 5, 7, 2, 1, 3] },
      { array: [1, 0, 1, 0, 1, 0, 1] },
      { array: [5, 6, 1, 3, 1, -2, -1, 3, 4, 5] },
      { array: [7, 6, 5, 4, 3, 2, 1] },
      { array: [5, 6, 1, 2, 3, 4] },
      { array: [1, 1, 1, 1, 1, 1, 1, 1] },
      { array: [12] },
      { array: [12, 4] },
      { array: [-9, 0, -5, 1, 3, -2, 18, 2, 5, 18] },
      { array: [2, 6, 7, 2, 2, 2] },
      { array: [1, 2, 3, 4, 1, 2, 3, 4, -8, -7, 6, 2, 17, 2, -8, 9, 0, 2] },
      { array: [-8, -1, -1, -2, -4, -5, -6, 0, -9, -91, -2, 8] },
      { array: [] },
    ],
  },
  {
    id: 'suffix-trie-construction',
    name: 'Suffix Trie Construction',
    category: 'Tries',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a <span>SuffixTrie</span> class for a Suffix-Trie-like data structure.\n  The class should have a <span>root</span> property set to be the root node of\n  the trie and should support:\n</p>\n<ul>\n  <li>\n    Creating the trie from a string; this will be done by calling the\n    <span>populateSuffixTrieFrom</span> method upon class instantiation, which\n    should populate the <span>root</span> of the class.\n  </li>\n  <li>Searching for strings in the trie.</li>\n</ul>\n<p>\n  Note that every string added to the trie should end with the special\n  <span>endSymbol</span> character: <span>"*"</span>.\n</p>\n<p>\n  If you\'re unfamiliar with Suffix Tries, we recommend watching the\n  Conceptual Overview section of this question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input (for creation)</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "babc"\n</pre>\n<h3>Sample Output (for creation)</h3>\n<pre>\n<span class="CodeEditor-promptComment">The structure below is the root of the trie.</span>\n{\n  "c": {"*": true},\n  "b": {\n    "c": {"*": true},\n    "a": {"b": {"c": {"*": true}}},\n  },\n  "a": {"b": {"c": {"*": true}}},\n}\n</pre>\n<h3>\n  Sample Input (for searching in the suffix trie above)\n</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "abc"\n</pre>\n<h3>\n  Sample Output (for searching in the suffix trie above)\n</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      '<p>\nBuilding a suffix-trie-like data structure consists of essentially storing every suffix of a given string in a trie. To do so, iterate through the input string one character at a time and insert every substring starting at each character and ending at the end of the string into the trie.\n</p>\n',
      '\n<p>\nTo insert a string into the trie, start by adding the first character of the string into the root node of the trie and mapping it to an empty hash table if it isn\'t already there. Then, iterate through the rest of the string inserting each of the remaining characters into the previous character\'s corresponding node (or hash table) in the trie, making sure to add an endSymbol "*" at the end.\n</p>\n',
      '\n<p>\nSearching the trie for a specific string should follow a nearly identical logic to the one used to add a string in the trie.\n</p>',
    ],
    customInputVars: [
      { name: 'string', example: 'babc', schema: { type: 'string' } },
      {
        name: 'classMethodsToCall',
        example: [{ arguments: ['abc'], method: 'contains' }],
        schema: {
          description:
            'These methods will be called in the order that they appear in below\non a <span>SuffixTrie</span> built from the <span>string</span> and with their respective arguments.\n',
          items: {
            properties: {
              arguments: {
                items: { type: 'string' },
                maxItems: 1,
                minItems: 1,
                type: 'array',
              },
              method: { enum: ['contains'], type: 'string' },
            },
            required: ['method', 'arguments'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        "// Do not edit the class below except for the\n// populateSuffixTrieFrom and contains methods.\n// Feel free to add new properties and methods\n// to the class.\nclass SuffixTrie {\n  constructor(string) {\n    this.root = {};\n    this.endSymbol = '*';\n    this.populateSuffixTrieFrom(string);\n  }\n\n  populateSuffixTrieFrom(string) {\n    // Write your code here.\n  }\n\n  contains(string) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.SuffixTrie = SuffixTrie;\n",
      solutions: [
        "class SuffixTrie {\n  constructor(string) {\n    this.root = {};\n    this.endSymbol = '*';\n    this.populateSuffixTrieFrom(string);\n  }\n\n  // O(n^2) time | O(n^2) space\n  populateSuffixTrieFrom(string) {\n    for (let i = 0; i < string.length; i++) {\n      this.insertSubstringStartingAt(i, string);\n    }\n  }\n\n  insertSubstringStartingAt(i, string) {\n    let node = this.root;\n    for (let j = i; j < string.length; j++) {\n      const letter = string[j];\n      if (!(letter in node)) node[letter] = {};\n      node = node[letter];\n    }\n    node[this.endSymbol] = true;\n  }\n\n  // O(m) time | O(1) space\n  contains(string) {\n    let node = this.root;\n    for (const letter of string) {\n      if (!(letter in node)) return false;\n      node = node[letter];\n    }\n    return this.endSymbol in node;\n  }\n}\n\nexports.SuffixTrie = SuffixTrie;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const trie = new program.SuffixTrie('babc');\n  const expected = {\n    c: {'*': true},\n    b: {\n      c: {'*': true},\n      a: {b: {c: {'*': true}}},\n    },\n    a: {b: {c: {'*': true}}},\n  };\n  chai.expect(trie.root).to.deep.equal(expected);\n  chai.expect(trie.contains('abc')).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const trie = new program.SuffixTrie('babc');\n  const expected = {\n    c: {'*': true},\n    b: {\n      c: {'*': true},\n      a: {b: {c: {'*': true}}},\n    },\n    a: {b: {c: {'*': true}}},\n  };\n  chai.expect(trie.root).to.deep.equal(expected);\n  chai.expect(trie.contains('abc')).to.deep.equal(true);\n});\n",
    },
    bigO: 'Creation: O(n^2) time | O(n^2) space - where n is the length of the input string\nSearching: O(m) time | O(1) space - where m is the length of the input string',
    tests: [
      {
        classMethodsToCall: [{ arguments: ['abc'], method: 'contains' }],
        string: 'babc',
      },
      {
        classMethodsToCall: [
          { arguments: ['t'], method: 'contains' },
          { arguments: ['st'], method: 'contains' },
          { arguments: ['est'], method: 'contains' },
          { arguments: ['test'], method: 'contains' },
          { arguments: ['tes'], method: 'contains' },
        ],
        string: 'test',
      },
      {
        classMethodsToCall: [
          { arguments: ['e'], method: 'contains' },
          { arguments: ['le'], method: 'contains' },
          { arguments: ['ble'], method: 'contains' },
          { arguments: ['ible'], method: 'contains' },
          { arguments: ['sible'], method: 'contains' },
          { arguments: ['isible'], method: 'contains' },
          { arguments: ['visible'], method: 'contains' },
          { arguments: ['nvisible'], method: 'contains' },
          { arguments: ['invisible'], method: 'contains' },
          { arguments: ['nvisibl'], method: 'contains' },
        ],
        string: 'invisible',
      },
      {
        classMethodsToCall: [
          { arguments: ['9'], method: 'contains' },
          { arguments: ['89'], method: 'contains' },
          { arguments: ['789'], method: 'contains' },
          { arguments: ['6789'], method: 'contains' },
          { arguments: ['56789'], method: 'contains' },
          { arguments: ['456789'], method: 'contains' },
          { arguments: ['3456789'], method: 'contains' },
          { arguments: ['23456789'], method: 'contains' },
          { arguments: ['123456789'], method: 'contains' },
          { arguments: ['45567'], method: 'contains' },
        ],
        string: '1234556789',
      },
      {
        classMethodsToCall: [
          { arguments: ['t'], method: 'contains' },
          { arguments: ['st'], method: 'contains' },
          { arguments: ['est'], method: 'contains' },
          { arguments: ['test'], method: 'contains' },
          { arguments: ['ttest'], method: 'contains' },
          { arguments: ['sttest'], method: 'contains' },
          { arguments: ['esttest'], method: 'contains' },
          { arguments: ['testtest'], method: 'contains' },
          { arguments: ['tt'], method: 'contains' },
        ],
        string: 'testtest',
      },
      {
        classMethodsToCall: [
          { arguments: ['t'], method: 'contains' },
          { arguments: ['tt'], method: 'contains' },
          { arguments: ['ttt'], method: 'contains' },
          { arguments: ['tttt'], method: 'contains' },
          { arguments: ['ttttt'], method: 'contains' },
          { arguments: ['tttttt'], method: 'contains' },
          { arguments: ['ttttttt'], method: 'contains' },
          { arguments: ['tttttttt'], method: 'contains' },
          { arguments: ['ttttttttt'], method: 'contains' },
          { arguments: ['vvv'], method: 'contains' },
        ],
        string: 'ttttttttt',
      },
    ],
  },
  {
    id: 'multi-string-search',
    name: 'Multi String Search',
    category: 'Tries',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a big string and an array of small strings,\n  all of which are smaller in length than the big string. The function should\n  return an array of booleans, where each boolean represents whether the small\n  string at that index in the array of small strings is contained in the big\n  string.\n</p>\n<p>Note that you can\'t use language-built-in string-matching methods.</p>\n<h3>Sample Input #1</h3>\n<pre>\n<span class="CodeEditor-promptParameter">bigString</span> = "this is a big string"\n<span class="CodeEditor-promptParameter">smallStrings</span> = ["this", "yo", "is", "a", "bigger", "string", "kappa"]\n</pre>\n<h3>Sample Output #1</h3>\n<pre>\n[true, false, true, true, false, true, false]\n</pre>\n<h3>Sample Input #2</h3>\n<pre>\n<span class="CodeEditor-promptParameter">bigString</span> = "abcdefghijklmnopqrstuvwxyz"\n<span class="CodeEditor-promptParameter">smallStrings</span> = ["abc", "mnopqr", "wyz", "no", "e", "tuuv"]\n</pre>\n<h3>Sample Output #2</h3>\n<pre>\n[true, true, false, true, true, false]\n</pre>\n</div>',
    hints: [
      "<p>\nA simple way to solve this problem is to iterate through all of the small strings, checking if each of them is contained in the big string by iterating through the big string's characters and comparing them to the given small string's characters with a couple of loops. Is this approach efficient from a time-complexity point of view?\n</p>\n",
      "\n<p>\nTry building a suffix-trie-like data structure containing all of the big string's suffixes. Then, iterate through all of the small strings and check if each of them is contained in the data structure you've created. What are the time-complexity ramifications of this approach?\n</p>\n",
      "\n<p>\nTry building a trie containing all of the small strings. Then, iterate through the big string's characters and check if any part of the big string is a string contained in the trie you've created. Is this approach better than the one described in Hint #2 from a time-complexity point of view?\n</p>",
    ],
    customInputVars: [
      {
        name: 'bigString',
        example: 'this is a big string',
        schema: { type: 'string' },
      },
      {
        name: 'smallStrings',
        example: ['this', 'yo', 'is', 'a', 'bigger', 'string', 'kappa'],
        schema: { items: { type: 'string' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function multiStringSearch(bigString, smallStrings) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.multiStringSearch = multiStringSearch;\n',
      solutions: [
        '// O(bns) time | O(n) space\nfunction multiStringSearch(bigString, smallStrings) {\n  return smallStrings.map(smallString => isInBigString(bigString, smallString));\n}\n\nfunction isInBigString(bigString, smallString) {\n  for (let i = 0; i < bigString.length; i++) {\n    if (i + smallString.length > bigString.length) break;\n    if (isInBigStringHelper(bigString, smallString, i)) return true;\n  }\n  return false;\n}\n\nfunction isInBigStringHelper(bigString, smallString, startIdx) {\n  let leftBigIdx = startIdx;\n  let rightBigIdx = startIdx + smallString.length - 1;\n  let leftSmallIdx = 0;\n  let rightSmallIdx = smallString.length - 1;\n  while (leftBigIdx <= rightBigIdx) {\n    if (\n      bigString[leftBigIdx] != smallString[leftSmallIdx] ||\n      bigString[rightBigIdx] != smallString[rightSmallIdx]\n    ) {\n      return false;\n    }\n    leftBigIdx++;\n    rightBigIdx--;\n    leftSmallIdx++;\n    rightSmallIdx--;\n  }\n  return true;\n}\n\nexports.multiStringSearch = multiStringSearch;\n',
        '// O(b^2 + ns) time | O(b^2 + n) space\nfunction multiStringSearch(bigString, smallStrings) {\n  const modifiedSuffixTrie = new ModifiedSuffixTrie(bigString);\n  return smallStrings.map(string => modifiedSuffixTrie.contains(string));\n}\n\nclass ModifiedSuffixTrie {\n  constructor(string) {\n    this.root = {};\n    this.populateModifiedSuffixTrieFrom(string);\n  }\n\n  populateModifiedSuffixTrieFrom(string) {\n    for (let i = 0; i < string.length; i++) {\n      this.insertSubstringStartingAt(i, string);\n    }\n  }\n\n  insertSubstringStartingAt(i, string) {\n    let node = this.root;\n    for (let j = i; j < string.length; j++) {\n      const letter = string[j];\n      if (!(letter in node)) node[letter] = {};\n      node = node[letter];\n    }\n  }\n\n  contains(string) {\n    let node = this.root;\n    for (const letter of string) {\n      if (!(letter in node)) return false;\n      node = node[letter];\n    }\n    return true;\n  }\n}\n\nexports.multiStringSearch = multiStringSearch;\n',
        "// O(ns + bs) time | O(ns) space\nfunction multiStringSearch(bigString, smallStrings) {\n  const trie = new Trie();\n  for (const string of smallStrings) {\n    trie.insert(string);\n  }\n  const containedStrings = {};\n  for (let i = 0; i < bigString.length; i++) {\n    findSmallStringsIn(bigString, i, trie, containedStrings);\n  }\n  return smallStrings.map(string => string in containedStrings);\n}\n\nfunction findSmallStringsIn(string, startIdx, trie, containedStrings) {\n  let currentNode = trie.root;\n  for (let i = startIdx; i < string.length; i++) {\n    const currentChar = string[i];\n    if (!(currentChar in currentNode)) break;\n    currentNode = currentNode[currentChar];\n    if (trie.endSymbol in currentNode) containedStrings[currentNode[trie.endSymbol]] = true;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = {};\n    this.endSymbol = '*';\n  }\n\n  insert(string) {\n    let current = this.root;\n    for (let i = 0; i < string.length; i++) {\n      if (!(string[i] in current)) {\n        current[string[i]] = {};\n      }\n      current = current[string[i]];\n    }\n    current[this.endSymbol] = string;\n  }\n}\n\nexports.multiStringSearch = multiStringSearch;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.multiStringSearch('this is a big string', [\n        'this',\n        'yo',\n        'is',\n        'a',\n        'bigger',\n        'string',\n        'kappa',\n      ]),\n    )\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.multiStringSearch('this is a big string', [\n        'this',\n        'yo',\n        'is',\n        'a',\n        'bigger',\n        'string',\n        'kappa',\n      ]),\n    )\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n",
    },
    bigO: 'O(ns + bs) time | O(ns) space - where n is the number of small strings, s is the length of longest small string, and b is the length of the big string',
    tests: [
      {
        bigString: 'this is a big string',
        smallStrings: ['this', 'yo', 'is', 'a', 'bigger', 'string', 'kappa'],
      },
      {
        bigString: 'abcdefghijklmnopqrstuvwxyz',
        smallStrings: ['abc', 'mnopqr', 'wyz', 'no', 'e', 'tuuv'],
      },
      {
        bigString: 'abcdefghijklmnopqrstuvwxyz',
        smallStrings: [
          'abcdefghijklmnopqrstuvwxyz',
          'abc',
          'j',
          'mnopqr',
          'pqrstuvwxyz',
          'xyzz',
          'defh',
        ],
      },
      {
        bigString: 'hj!)!%Hj1jh8f1985n!)51',
        smallStrings: ['%Hj7', '8f198', '!)5', '!)!', '!!', 'jh81', 'j181hf'],
      },
      {
        bigString: 'Mary goes to the shopping center every week.',
        smallStrings: [
          'to',
          'Mary',
          'centers',
          'shop',
          'shopping',
          'string',
          'kappa',
        ],
      },
      {
        bigString: 'adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda',
        smallStrings: ['abcd', 'acbd', 'adbc', 'dabc', 'cbda', 'cabd', 'cdab'],
      },
      {
        bigString: 'test testing testings tests testers test-takers',
        smallStrings: [
          'tests',
          'testatk',
          'testiing',
          'trsatii',
          'test-taker',
          'test',
        ],
      },
      {
        bigString:
          'ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd',
        smallStrings: [
          'abc',
          'akwbc',
          'awbc',
          'abafac',
          'ajjfbc',
          'abac',
          'jadfl',
        ],
      },
      {
        bigString:
          'Is this particular test going to pass or is it going to fail? That is the question.',
        smallStrings: [
          'that',
          'the',
          'questions',
          'goes',
          'mountain',
          'passes',
          'passed',
          'going',
          'is',
        ],
      },
      {
        bigString: 'Everything in this test should fail.',
        smallStrings: [
          'everything',
          'inn',
          'that',
          'testers',
          'shall',
          'failure',
        ],
      },
      {
        bigString: "this ain't a big string",
        smallStrings: ['this', 'is', 'yo', 'a', 'bigger'],
      },
      { bigString: 'bbbabb', smallStrings: ['bbabb'] },
    ],
  },
  {
    id: 'linked-list-construction',
    name: 'Linked List Construction',
    category: 'Linked Lists',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a <span>DoublyLinkedList</span> class that has a <span>head</span> and a\n  <span>tail</span>, both of which point to either a linked list\n  <span>Node</span> or <span>None</span> / <span>null</span>. The class should\n  support:\n</p>\n<ul>\n  <li>\n    Setting the head and tail of the linked list.\n  </li>\n  <li>\n    Inserting nodes before and after other nodes as well as at given positions\n    (the position of the head node is <span>1</span>).\n  </li>\n  <li>Removing given nodes and removing nodes with given values.</li>\n  <li>Searching for nodes with given values.</li>\n</ul>\n<p>\n  Note that the <span>setHead</span>, <span>setTail</span>,\n  <span>insertBefore</span>, <span>insertAfter</span>,\n  <span>insertAtPosition</span>, and <span>remove</span> methods all take in\n  actual <span>Node</span>s as input parametersnot integers (except for\n  <span>insertAtPosition</span>, which also takes in an integer representing the\n  position); this means that you don\'t need to create any new <span>Node</span>s\n  in these methods. The input nodes can be either stand-alone nodes or nodes\n  that are already in the linked list. If they\'re nodes that are already in the\n  linked list, the methods will effectively be <i>moving</i> the nodes within\n  the linked list. You won\'t be told if the input nodes are already in the\n  linked list, so your code will have to defensively handle this scenario.\n</p>\n<p>\n  If you\'re doing this problem in an untyped language like Python or JavaScript,\n  you may want to look at the various function signatures in a typed language\n  like Java or TypeScript to get a better idea of what each input parameter is.\n</p>\n<p>\n  Each <span>Node</span> has an integer <span>value</span> as well as a\n  <span>prev</span> node and a <span>next</span> node, both of which can point\n  to either another node or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class="CodeEditor-promptComment">// Assume the following linked list has already been created:</span>\n1 <-> 2 <-> 3 <-> 4 <-> 5\n<span class="CodeEditor-promptComment">// Assume that we also have the following stand-alone nodes:</span>\n3, 3, 6\n<span class="CodeEditor-promptParameter">setHead</span>(4): 4 <-> 1 <-> 2 <-> 3 <-> 5 <span class="CodeEditor-promptComment">// set the existing node with value 4 as the head</span>\n<span class="CodeEditor-promptParameter">setTail</span>(6): 4 <-> 1 <-> 2 <-> 3 <-> 5 <-> 6 <span class="CodeEditor-promptComment">// set the stand-alone node with value 6 as the tail</span>\n<span class="CodeEditor-promptParameter">insertBefore</span>(6, 3): 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <span class="CodeEditor-promptComment">// move the existing node with value 3 before the existing node with value 6</span>\n<span class="CodeEditor-promptParameter">insertAfter</span>(6, 3): 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <-> 3 <span class="CodeEditor-promptComment">// insert a stand-alone node with value 3 after the existing node with value 6</span>\n<span class="CodeEditor-promptParameter">insertAtPosition</span>(1, 3): 3 <-> 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <-> 3 <span class="CodeEditor-promptComment">// insert a stand-alone node with value 3 in position 1</span>\n<span class="CodeEditor-promptParameter">removeNodesWithValue</span>(3): 4 <-> 1 <-> 2 <-> 5 <-> 6 <span class="CodeEditor-promptComment">// remove all nodes with value 3</span>\n<span class="CodeEditor-promptParameter">remove</span>(2): 4 <-> 1 <-> 5 <-> 6 <span class="CodeEditor-promptComment">// remove the existing node with value 2</span>\n<span class="CodeEditor-promptParameter">containsNodeWithValue</span>(5): true\n</pre>\n</div>',
    hints: [
      "<p>\nWhen dealing with linked lists, it's very important to keep track of pointers on nodes (i.e., the \"next\" and \"prev\" properties on the nodes). For instance, if you're inserting a node in a linked list, but that node is already located somewhere else in the linked list (in other words, if you're moving a node), it's crucial to completely update the pointers of the adjacent nodes of the node being moved before updating the node's own pointers. The order in which you update nodes' pointers will make or break your algorithm.\n</p>\n",
      '\n<p>\nRealize that the insertBefore() and insertAfter() methods can be used to implement the setHead(), setTail(), and insertAtPosition() methods; making the insertBefore() and insertAfter() methods as robust as possible will simplify your code for the other methods. Make sure to take care of edge cases involving inserting nodes before the head of the linked list or inserting nodes after the tail of the linked list.\n</p>\n',
      '\n<p>\nSimilar to Hint #2, realize that the remove() method can be used to implement the removeNodesWithValue() method as well as parts of the insertBefore() and insertAfter() methods; make sure that the remove() method handles edge cases regarding the head and the tail.\n</p>',
    ],
    customInputVars: [
      {
        name: 'nodes',
        example: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '3-2', next: null, prev: null, value: 3 },
          { id: '3-3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
          { id: '5', next: null, prev: null, value: 5 },
          { id: '6', next: null, prev: null, value: 6 },
        ],
        schema: {
          description:
            "You'll be able to reference these nodes by their <span>id</span>\nin the <span>classMethodsToCall</span>.\n",
          items: {
            properties: {
              id: { type: 'string' },
              next: { type: 'null' },
              prev: { type: 'null' },
              value: { type: 'integer' },
            },
            required: ['id', 'value', 'prev', 'next'],
            type: 'object',
          },
          type: 'array',
        },
      },
      {
        name: 'classMethodsToCall',
        example: [
          { arguments: ['5'], method: 'setHead' },
          { arguments: ['4'], method: 'setHead' },
          { arguments: ['3'], method: 'setHead' },
          { arguments: ['2'], method: 'setHead' },
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['4'], method: 'setHead' },
          { arguments: ['6'], method: 'setTail' },
          { arguments: ['6', '3'], method: 'insertBefore' },
          { arguments: ['6', '3-2'], method: 'insertAfter' },
          { arguments: [1, '3-3'], method: 'insertAtPosition' },
          { arguments: [3], method: 'removeNodesWithValue' },
          { arguments: ['2'], method: 'remove' },
          { arguments: [5], method: 'containsNodeWithValue' },
        ],
        schema: {
          description:
            'These methods will be called in the order that they appear in below\non a <span>DoublyLinkedList</span> and with their respective arguments.\nFor methods that take in actual <span>Node</span>s as parameters, you can\ncreate <span>nodes</span> below and reference them by their <span>id</span>.\n',
          items: {
            properties: {
              arguments: { maxItems: 2, type: 'array' },
              method: {
                enum: [
                  'setHead',
                  'setTail',
                  'insertBefore',
                  'insertAfter',
                  'insertAtPosition',
                  'removeNodesWithValue',
                  'remove',
                  'containsNodeWithValue',
                ],
                type: 'string',
              },
            },
            required: ['method', 'arguments'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n// Feel free to add new properties and methods to the class.\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHead(node) {\n    // Write your code here.\n  }\n\n  setTail(node) {\n    // Write your code here.\n  }\n\n  insertBefore(node, nodeToInsert) {\n    // Write your code here.\n  }\n\n  insertAfter(node, nodeToInsert) {\n    // Write your code here.\n  }\n\n  insertAtPosition(position, nodeToInsert) {\n    // Write your code here.\n  }\n\n  removeNodesWithValue(value) {\n    // Write your code here.\n  }\n\n  remove(node) {\n    // Write your code here.\n  }\n\n  containsNodeWithValue(value) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the lines below.\nexports.Node = Node;\nexports.DoublyLinkedList = DoublyLinkedList;\n',
      solutions: [
        'class Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // O(1) time | O(1) space\n  setHead(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      return;\n    }\n    this.insertBefore(this.head, node);\n  }\n\n  // O(1) time | O(1) space\n  setTail(node) {\n    if (this.tail === null) {\n      this.setHead(node);\n      return;\n    }\n    this.insertAfter(this.tail, node);\n  }\n\n  // O(1) time | O(1) space\n  insertBefore(node, nodeToInsert) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node.prev;\n    nodeToInsert.next = node;\n    if (node.prev === null) {\n      this.head = nodeToInsert;\n    } else {\n      node.prev.next = nodeToInsert;\n    }\n    node.prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  insertAfter(node, nodeToInsert) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node;\n    nodeToInsert.next = node.next;\n    if (node.next === null) {\n      this.tail = nodeToInsert;\n    } else {\n      node.next.prev = nodeToInsert;\n    }\n    node.next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  insertAtPosition(position, nodeToInsert) {\n    if (position === 1) {\n      this.setHead(nodeToInsert);\n      return;\n    }\n    let node = this.head;\n    let currentPosition = 1;\n    while (node !== null && currentPosition++ !== position) node = node.next;\n    if (node !== null) {\n      this.insertBefore(node, nodeToInsert);\n    } else {\n      this.setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  removeNodesWithValue(value) {\n    let node = this.head;\n    while (node !== null) {\n      const nodeToRemove = node;\n      node = node.next;\n      if (nodeToRemove.value === value) this.remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  remove(node) {\n    if (node === this.head) this.head = this.head.next;\n    if (node === this.tail) this.tail = this.tail.prev;\n    this.removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  containsNodeWithValue(value) {\n    let node = this.head;\n    while (node !== null && node.value !== value) node = node.next;\n    return node !== null;\n  }\n\n  removeNodeBindings(node) {\n    if (node.prev !== null) node.prev.next = node.next;\n    if (node.next !== null) node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n  }\n}\n\nexports.Node = Node;\nexports.DoublyLinkedList = DoublyLinkedList;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass TestNode {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne, nodeTwo) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass TestNode {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne, nodeTwo) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
    },
    bigO: 'setHead, setTail, insertBefore, insertAfter, and remove: O(1) time | O(1) space\ninsertAtPosition: O(p) time | O(1) space - where p is input position\nremoveNodesWithValue, containsNodeWithValue: O(n) time | O(1) space - where n is the number of nodes in the linked list',
    tests: [
      {
        classMethodsToCall: [
          { arguments: ['5'], method: 'setHead' },
          { arguments: ['4'], method: 'setHead' },
          { arguments: ['3'], method: 'setHead' },
          { arguments: ['2'], method: 'setHead' },
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['4'], method: 'setHead' },
          { arguments: ['6'], method: 'setTail' },
          { arguments: ['6', '3'], method: 'insertBefore' },
          { arguments: ['6', '3-2'], method: 'insertAfter' },
          { arguments: [1, '3-3'], method: 'insertAtPosition' },
          { arguments: [3], method: 'removeNodesWithValue' },
          { arguments: ['2'], method: 'remove' },
          { arguments: [5], method: 'containsNodeWithValue' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '3-2', next: null, prev: null, value: 3 },
          { id: '3-3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
          { id: '5', next: null, prev: null, value: 5 },
          { id: '6', next: null, prev: null, value: 6 },
        ],
      },
      {
        classMethodsToCall: [{ arguments: ['1'], method: 'setHead' }],
        nodes: [{ id: '1', next: null, prev: null, value: 1 }],
      },
      {
        classMethodsToCall: [{ arguments: ['1'], method: 'setTail' }],
        nodes: [{ id: '1', next: null, prev: null, value: 1 }],
      },
      {
        classMethodsToCall: [
          { arguments: [1, '1'], method: 'insertAtPosition' },
        ],
        nodes: [{ id: '1', next: null, prev: null, value: 1 }],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['2'], method: 'setTail' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['2'], method: 'setHead' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertBefore' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '3'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertAfter' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setTail' },
          { arguments: ['1', '2'], method: 'insertBefore' },
          { arguments: ['2', '3'], method: 'insertBefore' },
          { arguments: ['3', '4'], method: 'insertBefore' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '3'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertAfter' },
          { arguments: ['1'], method: 'setTail' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setTail' },
          { arguments: ['1', '2'], method: 'insertBefore' },
          { arguments: ['2', '3'], method: 'insertBefore' },
          { arguments: ['3', '4'], method: 'insertBefore' },
          { arguments: ['1'], method: 'setHead' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '3'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertAfter' },
          { arguments: ['2', '1'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertBefore' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '3'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertAfter' },
          { arguments: ['4', '5'], method: 'insertAfter' },
          { arguments: ['5', '6'], method: 'insertAfter' },
          { arguments: ['6', '7'], method: 'insertAfter' },
          { arguments: [7, '1'], method: 'insertAtPosition' },
          { arguments: [1, '1'], method: 'insertAtPosition' },
          { arguments: [2, '1'], method: 'insertAtPosition' },
          { arguments: [3, '1'], method: 'insertAtPosition' },
          { arguments: [4, '1'], method: 'insertAtPosition' },
          { arguments: [5, '1'], method: 'insertAtPosition' },
          { arguments: [6, '1'], method: 'insertAtPosition' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
          { id: '5', next: null, prev: null, value: 5 },
          { id: '6', next: null, prev: null, value: 6 },
          { id: '7', next: null, prev: null, value: 7 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1'], method: 'remove' },
        ],
        nodes: [{ id: '1', next: null, prev: null, value: 1 }],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: [1], method: 'removeNodesWithValue' },
        ],
        nodes: [{ id: '1', next: null, prev: null, value: 1 }],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '3'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertAfter' },
          { arguments: ['1'], method: 'remove' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '3'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertAfter' },
          { arguments: ['4'], method: 'remove' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '3'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertAfter' },
          { arguments: ['2'], method: 'remove' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '1-2'], method: 'insertAfter' },
          { arguments: ['1-2', '1-3'], method: 'insertAfter' },
          { arguments: ['1-3', '1-4'], method: 'insertAfter' },
          { arguments: [1], method: 'removeNodesWithValue' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '1-2', next: null, prev: null, value: 1 },
          { id: '1-3', next: null, prev: null, value: 1 },
          { id: '1-4', next: null, prev: null, value: 1 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '1-2'], method: 'insertAfter' },
          { arguments: ['1-2', '3'], method: 'insertAfter' },
          { arguments: ['3', '1-3'], method: 'insertAfter' },
          { arguments: ['1-3', '4'], method: 'insertAfter' },
          { arguments: [1], method: 'removeNodesWithValue' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '1-2', next: null, prev: null, value: 1 },
          { id: '1-3', next: null, prev: null, value: 1 },
          { id: '1-4', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: ['1'], method: 'setHead' },
          { arguments: ['1', '2'], method: 'insertAfter' },
          { arguments: ['2', '3'], method: 'insertAfter' },
          { arguments: ['3', '4'], method: 'insertAfter' },
          { arguments: [1], method: 'containsNodeWithValue' },
          { arguments: [2], method: 'containsNodeWithValue' },
          { arguments: [3], method: 'containsNodeWithValue' },
          { arguments: [4], method: 'containsNodeWithValue' },
          { arguments: [5], method: 'containsNodeWithValue' },
        ],
        nodes: [
          { id: '1', next: null, prev: null, value: 1 },
          { id: '2', next: null, prev: null, value: 2 },
          { id: '3', next: null, prev: null, value: 3 },
          { id: '4', next: null, prev: null, value: 4 },
        ],
      },
    ],
  },
  {
    id: 'remove-kth-node-from-end',
    name: 'Remove Kth Node From End',
    category: 'Linked Lists',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the head of a Singly Linked List and an integer\n  <span>k</span> and removes the kth node from the end of the list.\n</p>\n<p>\n  The removal should be done in place, meaning that the original data structure\n  should be mutated (no new structure should be created).\n</p>\n<p>\n  Furthermore, the input head of the linked list should remain the head of the\n  linked list after the removal is done, even if the head is the node that\'s\n  supposed to be removed. In other words, if the head is the node that\'s\n  supposed to be removed, your function should simply mutate its\n  <span>value</span> and <span>next</span> pointer.\n</p>\n<p>Note that your function doesn\'t need to return anything.</p>\n<p>\n  You can assume that the input Linked List will always have at least two nodes\n  and, more specifically, at least k nodes.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">head</span> = 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 <span class="CodeEditor-promptComment">// the head node with value 0</span>\n<span class="CodeEditor-promptParameter">k</span> = 4\n</pre>\n<h3>Sample Output</h3>\n<pre>\n<span class="CodeEditor-promptComment">// No output required.</span>\n<span class="CodeEditor-promptComment">// The 4th node from the end of the list (the node with value 6) is removed.</span>\n0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 7 -> 8 -> 9\n</pre>\n</div>',
    hints: [
      "<p>\nSince you are given a Singly Linked List, you do not have access to any of the list's nodes' previous nodes. Thus, traversing the entire list and then counting k nodes back isn't an option. Is there a way for you to traverse the entire list and to know which node is the kth node from the end by the time you reach the final node in the list?\n</p>\n",
      '\n<p>\nCan you accomplish the task mentioned in Hint #1 by traversing the list all the while keeping track of two nodes at a time. How could this work?\n</p>\n',
      '\n<p>\nInitialize two variables pointing to the first node in the list. Traverse k nodes in the list, updating the second variable at every node (that is, take k steps with the second variable). Then, traverse the remainder of the list, this time updating both the second and the first variables (that is take as many steps with the first variable as the number of steps between the kth node from the start and the end of the list). Once you reach the end of the list, the first variable should point to the kth node from the end.\n</p>',
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
      { name: 'k', example: 4, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction removeKthNodeFromEnd(head, k) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.removeKthNodeFromEnd = removeKthNodeFromEnd;\n',
      solutions: [
        'class LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space\nfunction removeKthNodeFromEnd(head, k) {\n  let counter = 1;\n  let first = head;\n  let second = head;\n  while (counter <= k) {\n    second = second.next;\n    counter++;\n  }\n  if (second === null) {\n    head.value = head.next.value;\n    head.next = head.next.next;\n    return;\n  }\n  while (second.next !== null) {\n    second = second.next;\n    first = first.next;\n  }\n  first.next = first.next.next;\n}\n\nexports.LinkedList = LinkedList;\nexports.removeKthNodeFromEnd = removeKthNodeFromEnd;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  const expected = new LinkedList(0).addMany([1, 2, 3, 4, 5, 7, 8, 9]);\n  program.removeKthNodeFromEnd(test, 4);\n  chai.expect(test.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  const expected = new LinkedList(0).addMany([1, 2, 3, 4, 5, 7, 8, 9]);\n  program.removeKthNodeFromEnd(test, 4);\n  chai.expect(test.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Linked List',
    tests: [
      {
        k: 4,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 1,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 2,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 3,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 5,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 6,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 7,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 8,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 9,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: 10,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
    ],
  },
  {
    id: 'find-loop',
    name: 'Find Loop',
    category: 'Linked Lists',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the head of a Singly Linked List that contains\n  a loop (in other words, the list\'s tail node points to some node in the list\n  instead of <span>None</span> / <span>null</span>). The function should return\n  the node (the actual node--not just its value) from which the loop originates\n  in constant space.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">head</span> = 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 <span class="CodeEditor-promptComment">// the head node with value 0</span>\n                           ^         v\n                           9 <- 8 <- 7\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 -> 5 -> 6 <span class="CodeEditor-promptComment">// the node with value 4</span>\n^         v\n9 <- 8 <- 7\n</pre>\n</div>',
    hints: [
      '<p>\nTry traversing the linked list with two pointers, one iterating through every single node in the list and another iterating through every other node in the list (skipping a node every time). Eventually, both pointers will point to the same node since there is a loop in the list and since one pointer is moving faster than the other. Stop once the pointers overlap each other. How can you find the origin of the loop from here?\n</p>\n',
      '\n<p>\nCan you come up with a mathematical relation between the respective distances traveled by each pointer? How far will the first pointer have traveled when the pointers overlap? What about the second pointer? How can this relation then help you find the actual origin of the loop in the list?\n</p>\n',
      '\n<p>\nLet D be the distance between the start of the linked list and the origin of the loop in the list. Let P be distance between the origin of the loop and the node N where the first and second pointers overlap (going in the primary direction of the list). By the time the pointers reach N, the first pointer will have traveled a distance of length D + P, and the second pointer will have traveled a distance of length 2D + 2P, since it will have traveled twice as much as the first pointer. Thus, the distance between N and the origin of the loop (going in the primary direction of the list) can be arithmetically deduced to be 2D + 2P - D - 2P = D. With both pointers D length away from the origin of the loop, how can you find the origin?\n</p>',
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '4', value: 9 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction findLoop(head) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.findLoop = findLoop;\n',
      solutions: [
        'class LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space\nfunction findLoop(head) {\n  let first = head.next;\n  let second = head.next.next;\n  while (first !== second) {\n    first = first.next;\n    second = second.next.next;\n  }\n  first = head;\n  while (first !== second) {\n    first = first.next;\n    second = second.next;\n  }\n  return first;\n}\n\nexports.LinkedList = LinkedList;\nexports.findLoop = findLoop;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNthNode(n) {\n    let counter = 1;\n    let current = this;\n    while (counter < n) {\n      current = current.next;\n      counter++;\n    }\n    return current;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  test.getNthNode(10).next = test.getNthNode(5);\n  chai.expect(program.findLoop(test)).to.deep.equal(test.getNthNode(5));\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNthNode(n) {\n    let counter = 1;\n    let current = this;\n    while (counter < n) {\n      current = current.next;\n      counter++;\n    }\n    return current;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n  test.getNthNode(10).next = test.getNthNode(5);\n  chai.expect(program.findLoop(test)).to.deep.equal(test.getNthNode(5));\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Linked List',
    tests: [
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '4', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '0', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '1', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '2', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '3', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '5', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '6', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '7', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '8', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '9', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 5 },
            { id: '1', next: '2', value: 4 },
            { id: '2', next: '3', value: 3 },
            { id: '3', next: '2', value: 2 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '2-2', value: 6 },
            { id: '2-2', next: '7', value: 2 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '4', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '2-2', value: 6 },
            { id: '2-2', next: '7', value: 2 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '2-2', value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '0-2', value: 0 },
            { id: '0-2', next: '0-3', value: 0 },
            { id: '0-3', next: '0-4', value: 0 },
            { id: '0-4', next: '0-5', value: 0 },
            { id: '0-5', next: '0-6', value: 0 },
            { id: '0-6', next: '0-7', value: 0 },
            { id: '0-7', next: '0-8', value: 0 },
            { id: '0-8', next: '0-9', value: 0 },
            { id: '0-9', next: '0-7', value: 0 },
          ],
        },
      },
    ],
  },
  {
    id: 'lru-cache',
    name: 'LRU Cache',
    category: 'Linked Lists',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Implement an <span>LRUCache</span> class for a Least Recently Used (LRU)\n  cache. The class should support:\n</p>\n<ul>\n  <li>\n    Inserting key-value pairs with the <span>insertKeyValuePair</span> method.\n  </li>\n  <li>\n    Retrieving a key\'s value with the <span>getValueFromKey</span> method.\n  </li>\n  <li>\n    Retrieving the most recently used (the most recently inserted or\n    retrieved) key with the\n    <span>getMostRecentKey</span> method.\n  </li>\n</ul>\n<p>\n  Each of these methods should run in constant time.\n</p>\n<p>\n  Additionally, the <span>LRUCache</span> class should store a\n  <span>maxSize</span> property set to the size of the cache, which is passed in\n  as an argument during instantiation. This size represents the maximum number\n  of key-value pairs that the cache can store at once. If a key-value pair is\n  inserted in the cache when it has reached maximum capacity, the least recently\n  used key-value pair should be evicted from the cache and no longer\n  retrievable; the newly added key-value pair should effectively replace it.\n</p>\n<p>\n  Note that inserting a key-value pair with an already existing key should\n  simply replace the key\'s value in the cache with the new value and shouldn\'t\n  evict a key-value pair if the cache is full. Lastly, attempting to retrieve a\n  value from a key that isn\'t in the cache should return <span>None</span> /\n  <span>null</span>.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class="CodeEditor-promptComment">// All operations below are performed sequentially.</span>\n<span class="CodeEditor-promptParameter">LRUCache</span>(3): - <span class="CodeEditor-promptComment">// instantiate an LRUCache of size 3</span>\n<span class="CodeEditor-promptParameter">insertKeyValuePair</span>("b", 2): -\n<span class="CodeEditor-promptParameter">insertKeyValuePair</span>("a", 1): -\n<span class="CodeEditor-promptParameter">insertKeyValuePair</span>("c", 3): -\n<span class="CodeEditor-promptParameter">getMostRecentKey</span>(): "c" <span class="CodeEditor-promptComment">// "c" was the most recently inserted key</span>\n<span class="CodeEditor-promptParameter">getValueFromKey</span>("a"): 1\n<span class="CodeEditor-promptParameter">getMostRecentKey</span>(): "a" <span class="CodeEditor-promptComment">// "a" was the most recently retrieved key</span>\n<span class="CodeEditor-promptParameter">insertKeyValuePair</span>("d", 4): - <span class="CodeEditor-promptComment">// the cache had 3 entries; the least recently used one is evicted</span>\n<span class="CodeEditor-promptParameter">getValueFromKey</span>("b"): None <span class="CodeEditor-promptComment">// "b" was evicted in the previous operation</span>\n<span class="CodeEditor-promptParameter">insertKeyValuePair</span>("a", 5): - <span class="CodeEditor-promptComment">// "a" already exists in the cache so its value just gets replaced</span>\n<span class="CodeEditor-promptParameter">getValueFromKey</span>("a"): 5\n</pre>\n</div>',
    hints: [
      "<p>\nWhat data structure could allow you to insert, retrieve, and evict resources as fast as possible, all the while keeping track of the least recently accessed resource - essentially keeping track of the order of the resources? A hash table would allow you to insert and retrieve resources fast, but it wouldn't allow you to keep track of their order. An array would let you keep track of their order, but it wouldn't let you access elements fast; it also wouldn't allow you to move an element from one position to another in constant time, which you would need to do to make a newly-accessed key / value pair the most recent one upon retrieval of a key's value. A linked list would allow you to keep track of elements' order and to move them seamlessly (if you knew their position), but it wouldn't allow you to access them easily without knowing their position beforehand. Could a heap help? What about a BST or a trie? Would any other data structures work?\n</p>\n",
      "\n<p>\nCould you use multiple data structures to make your LRU Cache's functionality fast and efficient? Could you store keys in one data structure, for instance, and values in an auxiliary data structure? What should these data structures be in order for all of the LRU Cache's methods to run in constant time?\n</p>\n",
      "\n<p>\nTry storing keys in a hash table and mapping them to nodes in a doubly linked list containing the keys' corresponding values (perhaps the nodes would also have to store the keys themselves). With these two data structures, you could access any key / value pair very easily via the hash table, and you could also effortlessly move nodes in the linked list so as to keep track of the most recent and least recent key / value pairs. The linked list would also allow you to keep track of the entire order of the key / value pairs, thus allowing you to perpetually update the least recent key / value pairs after evictions.\n</p>",
    ],
    customInputVars: [
      { name: 'maxSize', example: 3, schema: { minimum: 0, type: 'integer' } },
      {
        name: 'classMethodsToCall',
        example: [
          { arguments: ['b', 2], method: 'insertKeyValuePair' },
          { arguments: ['a', 1], method: 'insertKeyValuePair' },
          { arguments: ['c', 3], method: 'insertKeyValuePair' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['d', 4], method: 'insertKeyValuePair' },
          { arguments: ['b'], method: 'getValueFromKey' },
          { arguments: ['a', 5], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
        ],
        schema: {
          description:
            'These methods will be called in the order that they appear in below\non an <span>LRUCache</span> of size <span>maxSize</span> and with their respective arguments.\n',
          items: {
            properties: {
              arguments: { maxItems: 2, type: 'array' },
              method: {
                enum: [
                  'getMostRecentKey',
                  'getValueFromKey',
                  'insertKeyValuePair',
                ],
                type: 'string',
              },
            },
            required: ['method', 'arguments'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Do not edit the class below except for the insertKeyValuePair,\n// getValueFromKey, and getMostRecentKey methods. Feel free\n// to add new properties and methods to the class.\nclass LRUCache {\n  constructor(maxSize) {\n    this.maxSize = maxSize || 1;\n  }\n\n  insertKeyValuePair(key, value) {\n    // Write your code here.\n  }\n\n  getValueFromKey(key) {\n    // Write your code here.\n  }\n\n  getMostRecentKey() {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.LRUCache = LRUCache;\n',
      solutions: [
        'class LRUCache {\n  constructor(maxSize) {\n    this.cache = {};\n    this.maxSize = maxSize || 1;\n    this.currentSize = 0;\n    this.listOfMostRecent = new DoublyLinkedList();\n  }\n\n  // O(1) time | O(1) space\n  insertKeyValuePair(key, value) {\n    if (!(key in this.cache)) {\n      if (this.currentSize === this.maxSize) {\n        this.evictLeastRecent();\n      } else {\n        this.currentSize++;\n      }\n      this.cache[key] = new DoublyLinkedListNode(key, value);\n    } else {\n      this.replaceKey(key, value);\n    }\n    this.updateMostRecent(this.cache[key]);\n  }\n\n  // O(1) time | O(1) space\n  getValueFromKey(key) {\n    if (!(key in this.cache)) return null;\n    this.updateMostRecent(this.cache[key]);\n    return this.cache[key].value;\n  }\n\n  // O(1) time | O(1) space\n  getMostRecentKey() {\n    if (!this.listOfMostRecent.head) return;\n    return this.listOfMostRecent.head.key;\n  }\n\n  evictLeastRecent() {\n    const keyToRemove = this.listOfMostRecent.tail.key;\n    this.listOfMostRecent.removeTail();\n    delete this.cache[keyToRemove];\n  }\n\n  updateMostRecent(node) {\n    this.listOfMostRecent.setHeadTo(node);\n  }\n\n  replaceKey(key, value) {\n    if (!(key in this.cache)) {\n      throw new Error("The provided key isn\'t in the cache!");\n    }\n    this.cache[key].value = value;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHeadTo(node) {\n    if (this.head === node) {\n      return;\n    } else if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n    } else if (this.head === this.tail) {\n      this.tail.prev = node;\n      this.head = node;\n      this.head.next = this.tail;\n    } else {\n      if (this.tail === node) this.removeTail();\n      node.removeBindings();\n      this.head.prev = node;\n      node.next = this.head;\n      this.head = node;\n    }\n  }\n\n  removeTail() {\n    if (this.tail === null) return;\n    if (this.tail === this.head) {\n      this.head = null;\n      this.tail = null;\n      return;\n    }\n    this.tail = this.tail.prev;\n    this.tail.next = null;\n  }\n}\n\nclass DoublyLinkedListNode {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n\n  removeBindings() {\n    if (this.prev !== null) {\n      this.prev.next = this.next;\n    }\n    if (this.next !== null) {\n      this.next.prev = this.prev;\n    }\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nexports.LRUCache = LRUCache;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const lruCache = new program.LRUCache(3);\n  lruCache.insertKeyValuePair('b', 2);\n  lruCache.insertKeyValuePair('a', 1);\n  lruCache.insertKeyValuePair('c', 3);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('c');\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(1);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('a');\n  lruCache.insertKeyValuePair('d', 4);\n  chai.expect(lruCache.getValueFromKey('b')).to.deep.equal(null);\n  lruCache.insertKeyValuePair('a', 5);\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(5);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const lruCache = new program.LRUCache(3);\n  lruCache.insertKeyValuePair('b', 2);\n  lruCache.insertKeyValuePair('a', 1);\n  lruCache.insertKeyValuePair('c', 3);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('c');\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(1);\n  chai.expect(lruCache.getMostRecentKey()).to.deep.equal('a');\n  lruCache.insertKeyValuePair('d', 4);\n  chai.expect(lruCache.getValueFromKey('b')).to.deep.equal(null);\n  lruCache.insertKeyValuePair('a', 5);\n  chai.expect(lruCache.getValueFromKey('a')).to.deep.equal(5);\n});\n",
    },
    bigO: '(all 3 methods) O(1) time | O(1) space',
    tests: [
      {
        classMethodsToCall: [
          { arguments: ['b', 2], method: 'insertKeyValuePair' },
          { arguments: ['a', 1], method: 'insertKeyValuePair' },
          { arguments: ['c', 3], method: 'insertKeyValuePair' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['d', 4], method: 'insertKeyValuePair' },
          { arguments: ['b'], method: 'getValueFromKey' },
          { arguments: ['a', 5], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
        ],
        maxSize: 3,
      },
      {
        classMethodsToCall: [
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['a', 1], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['a', 9001], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['b', 2], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['b'], method: 'getValueFromKey' },
          { arguments: ['c', 3], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['b'], method: 'getValueFromKey' },
          { arguments: ['c'], method: 'getValueFromKey' },
        ],
        maxSize: 1,
      },
      {
        classMethodsToCall: [
          { arguments: ['a', 1], method: 'insertKeyValuePair' },
          { arguments: ['b', 2], method: 'insertKeyValuePair' },
          { arguments: ['c', 3], method: 'insertKeyValuePair' },
          { arguments: ['d', 4], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['b'], method: 'getValueFromKey' },
          { arguments: ['c'], method: 'getValueFromKey' },
          { arguments: ['d'], method: 'getValueFromKey' },
          { arguments: ['e', 5], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['b'], method: 'getValueFromKey' },
          { arguments: ['c'], method: 'getValueFromKey' },
          { arguments: ['d'], method: 'getValueFromKey' },
          { arguments: ['e'], method: 'getValueFromKey' },
        ],
        maxSize: 4,
      },
      {
        classMethodsToCall: [
          { arguments: ['a', 1], method: 'insertKeyValuePair' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['b', 2], method: 'insertKeyValuePair' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['c', 3], method: 'insertKeyValuePair' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['d', 4], method: 'insertKeyValuePair' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['b'], method: 'getValueFromKey' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['c'], method: 'getValueFromKey' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['d'], method: 'getValueFromKey' },
          { arguments: [], method: 'getMostRecentKey' },
          { arguments: ['e', 5], method: 'insertKeyValuePair' },
          { arguments: [], method: 'getMostRecentKey' },
        ],
        maxSize: 4,
      },
      {
        classMethodsToCall: [
          { arguments: ['a', 1], method: 'insertKeyValuePair' },
          { arguments: ['b', 2], method: 'insertKeyValuePair' },
          { arguments: ['c', 3], method: 'insertKeyValuePair' },
          { arguments: ['d', 4], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['e', 5], method: 'insertKeyValuePair' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['b'], method: 'getValueFromKey' },
          { arguments: ['c'], method: 'getValueFromKey' },
          { arguments: ['f', 5], method: 'insertKeyValuePair' },
          { arguments: ['c'], method: 'getValueFromKey' },
          { arguments: ['d'], method: 'getValueFromKey' },
          { arguments: ['g', 5], method: 'insertKeyValuePair' },
          { arguments: ['e'], method: 'getValueFromKey' },
          { arguments: ['a'], method: 'getValueFromKey' },
          { arguments: ['c'], method: 'getValueFromKey' },
          { arguments: ['f'], method: 'getValueFromKey' },
          { arguments: ['g'], method: 'getValueFromKey' },
        ],
        maxSize: 4,
      },
    ],
  },
  {
    id: 'reverse-linked-list',
    name: 'Reverse Linked List',
    category: 'Linked Lists',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the head of a Singly Linked List, reverses the\n  list in place (i.e., doesn\'t create a brand new list), and returns its new head.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<p>\n  You can assume that the input Linked List will always have at least one node; in other\n  words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">head</span> = 0 -> 1 -> 2 -> 3 -> 4 -> 5 <span class="CodeEditor-promptComment">// the head node with value 0</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5 -> 4 -> 3 -> 2 -> 1 -> 0 <span class="CodeEditor-promptComment">// the new head node with value 5</span>\n</pre>\n</div>',
    hints: [
      '<p>\nYou can iterate through the Linked List from head to tail and reverse it in place along the way.\n</p>\n',
      "\n<p>\nYou'll need to manipulate three nodes at once at every step.\n</p>\n",
      '\n<p>\nImagine you have three variables pointing to three consecutive nodes in a Linked List. Start by setting the "next" property of the second node to the first node. Then, set the first variable to the second node, and set the second variable to the third node. Finally, set the third variable to the second variable\'s "next" property (at this point, the second variable is the original third node). Repeat this process until you\'re at the tail of the Linked List.\n</p>',
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction reverseLinkedList(head) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.reverseLinkedList = reverseLinkedList;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction reverseLinkedList(head) {\n  let previousNode = null;\n  let currentNode = head;\n  while (currentNode !== null) {\n    const nextNode = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n\nexports.LinkedList = LinkedList;\nexports.reverseLinkedList = reverseLinkedList;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5]);\n  const result = program.reverseLinkedList(test).getNodesInArray();\n  const expected = new LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray();\n  chai.expect(result).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const test = new LinkedList(0).addMany([1, 2, 3, 4, 5]);\n  const result = program.reverseLinkedList(test).getNodesInArray();\n  const expected = new LinkedList(5).addMany([4, 3, 2, 1, 0]).getNodesInArray();\n  chai.expect(result).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Linked List',
    tests: [
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      { linkedList: { head: '0', nodes: [{ id: '0', next: null, value: 0 }] } },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: null, value: 1 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: null, value: 2 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: null, value: 3 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: null, value: 6 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: '11', value: 10 },
            { id: '11', next: '12', value: 11 },
            { id: '12', next: null, value: 12 },
          ],
        },
      },
    ],
  },
  {
    id: 'merge-linked-lists',
    name: 'Merge Linked Lists',
    category: 'Linked Lists',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the heads of two Singly Linked Lists that are\n  in sorted order, respectively. The function should merge the lists in place\n  (i.e., it shouldn\'t create a brand new list) and return the head of the merged\n  list; the merged list should be in sorted order.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<p>\n  You can assume that the input linked lists will always have at least one node; in other\n  words, the heads will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">headOne</span> = 2 -> 6 -> 7 -> 8 <span class="CodeEditor-promptComment">// the head node with value 2</span>\n<span class="CodeEditor-promptParameter">headTwo</span> = 1 -> 3 -> 4 -> 5 -> 9 -> 10 <span class="CodeEditor-promptComment">// the head node with value 1</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 <span class="CodeEditor-promptComment">// the new head node with value 1</span>\n</pre>\n</div>',
    hints: [
      '<p>\nYou can iterate through the Linked Lists from head to tail and merge them along the way by inserting nodes from the second Linked List into the first Linked List.\n</p>\n',
      "\n<p>\nYou'll need to manipulate three nodes at once at every step.\n</p>\n",
      "\n<p>\nAt every step, you'll need to have three variables (p1, p2, and p1Prev) pointing to the current node in the first Linked List (p1), the current node in the second Linked List (p2), and the previous node in the first Linked List (p1Prev). If the value of p1 is smaller than the value of p2, then you can just \"move forward\" in the first Linked List by moving p1 and p1Prev forward by one position (p1Prev becomes p1 and p1 becomes p1.next). If the value of p1 is greater than the value of p2, then you need to insert p2 before p1. You'll have to first make p1Prev point to p2, then make p2 point to p1, all the while not losing track of p2's \"next\" node, which you'll need to move to right after. You'll also have to handle edge cases when you're dealing with head nodes or tail nodes.\n</p>\n",
      '\n<p>\nYou can implement this algorithm both iteratively and recursively following nearly identical logic.\n</p>',
    ],
    customInputVars: [
      {
        name: 'linkedListOne',
        example: {
          head: '2',
          nodes: [
            { id: '2', next: '6', value: 2 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: null, value: 8 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
      {
        name: 'linkedListTwo',
        example: {
          head: '1',
          nodes: [
            { id: '1', next: '3', value: 1 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '9', value: 5 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction mergeLinkedLists(headOne, headTwo) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.mergeLinkedLists = mergeLinkedLists;\n',
      solutions: [
        'class LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(1) space - where n is the number of nodes in the first\n// Linked List and m is the number of nodes in the second Linked List\nfunction mergeLinkedLists(headOne, headTwo) {\n  let p1 = headOne;\n  let p1Prev = null;\n  let p2 = headTwo;\n  while (p1 !== null && p2 !== null) {\n    if (p1.value < p2.value) {\n      p1Prev = p1;\n      p1 = p1.next;\n    } else {\n      if (p1Prev !== null) p1Prev.next = p2;\n      p1Prev = p2;\n      p2 = p2.next;\n      p1Prev.next = p1;\n    }\n  }\n  if (p1 === null) p1Prev.next = p2;\n  return headOne.value < headTwo.value ? headOne : headTwo;\n}\n\nexports.LinkedList = LinkedList;\nexports.mergeLinkedLists = mergeLinkedLists;\n',
        'class LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(n + m) space - where n is the number of nodes in the first\n// Linked List and m is the number of nodes in the second Linked List\nfunction mergeLinkedLists(headOne, headTwo) {\n  recursiveMerge(headOne, headTwo, null);\n  return headOne.value < headTwo.value ? headOne : headTwo;\n}\n\nfunction recursiveMerge(p1, p2, p1Prev) {\n  if (p1 === null) {\n    p1Prev.next = p2;\n    return;\n  }\n  if (p2 === null) return;\n\n  if (p1.value < p2.value) {\n    recursiveMerge(p1.next, p2, p1);\n  } else {\n    if (p1Prev !== null) p1Prev.next = p2;\n    const newP2 = p2.next;\n    p2.next = p1;\n    recursiveMerge(p1, newP2, p2);\n  }\n}\n\nexports.LinkedList = LinkedList;\nexports.mergeLinkedLists = mergeLinkedLists;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const list1 = new LinkedList(2).addMany([6, 7, 8]);\n  const list2 = new LinkedList(1).addMany([3, 4, 5, 9, 10]);\n  const output = program.mergeLinkedLists(list1, list2);\n  const expectedNodes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n  chai.expect(output.getNodesInArray()).to.deep.equal(expectedNodes);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const list1 = new LinkedList(2).addMany([6, 7, 8]);\n  const list2 = new LinkedList(1).addMany([3, 4, 5, 9, 10]);\n  const output = program.mergeLinkedLists(list1, list2);\n  const expectedNodes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n  chai.expect(output.getNodesInArray()).to.deep.equal(expectedNodes);\n});\n",
    },
    bigO: 'O(n + m) time | O(1) space - where n is the number of nodes in the first Linked List and m is the number of nodes in the second Linked List',
    tests: [
      {
        linkedListOne: {
          head: '2',
          nodes: [
            { id: '2', next: '6', value: 2 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: null, value: 8 },
          ],
        },
        linkedListTwo: {
          head: '1',
          nodes: [
            { id: '1', next: '3', value: 1 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '9', value: 5 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
        linkedListTwo: {
          head: '6',
          nodes: [
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '6',
          nodes: [
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
        linkedListTwo: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '3', value: 1 },
            { id: '3', next: '5', value: 3 },
            { id: '5', next: '7', value: 5 },
            { id: '7', next: '9', value: 7 },
            { id: '9', next: null, value: 9 },
          ],
        },
        linkedListTwo: {
          head: '2',
          nodes: [
            { id: '2', next: '4', value: 2 },
            { id: '4', next: '6', value: 4 },
            { id: '6', next: '8', value: 6 },
            { id: '8', next: '10', value: 8 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '7', value: 5 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
        linkedListTwo: {
          head: '6',
          nodes: [{ id: '6', next: null, value: 6 }],
        },
      },
      {
        linkedListOne: {
          head: '6',
          nodes: [{ id: '6', next: null, value: 6 }],
        },
        linkedListTwo: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '7', value: 5 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [{ id: '1', next: null, value: 1 }],
        },
        linkedListTwo: {
          head: '2',
          nodes: [{ id: '2', next: null, value: 2 }],
        },
      },
      {
        linkedListOne: {
          head: '2',
          nodes: [{ id: '2', next: null, value: 2 }],
        },
        linkedListTwo: {
          head: '1',
          nodes: [{ id: '1', next: null, value: 1 }],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '1-3', value: 1 },
            { id: '1-3', next: '3', value: 1 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '5-2', value: 5 },
            { id: '5-2', next: '5-3', value: 5 },
            { id: '5-3', next: '5-4', value: 5 },
            { id: '5-4', next: '10', value: 5 },
            { id: '10', next: null, value: 10 },
          ],
        },
        linkedListTwo: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '2', value: 1 },
            { id: '2', next: '2-2', value: 2 },
            { id: '2-2', next: '5', value: 2 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '10', value: 6 },
            { id: '10', next: '10-2', value: 10 },
            { id: '10-2', next: null, value: 10 },
          ],
        },
      },
    ],
  },
  {
    id: 'shift-linked-list',
    name: 'Shift Linked List',
    category: 'Linked Lists',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the head of a Singly Linked List and an integer\n  <span>k</span>, shifts the list in place (i.e., doesn\'t create a brand new\n  list) by k positions, and returns its new head.\n</p>\n<p>\n  Shifting a Linked List means moving its nodes forward or backward and wrapping\n  them around the list where appropriate. For example, shifting a Linked List\n  forward by one position would make its tail become the new head of the linked\n  list.\n</p>\n<p>\n  Whether nodes are moved forward or backward is determined by whether\n  <span>k</span> is positive or negative.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<p>\n  You can assume that the input Linked List will always have at least one node;\n  in other words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">head</span> = 0 -> 1 -> 2 -> 3 -> 4 -> 5 <span class="CodeEditor-promptComment">// the head node with value 0</span>\n<span class="CodeEditor-promptParameter">k</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 -> 5 -> 0 -> 1 -> 2 -> 3 <span class="CodeEditor-promptComment">// the new head node with value 4</span>\n</pre>\n</div>',
    hints: [
      '<p>\nPutting aside the cases where k is a negative integer, where k is 0, or where k is larger than the length of the linked list, what does shifting the linked list by k positions entail exactly?\n</p>\n',
      '\n<p>\nPutting aside the cases mentioned in Hint #1, shifting the linked list by k positions means moving the last k nodes in the linked list to the front of the linked list. What nodes in the linked list will you actually need to mutate?\n</p>\n',
      '\n<p>\nThere are four nodes that really matter in this entire process: the original tail of the linked list, which will point to the original head of the linked list, the original head of the linked list, which will be pointed to by the original tail of the linked list, the new tail of the linked list, and the new head of the linked list. Note that the new head is the node that the new tail points to in the original, unshifted linked list.\n</p>\n',
      "\n<p>\nYou can find the original tail of the linked list by simply traversing the linked list, starting at the original head of the linked list that you're given. You can find the new tail of the linked list by moving k positions from the original tail if k is positive (which means moving to the (lengthOfList - k)th position in the list, and you can easily count the length of the list as you traverse it to find its original tail). You can access the new head of the linked list once you've found its new tail, since it's the new tail's original next node. How will you handle the trickier values of k?\n</p>",
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
      { name: 'k', example: 2, schema: { type: 'integer' } },
    ],
    isFree: true,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is the class of the input linked list.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction shiftLinkedList(head, k) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.shiftLinkedList = shiftLinkedList;\n',
      solutions: [
        '// This is the class of the input linked list.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction shiftLinkedList(head, k) {\n  let listLength = 1;\n  let listTail = head;\n  while (listTail.next !== null) {\n    listTail = listTail.next;\n    listLength++;\n  }\n\n  const offset = Math.abs(k) % listLength;\n  if (offset === 0) return head;\n\n  const newTailPosition = k > 0 ? listLength - offset : offset;\n  let newTail = head;\n  for (let i = 1; i < newTailPosition; i++) {\n    newTail = newTail.next;\n  }\n\n  const newHead = newTail.next;\n  newTail.next = null;\n  listTail.next = head;\n  return newHead;\n}\n\nexports.LinkedList = LinkedList;\nexports.shiftLinkedList = shiftLinkedList;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {LinkedList} = program;\n\nfunction linkedListToArray(head) {\n  const array = [];\n  let current = head;\n  while (current) {\n    array.push(current.value);\n    current = current.next;\n  }\n  return array;\n}\n\nit('Test Case #1', function () {\n  const head = new LinkedList(0);\n  head.next = new LinkedList(1);\n  head.next.next = new LinkedList(2);\n  head.next.next.next = new LinkedList(3);\n  head.next.next.next.next = new LinkedList(4);\n  head.next.next.next.next.next = new LinkedList(5);\n  const result = program.shiftLinkedList(head, 2);\n  const array = linkedListToArray(result);\n\n  var expected = [4, 5, 0, 1, 2, 3];\n  chai.expect(array).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst {LinkedList} = program;\n\nfunction linkedListToArray(head) {\n  const array = [];\n  let current = head;\n  while (current) {\n    array.push(current.value);\n    current = current.next;\n  }\n  return array;\n}\n\nit('Test Case #1', function () {\n  const head = new LinkedList(0);\n  head.next = new LinkedList(1);\n  head.next.next = new LinkedList(2);\n  head.next.next.next = new LinkedList(3);\n  head.next.next.next.next = new LinkedList(4);\n  head.next.next.next.next.next = new LinkedList(5);\n  const result = program.shiftLinkedList(head, 2);\n  const array = linkedListToArray(result);\n\n  var expected = [4, 5, 0, 1, 2, 3];\n  chai.expect(array).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Linked List',
    tests: [
      {
        k: 2,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 0,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 1,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 3,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 4,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 5,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 6,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 8,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 14,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 18,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -1,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -2,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -3,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -4,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -5,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -6,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -8,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -14,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -18,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 2,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '4', value: 1 },
            { id: '2', next: null, value: 2 },
            { id: '3', next: '5', value: 3 },
            { id: '4', next: '3', value: 4 },
            { id: '5', next: '2', value: 5 },
          ],
        },
      },
    ],
  },
  {
    id: 'rearrange-linked-list',
    name: 'Rearrange Linked List',
    category: 'Linked Lists',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the head of a Singly Linked List and an integer\n  <span>k</span>, rearranges the list in place (i.e., doesn\'t create a brand new\n  list) around nodes with value <span>k</span>, and returns its new head.\n</p>\n<p>\n  Rearranging a Linked List around nodes with value <span>k</span> means moving\n  all nodes with a value smaller than <span>k</span> before all nodes with value\n  <span>k</span> and moving all nodes with a value greater than\n  <span>k</span> after all nodes with value <span>k</span>.\n</p>\n<p>\n  All moved nodes should maintain their original relative ordering if possible.\n</p>\n<p>\n  Note that the linked list should be rearranged even if it doesn\'t have any\n  nodes with value <span>k</span>.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<p>\n  You can assume that the input Linked List will always have at least one node;\n  in other words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">head</span> = 3 -> 0 -> 5 -> 2 -> 1 -> 4 <span class="CodeEditor-promptComment">// the head node with value 3</span>\n<span class="CodeEditor-promptParameter">k</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n0 -> 2 -> 1 -> 3 -> 5 -> 4 <span class="CodeEditor-promptComment">// the new head node with value 0</span>\n<span class="CodeEditor-promptComment">// Note that the nodes with values 0, 2, and 1 have</span>\n<span class="CodeEditor-promptComment">// maintained their original relative ordering, and</span>\n<span class="CodeEditor-promptComment">// so have the nodes with values 5 and 4.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nThe final linked list that you have to return essentially consists of three linked lists attached to one another: one with nodes whose values are smaller than k, one with nodes whose values are equal to k, and one with nodes whose values are greater than k.\n</p>\n',
      '\n<p>\nIterate through the linked list once, build the three linked lists mentioned in Hint #1 as you go, and finally connect these three linked lists to form the rearranged list.\n</p>\n',
      "\n<p>\nTo build the three linked lists mentioned in Hints #1 and #2, you'll have to keep track of their heads and tails and update the appropriate linked list's tail with each node that you traverse as you iterate through the main linked list. You can determine which linked list is the relevant one by simply comparing the value of the node that you're traversing to k.\n</p>\n",
      "\n<p>\nConnecting the three linked lists mentioned in the previous Hint won't be as simple as it sounds, mainly because one or two of the linked lists might actually be empty, depending on the various nodes' values and the value of k.\n</p>",
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '3',
          nodes: [
            { id: '3', next: '0', value: 3 },
            { id: '0', next: '5', value: 0 },
            { id: '5', next: '2', value: 5 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: null, value: 4 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
      { name: 'k', example: 3, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is the class of the input linked list.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction rearrangeLinkedList(head, k) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.rearrangeLinkedList = rearrangeLinkedList;\n',
      solutions: [
        '// This is the class of the input linked list.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction rearrangeLinkedList(head, k) {\n  let smallerListHead = null;\n  let smallerListTail = null;\n  let equalListHead = null;\n  let equalListTail = null;\n  let greaterListHead = null;\n  let greaterListTail = null;\n\n  let node = head;\n  while (node !== null) {\n    if (node.value < k) {\n      [smallerListHead, smallerListTail] = growLinkedList(smallerListHead, smallerListTail, node);\n    } else if (node.value > k) {\n      [greaterListHead, greaterListTail] = growLinkedList(greaterListHead, greaterListTail, node);\n    } else {\n      [equalListHead, equalListTail] = growLinkedList(equalListHead, equalListTail, node);\n    }\n\n    const prevNode = node;\n    node = node.next;\n    prevNode.next = null;\n  }\n\n  const [firstHead, firstTail] = connectLinkedLists(\n    smallerListHead,\n    smallerListTail,\n    equalListHead,\n    equalListTail,\n  );\n  const [finalHead, _] = connectLinkedLists(firstHead, firstTail, greaterListHead, greaterListTail);\n  return finalHead;\n}\n\nfunction growLinkedList(head, tail, node) {\n  let newHead = head;\n  let newTail = node;\n\n  if (newHead === null) newHead = node;\n  if (tail !== null) tail.next = node;\n\n  return [newHead, newTail];\n}\n\nfunction connectLinkedLists(headOne, tailOne, headTwo, tailTwo) {\n  const newHead = headOne === null ? headTwo : headOne;\n  const newTail = tailTwo === null ? tailOne : tailTwo;\n\n  if (tailOne !== null) tailOne.next = headTwo;\n\n  return [newHead, newTail];\n}\n\nexports.LinkedList = LinkedList;\nexports.rearrangeLinkedList = rearrangeLinkedList;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {LinkedList} = program;\n\nfunction linkedListToArray(head) {\n  const array = [];\n  let current = head;\n  while (current) {\n    array.push(current.value);\n    current = current.next;\n  }\n  return array;\n}\n\nit('Test Case #1', function () {\n  const head = new LinkedList(3);\n  head.next = new LinkedList(0);\n  head.next.next = new LinkedList(5);\n  head.next.next.next = new LinkedList(2);\n  head.next.next.next.next = new LinkedList(1);\n  head.next.next.next.next.next = new LinkedList(4);\n  const result = program.rearrangeLinkedList(head, 3);\n  const array = linkedListToArray(result);\n\n  var expected = [0, 2, 1, 3, 5, 4];\n  chai.expect(array).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst {LinkedList} = program;\n\nfunction linkedListToArray(head) {\n  const array = [];\n  let current = head;\n  while (current) {\n    array.push(current.value);\n    current = current.next;\n  }\n  return array;\n}\n\nit('Test Case #1', function () {\n  const head = new LinkedList(3);\n  head.next = new LinkedList(0);\n  head.next.next = new LinkedList(5);\n  head.next.next.next = new LinkedList(2);\n  head.next.next.next.next = new LinkedList(1);\n  head.next.next.next.next.next = new LinkedList(4);\n  const result = program.rearrangeLinkedList(head, 3);\n  const array = linkedListToArray(result);\n\n  var expected = [0, 2, 1, 3, 5, 4];\n  chai.expect(array).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Linked List',
    tests: [
      {
        k: 3,
        linkedList: {
          head: '3',
          nodes: [
            { id: '3', next: '0', value: 3 },
            { id: '0', next: '5', value: 0 },
            { id: '5', next: '2', value: 5 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: null, value: 4 },
          ],
        },
      },
      {
        k: 4,
        linkedList: {
          head: '3',
          nodes: [
            { id: '3', next: '0', value: 3 },
            { id: '0', next: '2', value: 0 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 5,
        linkedList: {
          head: '3',
          nodes: [
            { id: '3', next: '0', value: 3 },
            { id: '0', next: '2', value: 0 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: 0,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '3', value: 0 },
            { id: '3', next: '2', value: 3 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        k: -9000,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '3', value: 0 },
            { id: '3', next: '2', value: 3 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '3-2', value: 5 },
            { id: '3-2', next: '-1', value: 3 },
            { id: '-1', next: '-2', value: -1 },
            { id: '-2', next: '3-3', value: -2 },
            { id: '3-3', next: '6', value: 3 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '3-4', value: 7 },
            { id: '3-4', next: '2-2', value: 3 },
            { id: '2-2', next: '-9000', value: 2 },
            { id: '-9000', next: null, value: -9000 },
          ],
        },
      },
      {
        k: 2,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '3', value: 0 },
            { id: '3', next: '2', value: 3 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '3-2', value: 5 },
            { id: '3-2', next: '-1', value: 3 },
            { id: '-1', next: '-2', value: -1 },
            { id: '-2', next: '3-3', value: -2 },
            { id: '3-3', next: '6', value: 3 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '3-4', value: 7 },
            { id: '3-4', next: '2-2', value: 3 },
            { id: '2-2', next: '-9000', value: 2 },
            { id: '-9000', next: null, value: -9000 },
          ],
        },
      },
      {
        k: 3,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '3', value: 0 },
            { id: '3', next: '2', value: 3 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '3-2', value: 5 },
            { id: '3-2', next: '-1', value: 3 },
            { id: '-1', next: '-2', value: -1 },
            { id: '-2', next: '3-3', value: -2 },
            { id: '3-3', next: '6', value: 3 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '3-4', value: 7 },
            { id: '3-4', next: '2-2', value: 3 },
            { id: '2-2', next: '-9000', value: 2 },
            { id: '-9000', next: null, value: -9000 },
          ],
        },
      },
      {
        k: 3,
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '3-2', value: 3 },
            { id: '3-2', next: '3-3', value: 3 },
            { id: '3-3', next: '3-4', value: 3 },
            { id: '3-4', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        k: -1,
        linkedList: {
          head: '3',
          nodes: [
            { id: '3', next: '0', value: 3 },
            { id: '0', next: '5', value: 0 },
            { id: '5', next: '2', value: 5 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: null, value: 4 },
          ],
        },
      },
      {
        k: 6,
        linkedList: {
          head: '3',
          nodes: [
            { id: '3', next: '0', value: 3 },
            { id: '0', next: '5', value: 0 },
            { id: '5', next: '2', value: 5 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: null, value: 4 },
          ],
        },
      },
      {
        k: 3,
        linkedList: {
          head: '6',
          nodes: [
            { id: '6', next: '0', value: 6 },
            { id: '0', next: '5', value: 0 },
            { id: '5', next: '2', value: 5 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: null, value: 4 },
          ],
        },
      },
    ],
  },
  {
    id: 'linked-list-palindrome',
    name: 'Linked List Palindrome',
    category: 'Linked Lists',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the head of a Singly Linked List and returns a\n  boolean representing whether the linked list\'s nodes form a palindrome. Your\n  function shouldn\'t make use of any auxiliary data structure.\n</p>\n<p>\n  A palindrome is usually defined as a string that\'s written the same forward\n  and backward. For a linked list\'s nodes to form a palindrome, their values\n  must be the same when read from left to right and from right to left. Note\n  that single-character strings are palindromes, which means that single-node\n  linked lists form palindromes.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<p>\n  You can assume that the input linked list will always have at least one node;\n  in other words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">head</span> = 0 -> 1 -> 2 -> 2 -> 1 -> 0 <span class="CodeEditor-promptComment">// the head node with value 0</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      "<p>\nThink about comparing two nodes at a time. To determine if the linked list's nodes form a palindrome, which two nodes should we compare?\n</p>\n",
      "\n<p>\nFollowing Hint #1, to determine if the linked list's nodes form a palindrome, we'll want to compare the first and last node, the second and second-to-last node, the third and third-to-last node, etc.. How can we compare all of these nodes recursively?\n</p>\n",
      '\n<p>\nPutting aside the recursive solution hinted at in Hint #2, we can solve this problem iteratively and with no auxiliary space if we know how to reverse a linked list. How can reversing the linked list (or part of it) help us solve this problem?\n</p>\n',
      "\n<p>\nTry reversing the second half of the linked list and then comparing nodes in the first half and in the reversed second half by simply iterating through both halves at the same time. You'll have to figure out where the second half of the linked list begins in order to reverse it.\n</p>",
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '2-2', value: 2 },
            { id: '2-2', next: '1-2', value: 2 },
            { id: '1-2', next: '0-2', value: 1 },
            { id: '0-2', next: null, value: 0 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction linkedListPalindrome(head) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.linkedListPalindrome = linkedListPalindrome;\n',
      solutions: [
        'class LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Linked List\nfunction linkedListPalindrome(head) {\n  const isPalindromeResults = isPalindrome(head, head);\n  return isPalindromeResults.outerNodesAreEqual;\n}\n\nfunction isPalindrome(leftNode, rightNode) {\n  if (rightNode === null) {\n    return new LinkedListInfo(true, leftNode);\n  }\n\n  const recursiveCallResults = isPalindrome(leftNode, rightNode.next);\n  const {leftNodeToCompare, outerNodesAreEqual} = recursiveCallResults;\n\n  const recursiveIsEqual = outerNodesAreEqual && leftNodeToCompare.value === rightNode.value;\n  const nextLeftNodeToCompare = leftNodeToCompare.next;\n\n  return new LinkedListInfo(recursiveIsEqual, nextLeftNodeToCompare);\n}\n\nclass LinkedListInfo {\n  constructor(outerNodesAreEqual, leftNodeToCompare) {\n    this.outerNodesAreEqual = outerNodesAreEqual;\n    this.leftNodeToCompare = leftNodeToCompare;\n  }\n}\n\n// Do not edit the line below.\nexports.linkedListPalindrome = linkedListPalindrome;\nexports.LinkedList = LinkedList;\n',
        'class LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction linkedListPalindrome(head) {\n  let slowNode = head;\n  let fastNode = head;\n  while (fastNode !== null && fastNode.next !== null) {\n    slowNode = slowNode.next;\n    fastNode = fastNode.next.next;\n  }\n\n  let reversedSecondHalfNode = reverseLinkedList(slowNode);\n  let firstHalfNode = head;\n\n  while (reversedSecondHalfNode !== null) {\n    if (reversedSecondHalfNode.value !== firstHalfNode.value) {\n      return false;\n    }\n    reversedSecondHalfNode = reversedSecondHalfNode.next;\n    firstHalfNode = firstHalfNode.next;\n  }\n\n  return true;\n}\n\nfunction reverseLinkedList(head) {\n  let previousNode = null;\n  let currentNode = head;\n  while (currentNode !== null) {\n    const nextNode = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n\nexports.linkedListPalindrome = linkedListPalindrome;\nexports.LinkedList = LinkedList;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const head = new program.LinkedList(0);\n  head.next = new program.LinkedList(1);\n  head.next.next = new program.LinkedList(2);\n  head.next.next.next = new program.LinkedList(2);\n  head.next.next.next.next = new program.LinkedList(1);\n  head.next.next.next.next.next = new program.LinkedList(0);\n  const expected = true;\n  const actual = program.linkedListPalindrome(head);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const head = new program.LinkedList(0);\n  head.next = new program.LinkedList(1);\n  head.next.next = new program.LinkedList(2);\n  head.next.next.next = new program.LinkedList(2);\n  head.next.next.next.next = new program.LinkedList(1);\n  head.next.next.next.next.next = new program.LinkedList(0);\n  const expected = true;\n  const actual = program.linkedListPalindrome(head);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Linked List',
    tests: [
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '2-2', value: 2 },
            { id: '2-2', next: '1-2', value: 2 },
            { id: '1-2', next: '0-2', value: 1 },
            { id: '0-2', next: null, value: 0 },
          ],
        },
      },
      { linkedList: { head: '0', nodes: [{ id: '0', next: null, value: 0 }] } },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: null, value: 1 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '0-2', value: 0 },
            { id: '0-2', next: null, value: 0 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: null, value: 3 },
          ],
        },
      },
      {
        linkedList: {
          head: '6',
          nodes: [
            { id: '6', next: '5', value: 6 },
            { id: '5', next: '4', value: 5 },
            { id: '4', next: '3', value: 4 },
            { id: '3', next: '4-2', value: 3 },
            { id: '4-2', next: '5-2', value: 4 },
            { id: '5-2', next: '6-2', value: 5 },
            { id: '6-2', next: null, value: 6 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '5-2', value: 5 },
            { id: '5-2', next: '4-2', value: 5 },
            { id: '4-2', next: '3-2', value: 4 },
            { id: '3-2', next: '2-2', value: 3 },
            { id: '2-2', next: '1-2', value: 2 },
            { id: '1-2', next: '0-2', value: 1 },
            { id: '0-2', next: '12', value: 0 },
            { id: '12', next: null, value: 12 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '5-2', value: 5 },
            { id: '5-2', next: '4-2', value: 5 },
            { id: '4-2', next: '3-2', value: 4 },
            { id: '3-2', next: '2-2', value: 3 },
            { id: '2-2', next: '1-2', value: 2 },
            { id: '1-2', next: '0-2', value: 1 },
            { id: '0-2', next: null, value: 0 },
          ],
        },
      },
      {
        linkedList: {
          head: '10000',
          nodes: [
            { id: '10000', next: '10000-2', value: 10000 },
            { id: '10000-2', next: '10000-3', value: 10000 },
            { id: '10000-3', next: null, value: 10000 },
          ],
        },
      },
      {
        linkedList: {
          head: '10000',
          nodes: [
            { id: '10000', next: '10000-2', value: 10000 },
            { id: '10000-2', next: '10000-3', value: 10000 },
            { id: '10000-3', next: '10000-4', value: 10000 },
            { id: '10000-4', next: null, value: 10000 },
          ],
        },
      },
      {
        linkedList: {
          head: '3',
          nodes: [
            { id: '3', next: '1', value: 3 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3-2', value: 2 },
            { id: '3-2', next: null, value: 3 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: '11', value: 10 },
            { id: '11', next: '10-2', value: 11 },
            { id: '10-2', next: '9-2', value: 10 },
            { id: '9-2', next: '8-2', value: 9 },
            { id: '8-2', next: '7-2', value: 8 },
            { id: '7-2', next: '6-2', value: 7 },
            { id: '6-2', next: '5-2', value: 6 },
            { id: '5-2', next: '4-2', value: 5 },
            { id: '4-2', next: '3-2', value: 4 },
            { id: '3-2', next: '2-2', value: 3 },
            { id: '2-2', next: '1-2', value: 2 },
            { id: '1-2', next: null, value: 1 },
          ],
        },
      },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: '11', value: 10 },
            { id: '11', next: '10-2', value: 11 },
            { id: '10-2', next: '9-2', value: 10 },
            { id: '9-2', next: '8-2', value: 9 },
            { id: '8-2', next: '7-2', value: 8 },
            { id: '7-2', next: '6-2', value: 7 },
            { id: '6-2', next: '5-2', value: 6 },
            { id: '5-2', next: '4-2', value: 5 },
            { id: '4-2', next: '3-2', value: 4 },
            { id: '3-2', next: '2-2', value: 3 },
            { id: '2-2', next: '1-2', value: 2 },
            { id: '1-2', next: '0-2', value: 1 },
            { id: '0-2', next: null, value: 0 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '1-2', value: 3 },
            { id: '1-2', next: '2-2', value: 1 },
            { id: '2-2', next: null, value: 2 },
          ],
        },
      },
    ],
  },
  {
    id: 'remove-duplicates-from-linked-list',
    name: 'Remove Duplicates From Linked List',
    category: 'Linked Lists',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  You\'re given the head of a Singly Linked List whose nodes are in sorted order\n  with respect to their values. Write a function that returns a modified version\n  of the Linked List that doesn\'t contain any nodes with duplicate values. The\n  Linked List should be modified in place (i.e., you shouldn\'t create a brand\n  new list), and the modified Linked List should still have its nodes sorted\n  with respect to their values.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">linkedList</span> = 1 -> 1 -> 3 -> 4 -> 4 -> 4 -> 5 -> 6 -> 6 <span class="CodeEditor-promptComment">// the head node with value 1</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 -> 3 -> 4 -> 5 -> 6 <span class="CodeEditor-promptComment">// the head node with value 1</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  The brute-force approach to this problem is to use a hash table or a set to\n  keep track of all node values that exist while traversing the linked list and\n  to simply remove nodes that have a value that already exists. This approach\n  works, but can you solve this problem without using an auxiliary data\n  structure?\n</p>\n',
      '\n<p>\n  What does the fact that the nodes are sorted tell you about the location of\n  all duplicate nodes? How can you use this fact to solve this problem with\n  constant space?\n</p>\n',
      "\n<p>\n  Since the linked list's nodes are sorted, you can loop through them and, at\n  each iteration, simply remove all successive nodes that have the same value as\n  the current node. For each node, change its next pointer to the next node in\n  the linked list that has a different value. This will remove all\n  duplicate-value nodes.\n</p>",
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '1-3', value: 1 },
            { id: '1-3', next: '2', value: 1 },
            { id: '2', next: '3', value: 3 },
            { id: '3', next: '3-2', value: 4 },
            { id: '3-2', next: '3-3', value: 4 },
            { id: '3-3', next: '4', value: 4 },
            { id: '4', next: '5', value: 5 },
            { id: '5', next: '5-2', value: 6 },
            { id: '5-2', next: null, value: 6 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction removeDuplicatesFromLinkedList(linkedList) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.removeDuplicatesFromLinkedList = removeDuplicatesFromLinkedList;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction removeDuplicatesFromLinkedList(linkedList) {\n  let currentNode = linkedList;\n  while (currentNode !== null) {\n    let nextDistinctNode = currentNode.next;\n    while (nextDistinctNode !== null && nextDistinctNode.value === currentNode.value) {\n      nextDistinctNode = nextDistinctNode.next;\n    }\n\n    currentNode.next = nextDistinctNode;\n    currentNode = nextDistinctNode;\n  }\n\n  return linkedList;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.removeDuplicatesFromLinkedList = removeDuplicatesFromLinkedList;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const input = new LinkedList(1).addMany([1, 3, 4, 4, 4, 5, 6, 6]);\n  const expected = new LinkedList(1).addMany([3, 4, 5, 6]);\n  const actual = program.removeDuplicatesFromLinkedList(input);\n  chai.expect(actual.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const input = new LinkedList(1).addMany([1, 3, 4, 4, 4, 5, 6, 6]);\n  const expected = new LinkedList(1).addMany([3, 4, 5, 6]);\n  const actual = program.removeDuplicatesFromLinkedList(input);\n  chai.expect(actual.getNodesInArray()).to.deep.equal(expected.getNodesInArray());\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Linked List',
    tests: [
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '1-3', value: 1 },
            { id: '1-3', next: '2', value: 1 },
            { id: '2', next: '3', value: 3 },
            { id: '3', next: '3-2', value: 4 },
            { id: '3-2', next: '3-3', value: 4 },
            { id: '3-3', next: '4', value: 4 },
            { id: '4', next: '5', value: 5 },
            { id: '5', next: '5-2', value: 6 },
            { id: '5-2', next: null, value: 6 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '1-3', value: 1 },
            { id: '1-3', next: '1-4', value: 1 },
            { id: '1-4', next: '1-5', value: 1 },
            { id: '1-5', next: '4', value: 1 },
            { id: '4', next: '4-2', value: 4 },
            { id: '4-2', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '6-2', value: 6 },
            { id: '6-2', next: null, value: 6 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '1-3', value: 1 },
            { id: '1-3', next: '1-4', value: 1 },
            { id: '1-4', next: '1-5', value: 1 },
            { id: '1-5', next: '1-6', value: 1 },
            { id: '1-6', next: '1-7', value: 1 },
            { id: '1-7', next: null, value: 1 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '9', value: 1 },
            { id: '9', next: '11', value: 9 },
            { id: '11', next: '15', value: 11 },
            { id: '15', next: '15-2', value: 15 },
            { id: '15-2', next: '16', value: 15 },
            { id: '16', next: '17', value: 16 },
            { id: '17', next: null, value: 17 },
          ],
        },
      },
      { linkedList: { head: '1', nodes: [{ id: '1', next: null, value: 1 }] } },
      {
        linkedList: {
          head: '-5',
          nodes: [
            { id: '-5', next: '-1', value: -5 },
            { id: '-1', next: '-1-2', value: -1 },
            { id: '-1-2', next: '-1-3', value: -1 },
            { id: '-1-3', next: '5', value: -1 },
            { id: '5', next: '5-2', value: 5 },
            { id: '5-2', next: '5-3', value: 5 },
            { id: '5-3', next: '8', value: 5 },
            { id: '8', next: '8-2', value: 8 },
            { id: '8-2', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: '11', value: 10 },
            { id: '11', next: '11-2', value: 11 },
            { id: '11-2', next: null, value: 11 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: '11', value: 10 },
            { id: '11', next: '12', value: 11 },
            { id: '12', next: '12-2', value: 12 },
            { id: '12-2', next: null, value: 12 },
          ],
        },
      },
    ],
  },
  {
    id: 'sum-of-linked-lists',
    name: 'Sum of Linked Lists',
    category: 'Linked Lists',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given two Linked Lists of potentially unequal length. Each Linked List\n  represents a non-negative integer, where each node in the Linked List is a\n  digit of that integer, and the first node in each Linked List always\n  represents the least significant digit of the integer. Write a function that\n  returns the head of a new Linked List that represents the sum of the integers\n  represented by the two input Linked Lists.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list. The\n  <span>value</span> of each <span>LinkedList</span> node is always in the range\n  of <span>0 - 9</span>.\n</p>\n<p>\n  Note: your function must create and return a new Linked List, and you\'re not\n  allowed to modify either of the input Linked Lists.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">linkedListOne</span> = 2 -> 4 -> 7 -> 1\n<span class="CodeEditor-promptParameter">linkedListTwo</span> = 9 -> 4 -> 5\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 -> 9 -> 2 -> 2\n<span class="CodeEditor-promptComment">// linkedListOne represents 1742</span>\n<span class="CodeEditor-promptComment">// linkedListTwo represents 549</span>\n<span class="CodeEditor-promptComment">// 1742 + 549 = 2291</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  If you can determine the integers that each individual Linked List represents,\n  then all you need to do is add these integers and create a new Linked List\n  that represents the summed value.\n</p>\n',
      "\n<p>\n  If you go with the approach mentioned in Hint #1, you'll need to break down\n  the sum of the two Linked Lists' numbers into its individual digits. Once you\n  know these digits, you can create a new Linked List using them. This approach\n  is <i>fine</i>, but you can solve this problem more elegantly, with a single\n  iteration through the Linked Lists.\n</p>\n",
      '\n<p>\n  Is it necessary to know the entire numbers represented by both Linked Lists in\n  order to calculate their sum? Think back to your elementary-school math class;\n  how did you add two numbers together?\n</p>\n',
      "\n<p>\n  Since each Linked List's digits are ordered from least significant digit to\n  most significant digit, you can simply loop through both Linked Lists,\n  consider the digits with the same significance, and add these digits together\n  while keeping track of any <i>carry</i> that comes out of the addition. At\n  each iteration, when you add the two Linked List digits, also add the carry\n  from the previous iteration. Create a new Linked List node that stores the\n  calculated value, and add that to your new Linked List. Keep iterating until\n  you reach the end of both Linked Lists and have no remaining carry.\n</p>",
    ],
    customInputVars: [
      {
        name: 'linkedListOne',
        example: {
          head: '2',
          nodes: [
            { id: '2', next: '4', value: 2 },
            { id: '4', next: '7', value: 4 },
            { id: '7', next: '1', value: 7 },
            { id: '1', next: null, value: 1 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
      {
        name: 'linkedListTwo',
        example: {
          head: '9',
          nodes: [
            { id: '9', next: '4', value: 9 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction sumOfLinkedLists(linkedListOne, linkedListTwo) {\n  // Write your code here.\n  return linkedListOne;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.sumOfLinkedLists = sumOfLinkedLists;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(max(n, m)) time | O(max(n, m)) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunction sumOfLinkedLists(linkedListOne, linkedListTwo) {\n  // This variable will store a dummy node whose .next\n  // attribute will point to the head of our new LL.\n  const newLinkedListHeadPointer = new LinkedList(0);\n  let currentNode = newLinkedListHeadPointer;\n  let carry = 0;\n\n  let nodeOne = linkedListOne;\n  let nodeTwo = linkedListTwo;\n  while (nodeOne !== null || nodeTwo !== null || carry !== 0) {\n    const valueOne = nodeOne !== null ? nodeOne.value : 0;\n    const valueTwo = nodeTwo !== null ? nodeTwo.value : 0;\n    const sumOfValues = valueOne + valueTwo + carry;\n\n    const newValue = sumOfValues % 10;\n    const newNode = new LinkedList(newValue);\n    currentNode.next = newNode;\n    currentNode = newNode;\n\n    carry = Math.floor(sumOfValues / 10);\n    nodeOne = nodeOne !== null ? nodeOne.next : null;\n    nodeTwo = nodeTwo !== null ? nodeTwo.next : null;\n  }\n\n  return newLinkedListHeadPointer.next;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.sumOfLinkedLists = sumOfLinkedLists;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n}\n\nfunction getNodesInArray(linkedList) {\n  const nodes = [];\n  let current = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n\nit('Test Case #1', function () {\n  const ll1 = new LinkedList(2).addMany([4, 7, 1]);\n  const ll2 = new LinkedList(9).addMany([4, 5]);\n  const expected = new LinkedList(1).addMany([9, 2, 2]);\n  const actual = program.sumOfLinkedLists(ll1, ll2);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(getNodesInArray(expected));\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n}\n\nfunction getNodesInArray(linkedList) {\n  const nodes = [];\n  let current = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n\nit('Test Case #1', function () {\n  const ll1 = new LinkedList(2).addMany([4, 7, 1]);\n  const ll2 = new LinkedList(9).addMany([4, 5]);\n  const expected = new LinkedList(1).addMany([9, 2, 2]);\n  const actual = program.sumOfLinkedLists(ll1, ll2);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(getNodesInArray(expected));\n});\n",
    },
    bigO: 'O(max(n, m)) time | O(max(n, m)) space - where n is the length of the first Linked List and m is the length of the second Linked List',
    tests: [
      {
        linkedListOne: {
          head: '2',
          nodes: [
            { id: '2', next: '4', value: 2 },
            { id: '4', next: '7', value: 4 },
            { id: '7', next: '1', value: 7 },
            { id: '1', next: null, value: 1 },
          ],
        },
        linkedListTwo: {
          head: '9',
          nodes: [
            { id: '9', next: '4', value: 9 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '2',
          nodes: [{ id: '2', next: null, value: 2 }],
        },
        linkedListTwo: {
          head: '9',
          nodes: [{ id: '9', next: null, value: 9 }],
        },
      },
      {
        linkedListOne: {
          head: '0',
          nodes: [
            { id: '0', next: '0-2', value: 0 },
            { id: '0-2', next: '0-3', value: 0 },
            { id: '0-3', next: '5', value: 0 },
            { id: '5', next: null, value: 5 },
          ],
        },
        linkedListTwo: {
          head: '9',
          nodes: [{ id: '9', next: null, value: 9 }],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '1-3', value: 1 },
            { id: '1-3', next: null, value: 1 },
          ],
        },
        linkedListTwo: {
          head: '9',
          nodes: [
            { id: '9', next: '9-2', value: 9 },
            { id: '9-2', next: '9-3', value: 9 },
            { id: '9-3', next: null, value: 9 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: null, value: 3 },
          ],
        },
        linkedListTwo: {
          head: '6',
          nodes: [
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '9', value: 7 },
            { id: '9', next: '1', value: 9 },
            { id: '1', next: '8', value: 1 },
            { id: '8', next: null, value: 8 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '0',
          nodes: [{ id: '0', next: null, value: 0 }],
        },
        linkedListTwo: {
          head: '0',
          nodes: [{ id: '0', next: null, value: 0 }],
        },
      },
      {
        linkedListOne: {
          head: '0',
          nodes: [{ id: '0', next: null, value: 0 }],
        },
        linkedListTwo: {
          head: '0',
          nodes: [
            { id: '0', next: '0-2', value: 0 },
            { id: '0-2', next: '0-3', value: 0 },
            { id: '0-3', next: '0-4', value: 0 },
            { id: '0-4', next: '0-5', value: 0 },
            { id: '0-5', next: '8', value: 0 },
            { id: '8', next: null, value: 8 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '4',
          nodes: [
            { id: '4', next: '6', value: 4 },
            { id: '6', next: '9', value: 6 },
            { id: '9', next: '3', value: 9 },
            { id: '3', next: '1', value: 3 },
            { id: '1', next: null, value: 1 },
          ],
        },
        linkedListTwo: {
          head: '0',
          nodes: [
            { id: '0', next: '0-2', value: 0 },
            { id: '0-2', next: '0-3', value: 0 },
            { id: '0-3', next: '0-4', value: 0 },
            { id: '0-4', next: '2', value: 0 },
            { id: '2', next: '7', value: 2 },
            { id: '7', next: null, value: 7 },
          ],
        },
      },
    ],
  },
  {
    id: 'zip-linked-list',
    name: 'Zip Linked List',
    category: 'Linked Lists',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  You\'re given the head of a Singly Linked List of arbitrary length\n  <span>k</span>. Write a function that zips the Linked List in place (i.e.,\n  doesn\'t create a brand new list) and returns its head.\n</p>\n<p>\n  A Linked List is zipped if its nodes are in the following order, where\n  <span>k</span> is the length of the Linked List:\n</p>\n<pre>\n1st node -> kth node -> 2nd node -> (k - 1)th node -> 3rd node -> (k - 2)th node -> ...\n</pre>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<p>\n  You can assume that the input Linked List will always have at least one node;\n  in other words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">linkedList</span> = 1 -> 2 -> 3 -> 4 -> 5 -> 6 <span class="CodeEditor-promptComment">// the head node with value 1 </span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 -> 6 -> 2 -> 5 -> 3 -> 4 <span class="CodeEditor-promptComment">// the head node with value 1</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  Try to imagine how you would solve this problem if you were given two distinct\n  linked lists. For example, how would you zip the list\n  <span>1 -> 2 -> 3</span> with the list <span>4 -> 5</span> to get\n  <span>1 -> 5 -> 2 -> 4 -> 3</span>?\n</p>\n',
      '\n<p>\n  One of the most straightforward ways to solve this problem is to split the\n  original linked list into two linked lists and to reverse the second linked\n  list before interweaving it with the first one. Ultimately, you want the first\n  node, then the kth node, then the second node, etc., so reversing the second\n  linked list before interweaving it with the first one makes things simple.\n</p>\n',
      "\n<p>\n  After you split the linked list into two halves and reverse the second half,\n  you'll have something like <span>1 -> 2 -> 3</span> and <span>5 -> 4</span>;\n  at this point, you can simply add the first node of the reversed second half\n  into the first half between <span>1</span> and <span>2</span> as in\n  <span>1 -> 5 -> 2...</span>. Simply continue this process until you've\n  inserted all of the nodes from the reversed second half into the first.\n</p>",
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: null, value: 6 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction zipLinkedList(linkedList) {\n  // Write your code here.\n  return linkedList;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.zipLinkedList = zipLinkedList;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the length of the Linked List\nfunction zipLinkedList(linkedList) {\n  if (linkedList.next === null || linkedList.next.next === null) return linkedList;\n\n  const firstHalfHead = linkedList;\n  const secondHalfHead = splitLinkedList(linkedList);\n\n  const reversedSecondHalfHead = reverseLinkedList(secondHalfHead);\n\n  return interweaveLinkedLists(firstHalfHead, reversedSecondHalfHead);\n}\n\nfunction splitLinkedList(linkedList) {\n  let slowIterator = linkedList;\n  let fastIterator = linkedList;\n  while (fastIterator !== null && fastIterator.next !== null) {\n    slowIterator = slowIterator.next;\n    fastIterator = fastIterator.next.next;\n  }\n\n  const secondHalfHead = slowIterator.next;\n  slowIterator.next = null;\n  return secondHalfHead;\n}\n\nfunction interweaveLinkedLists(linkedList1, linkedList2) {\n  let linkedList1Iterator = linkedList1;\n  let linkedList2Iterator = linkedList2;\n  while (linkedList1Iterator !== null && linkedList2Iterator !== null) {\n    const linkedList1IteratorNext = linkedList1Iterator.next;\n    const linkedList2IteratorNext = linkedList2Iterator.next;\n\n    linkedList1Iterator.next = linkedList2Iterator;\n    linkedList2Iterator.next = linkedList1IteratorNext;\n\n    linkedList1Iterator = linkedList1IteratorNext;\n    linkedList2Iterator = linkedList2IteratorNext;\n  }\n\n  return linkedList1;\n}\n\nfunction reverseLinkedList(head) {\n  let previousNode = null;\n  let currentNode = head;\n  while (currentNode !== null) {\n    const nextNode = currentNode.next;\n    currentNode.next = previousNode;\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n  return previousNode;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.zipLinkedList = zipLinkedList;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const head = new LinkedList(1).addMany([2, 3, 4, 5, 6]);\n  const expected = [1, 6, 2, 5, 3, 4];\n  const actual = program.zipLinkedList(head).getNodesInArray();\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n\n  getNodesInArray() {\n    const nodes = [];\n    let current = this;\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.next;\n    }\n    return nodes;\n  }\n}\n\nit('Test Case #1', function () {\n  const head = new LinkedList(1).addMany([2, 3, 4, 5, 6]);\n  const expected = [1, 6, 2, 5, 3, 4];\n  const actual = program.zipLinkedList(head).getNodesInArray();\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input Linked List',
    tests: [
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: null, value: 6 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: null, value: 7 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: null, value: 3 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: null, value: 2 },
          ],
        },
      },
      { linkedList: { head: '1', nodes: [{ id: '1', next: null, value: 1 }] } },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: '11', value: 10 },
            { id: '11', next: null, value: 11 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '-6', value: 1 },
            { id: '-6', next: '8', value: -6 },
            { id: '8', next: '5', value: 8 },
            { id: '5', next: '10', value: 5 },
            { id: '10', next: '-1', value: 10 },
            { id: '-1', next: '0', value: -1 },
            { id: '0', next: '2', value: 0 },
            { id: '2', next: '11', value: 2 },
            { id: '11', next: '-100', value: 11 },
            { id: '-100', next: '99', value: -100 },
            { id: '99', next: null, value: 99 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '-6', value: 1 },
            { id: '-6', next: '8', value: -6 },
            { id: '8', next: '5', value: 8 },
            { id: '5', next: '10', value: 5 },
            { id: '10', next: '-1', value: 10 },
            { id: '-1', next: '0', value: -1 },
            { id: '0', next: '2', value: 0 },
            { id: '2', next: '11', value: 2 },
            { id: '11', next: '-100', value: 11 },
            { id: '-100', next: '99', value: -100 },
            { id: '99', next: '50', value: 99 },
            { id: '50', next: null, value: 50 },
          ],
        },
      },
    ],
  },
  {
    id: 'node-swap',
    name: 'Node Swap',
    category: 'Linked Lists',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the head of a Singly Linked List, swaps every\n  pair of adjacent nodes in place (i.e., doesn\'t create a brand new list), and\n  returns its new head.\n</p>\n<p>\n  If the input Linked List has an odd number of nodes, its final node should\n  remain the same.\n</p>\n<p>\n  Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n  a <span>next</span> node pointing to the next node in the list or to\n  <span>None</span> / <span>null</span> if it\'s the tail of the list.\n</p>\n<p>\n  You can assume that the input Linked List will always have at least one node;\n  in other words, the head will never be <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">head</span> = 0 -> 1 -> 2 -> 3 -> 4 -> 5 <span class="CodeEditor-promptComment">// the head node with value 0</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\n1 -> 0 -> 3 -> 2 -> 5 -> 4 <span class="CodeEditor-promptComment">// the new head node with value 1</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  Each node in the linked list points to the next node in the linked list. How\n  would you modify the <span>next</span> pointers of two nodes in order to swap\n  them?\n</p>\n',
      '\n<p>\n  Can you apply what you come up with from Hint #1 in order to solve this\n  problem recursively?\n</p>\n',
      '\n<p>\n  To solve this problem recursively, have each recursive call swap a pair of\n  nodes and then return the first node of the swapped pair (the node that was\n  originally the second node in the pair). Also, have each recursive call make\n  the second node of the swapped pair (the node that was originally the first\n  node in the pair) point to the result of the next recursive call. The next\n  recursive call should take in the first node of the next pair as its input\n  parameter.\n</p>\n',
      "\n<p>\n  Implementing this problem iteratively can improve the space complexity of the\n  solution. Intuitively, you need swap nodes while traversing the entire linked\n  list. To do this, you'll need to reference and change the pointers of three\n  nodes at a time. You'll also need to create a placeholder node that points to\n  the head of the linked list, so that at the end of the traversal, you can\n  still reference the new head that you have to return.\n</p>",
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nfunction nodeSwap(head) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the lines below.\nexports.nodeSwap = nodeSwap;\nexports.LinkedList = LinkedList;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Linked List\nfunction nodeSwap(head) {\n  if (head === null || head.next === null) return head;\n\n  const nextNode = head.next;\n  head.next = nodeSwap(head.next.next);\n  nextNode.next = head;\n  return nextNode;\n}\n\n// Do not edit the lines below.\nexports.nodeSwap = nodeSwap;\nexports.LinkedList = LinkedList;\n',
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the Linked List\nfunction nodeSwap(head) {\n  const tempNode = new LinkedList(0);\n  tempNode.next = head;\n\n  let prevNode = tempNode;\n  while (prevNode.next !== null && prevNode.next.next !== null) {\n    const firstNode = prevNode.next;\n    const secondNode = prevNode.next.next;\n    // prevNode -> firstNode -> secondNode -> x\n\n    firstNode.next = secondNode.next;\n    secondNode.next = firstNode;\n    prevNode.next = secondNode;\n    // prevNode -> secondNode -> firstNode -> x\n\n    prevNode = firstNode;\n  }\n\n  return tempNode.next;\n}\n\n// Do not edit the lines below.\nexports.nodeSwap = nodeSwap;\nexports.LinkedList = LinkedList;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n}\n\nfunction getNodesInArray(linkedList) {\n  const nodes = [];\n  let current = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new LinkedList(0).addMany([1, 2, 3, 4, 5]);\n  const expectedNodes = [1, 0, 3, 2, 5, 4];\n  const actual = program.nodeSwap(linkedList);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(expectedNodes);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass LinkedList extends program.LinkedList {\n  addMany(values) {\n    let current = this;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    for (const value of values) {\n      current.next = new LinkedList(value);\n      current = current.next;\n    }\n    return this;\n  }\n}\n\nfunction getNodesInArray(linkedList) {\n  const nodes = [];\n  let current = linkedList;\n  while (current !== null) {\n    nodes.push(current.value);\n    current = current.next;\n  }\n  return nodes;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new LinkedList(0).addMany([1, 2, 3, 4, 5]);\n  const expectedNodes = [1, 0, 3, 2, 5, 4];\n  const actual = program.nodeSwap(linkedList);\n  chai.expect(getNodesInArray(actual)).to.deep.equal(expectedNodes);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Linked List',
    tests: [
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: null, value: 5 },
          ],
        },
      },
      { linkedList: { head: '0', nodes: [{ id: '0', next: null, value: 0 }] } },
      {
        linkedList: {
          head: '0',
          nodes: [
            { id: '0', next: '1', value: 0 },
            { id: '1', next: null, value: 1 },
          ],
        },
      },
      {
        linkedList: {
          head: '5',
          nodes: [
            { id: '5', next: '10', value: 5 },
            { id: '10', next: '15', value: 10 },
            { id: '15', next: '20', value: 15 },
            { id: '20', next: '25', value: 20 },
            { id: '25', next: '30', value: 25 },
            { id: '30', next: null, value: 30 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '3', value: 1 },
            { id: '3', next: '9', value: 3 },
            { id: '9', next: '6', value: 9 },
            { id: '6', next: '20', value: 6 },
            { id: '20', next: '4', value: 20 },
            { id: '4', next: null, value: 4 },
          ],
        },
      },
      {
        linkedList: {
          head: '5',
          nodes: [
            { id: '5', next: '4', value: 5 },
            { id: '4', next: '3', value: 4 },
            { id: '3', next: '2', value: 3 },
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '0', value: 1 },
            { id: '0', next: null, value: 0 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: '11', value: 10 },
            { id: '11', next: '12', value: 11 },
            { id: '12', next: '13', value: 12 },
            { id: '13', next: '14', value: 13 },
            { id: '14', next: '15', value: 14 },
            { id: '15', next: null, value: 15 },
          ],
        },
      },
      {
        linkedList: {
          head: '10',
          nodes: [
            { id: '10', next: '20', value: 10 },
            { id: '20', next: '30', value: 20 },
            { id: '30', next: null, value: 30 },
          ],
        },
      },
      {
        linkedList: {
          head: '30',
          nodes: [
            { id: '30', next: '10', value: 30 },
            { id: '10', next: '20', value: 10 },
            { id: '20', next: null, value: 20 },
          ],
        },
      },
      {
        linkedList: {
          head: '2',
          nodes: [
            { id: '2', next: '1', value: 2 },
            { id: '1', next: '4', value: 1 },
            { id: '4', next: '3', value: 4 },
            { id: '3', next: '6', value: 3 },
            { id: '6', next: '5', value: 6 },
            { id: '5', next: '8', value: 5 },
            { id: '8', next: '7', value: 8 },
            { id: '7', next: '10', value: 7 },
            { id: '10', next: '9', value: 10 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
    ],
  },
  {
    id: 'min-heap-construction',
    name: 'Min Heap Construction',
    category: 'Heaps',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>Implement a <span>MinHeap</span> class that supports:</p>\n<ul>\n  <li>Building a Min Heap from an input array of integers.</li>\n  <li>Inserting integers in the heap.</li>\n  <li>Removing the heap\'s minimum / root value.</li>\n  <li>Peeking at the heap\'s minimum / root value.</li>\n  <li>\n    Sifting integers up and down the heap, which is to be used when inserting\n    and removing values.\n  </li>\n</ul>\n<p>Note that the heap should be represented in the form of an array.</p>\n<p>\n  If you\'re unfamiliar with Min Heaps, we recommend watching the\n  Conceptual Overview section of this question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41]\n\n<span class="CodeEditor-promptComment">// All operations below are performed sequentially.</span>\n<span class="CodeEditor-promptParameter">MinHeap</span>(array): - <span class="CodeEditor-promptComment">// instantiate a MinHeap (calls the buildHeap method and populates the heap)</span>\n<span class="CodeEditor-promptParameter">buildHeap</span>(array): - <span class="CodeEditor-promptComment">[-5, 2, 6, 7, 8, 8, 24, 391, 24, 56, 12, 24, 48, 41]</span>\n<span class="CodeEditor-promptParameter">insert</span>(76): - <span class="CodeEditor-promptComment">[-5, 2, 6, 7, 8, 8, 24, 391, 24, 56, 12, 24, 48, 41, 76]</span>\n<span class="CodeEditor-promptParameter">peek</span>(): -5\n<span class="CodeEditor-promptParameter">remove</span>(): -5 <span class="CodeEditor-promptComment">[2, 7, 6, 24, 8, 8, 24, 391, 76, 56, 12, 24, 48, 41]</span>\n<span class="CodeEditor-promptParameter">peek</span>(): 2\n<span class="CodeEditor-promptParameter">remove</span>(): 2 <span class="CodeEditor-promptComment">[6, 7, 8, 24, 8, 24, 24, 391, 76, 56, 12, 41, 48]</span>\n<span class="CodeEditor-promptParameter">peek</span>(): 6\n<span class="CodeEditor-promptParameter">insert</span>(87): - <span class="CodeEditor-promptComment">[6, 7, 8, 24, 8, 24, 24, 391, 76, 56, 12, 41, 48, 87]</span>\n</pre>\n</div>',
    hints: [
      "<p>\nFor the buildHeap(), remove(), and insert() methods of the Heap, you will need to use the siftDown() and siftUp() methods. These two methods should essentially allow you to take any node in the heap and move it either down or up in the heap until it's in its final, appropriate position. This can be done by comparing the node in question to its child nodes in the case of siftDown() or to its parent node in the case of siftUp().\n</p>\n",
      "\n<p>\nIn an array-based Heap, you can easily access a node's children nodes and parent node by using the nodes' indices. If a node is located at index i, then its children nodes are located at indices 2 * i + 1 and 2 * i + 2, and its parent node is located at index Math.floor((i - 1) / 2).\n</p>\n",
      '\n<p>\nTo implement the buildHeap() method, you can either sift every node in the input array down to its final, correct position, or you can sift every node in the input array up to its final, correct position. What are the runtime implications of both approaches? Which methods (siftDown() or siftUp()) will insert() and remove() utilize? What about peek()?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      {
        name: 'classMethodsToCall',
        example: [
          { arguments: [76], method: 'insert' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'peek' },
          { arguments: [87], method: 'insert' },
        ],
        schema: {
          description:
            'These methods will be called in the order that they appear in below\non a <span>MinHeap</span> built from the <span>array</span> and with their respective arguments.\n',
          items: {
            properties: {
              arguments: { maxItems: 1, type: 'array' },
              method: { enum: ['insert', 'peek', 'remove'], type: 'string' },
            },
            required: ['method', 'arguments'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Do not edit the class below except for the buildHeap,\n// siftDown, siftUp, peek, remove, and insert methods.\n// Feel free to add new properties and methods to the class.\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  buildHeap(array) {\n    // Write your code here.\n  }\n\n  siftDown() {\n    // Write your code here.\n  }\n\n  siftUp() {\n    // Write your code here.\n  }\n\n  peek() {\n    // Write your code here.\n  }\n\n  remove() {\n    // Write your code here.\n  }\n\n  insert(value) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.MinHeap = MinHeap;\n',
      solutions: [
        'class MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap] < heap[currentIdx]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx] < heap[parentIdx]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.heap[0];\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\n// Do not edit the line below.\nexports.MinHeap = MinHeap;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst isMinHeapPropertySatisfied = array => {\n  for (let currentIdx = 1; currentIdx < array.length; currentIdx++) {\n    const parentIdx = Math.floor((currentIdx - 1) / 2);\n    if (array[parentIdx] > array[currentIdx]) return false;\n  }\n  return true;\n};\n\nit('Test Case #1', function () {\n  const minHeap = new program.MinHeap([48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41]);\n  minHeap.insert(76);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(-5);\n  chai.expect(minHeap.remove()).to.deep.equal(-5);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(2);\n  chai.expect(minHeap.remove()).to.deep.equal(2);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(6);\n  minHeap.insert(87);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst isMinHeapPropertySatisfied = array => {\n  for (let currentIdx = 1; currentIdx < array.length; currentIdx++) {\n    const parentIdx = Math.floor((currentIdx - 1) / 2);\n    if (array[parentIdx] > array[currentIdx]) return false;\n  }\n  return true;\n};\n\nit('Test Case #1', function () {\n  const minHeap = new program.MinHeap([48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41]);\n  minHeap.insert(76);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(-5);\n  chai.expect(minHeap.remove()).to.deep.equal(-5);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(2);\n  chai.expect(minHeap.remove()).to.deep.equal(2);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n  chai.expect(minHeap.peek()).to.deep.equal(6);\n  minHeap.insert(87);\n  chai.expect(isMinHeapPropertySatisfied(minHeap.heap)).to.deep.equal(true);\n});\n",
    },
    bigO: 'BuildHeap: O(n) time | O(1) space - where n is the length of the input array\nSiftDown: O(log(n)) time | O(1) space - where n is the length of the heap\nSiftUp: O(log(n)) time | O(1) space - where n is the length of the heap\nPeek: O(1) | O(1)\nRemove: O(log(n)) time | O(1) space - where n is the length of the heap\nInsert: O(log(n)) time | O(1) space - where n is the length of the heap',
    tests: [
      {
        array: [48, 12, 24, 7, 8, -5, 24, 391, 24, 56, 2, 6, 8, 41],
        classMethodsToCall: [
          { arguments: [76], method: 'insert' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'peek' },
          { arguments: [87], method: 'insert' },
        ],
      },
      {
        array: [2, 3, 1],
        classMethodsToCall: [{ arguments: [], method: 'peek' }],
      },
      {
        array: [1, 2, 3, 4, 5, 6, 7, 8, 9],
        classMethodsToCall: [{ arguments: [], method: 'peek' }],
      },
      {
        array: [
          -4, 5, 10, 8, -10, -6, -4, -2, -5, 3, 5, -4, -5, -1, 1, 6, -7, -6, -7,
          8,
        ],
        classMethodsToCall: [{ arguments: [], method: 'peek' }],
      },
      {
        array: [
          -7, 2, 3, 8, -10, 4, -6, -10, -2, -7, 10, 5, 2, 9, -9, -5, 3, 8,
        ],
        classMethodsToCall: [
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'peek' },
          { arguments: [-8], method: 'insert' },
          { arguments: [], method: 'peek' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'peek' },
          { arguments: [8], method: 'insert' },
          { arguments: [], method: 'peek' },
        ],
      },
      {
        array: [
          427, 787, 222, 996, -359, -614, 246, 230, 107, -706, 568, 9, -246, 12,
          -764, -212, -484, 603, 934, -848, -646, -991, 661, -32, -348, -474,
          -439, -56, 507, 736, 635, -171, -215, 564, -710, 710, 565, 892, 970,
          -755, 55, 821, -3, -153, 240, -160, -610, -583, -27, 131,
        ],
        classMethodsToCall: [{ arguments: [], method: 'peek' }],
      },
      {
        array: [
          991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998, 847,
          80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435, -269,
          652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980, 913,
          -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519, 906,
        ],
        classMethodsToCall: [
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'remove' },
          { arguments: [992], method: 'insert' },
        ],
      },
      {
        array: [
          544, -578, 556, 713, -655, -359, -810, -731, 194, -531, -685, 689,
          -279, -738, 886, -54, -320, -500, 738, 445, -401, 993, -753, 329,
          -396, -924, -975, 376, 748, -356, 972, 459, 399, 669, -488, 568, -702,
          551, 763, -90, -249, -45, 452, -917, 394, 195, -877, 153, 153, 788,
          844, 867, 266, -739, 904, -154, -947, 464, 343, -312, 150, -656, 528,
          61, 94, -581,
        ],
        classMethodsToCall: [{ arguments: [], method: 'peek' }],
      },
      {
        array: [
          -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
          842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
          -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
          892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
          341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800, -950,
          -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265, 746, 355,
          -578, -441, -254, -941, -738, -469, -167, -420, -126, -410, 59,
        ],
        classMethodsToCall: [
          { arguments: [2], method: 'insert' },
          { arguments: [22], method: 'insert' },
          { arguments: [222], method: 'insert' },
          { arguments: [2222], method: 'insert' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'remove' },
          { arguments: [], method: 'remove' },
        ],
      },
    ],
  },
  {
    id: 'continuous-median',
    name: 'Continuous Median',
    category: 'Heaps',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>Write a <span>ContinuousMedianHandler</span> class that supports:</p>\n<ul>\n  <li>\n    The continuous insertion of numbers with the <span>insert</span> method.\n  </li>\n  <li>\n    The instant (O(1) time) retrieval of the median of the numbers that have\n    been inserted thus far with the <span>getMedian</span> method.\n  </li>\n</ul>\n<p>\n  The <span>getMedian</span> method has already been written for you. You simply\n  have to write the <span>insert</span> method.\n</p>\n<p>\n  The median of a set of numbers is the "middle" number when the numbers are\n  ordered from smallest to greatest. If there\'s an odd number of numbers in the\n  set, as in <span>{1, 3, 7}</span>, the median is the number in the middle\n  (<span>3</span> in this case); if there\'s an even number of numbers in the\n  set, as in <span>{1, 3, 7, 8}</span>, the median is the average of the two\n  middle numbers (<span>(3 + 7) / 2 == 5</span> in this case).\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class="CodeEditor-promptComment">// All operations below are performed sequentially.</span>\n<span class="CodeEditor-promptParameter">ContinuousMedianHandler</span>(): - <span class="CodeEditor-promptComment">// instantiate a ContinuousMedianHandler</span>\n<span class="CodeEditor-promptParameter">insert</span>(5): -\n<span class="CodeEditor-promptParameter">insert</span>(10): -\n<span class="CodeEditor-promptParameter">getMedian</span>(): 7.5\n<span class="CodeEditor-promptParameter">insert</span>(100): -\n<span class="CodeEditor-promptParameter">getMedian</span>(): 10\n</pre>\n</div>',
    hints: [
      '<p>\nThe median of a set of numbers is often, by definition, one of the numbers in the set. Thus, you likely have to store all of the inserted numbers somewhere to be able to continuously compute their median.\n</p>\n',
      '\n<p>\nThe median of a set of numbers is either the middle number of that set (if the set has an odd amount of numbers) or the average of the middle numbers (if the set has an even amount of numbers). This means that if you could somehow keep track of the middle number(s) of the set of inserted numbers, you could easily compute the median by finding the indices of the middle numbers and doing some simple calculations. Perhaps storing all of the numbers in a sorted array could work, but what would be the runtime implication of inserting each new number into a sorted array?\n</p>\n',
      '\n<p>\nRealizing that you only need to keep track of the middle numbers in the set of inserted numbers to compute the median, try keeping track of two subsets of the numbers: a max-heap of the lower half of the numbers and a min-heap of the greater half of the numbers. Any time you insert a number, pick the heap to place it in by comparing it to the max / min values of the heaps. Then, re-balance the heaps in an effort to keep their sizes apart by at most one. Doing so will allow you to access the middle number(s) of the set of inserted numbers very easily, which will make calculating the median a trivial computation. Re-balancing the heaps can be accomplished by simply removing a value from the larger heap and inserting it in the smaller one. What are the runtime implications of all these operations?\n</p>',
    ],
    customInputVars: [
      {
        name: 'classMethodsToCall',
        example: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [100], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
        schema: {
          description:
            'These methods will be called in the order that they appear in below\non a <span>ContinuousMedianHandler</span> and with their respective arguments.\n',
          items: {
            properties: {
              arguments: { maxItems: 1, type: 'array' },
              method: { enum: ['getMedian', 'insert'], type: 'string' },
            },
            required: ['method', 'arguments'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Do not edit the class below except for\n// the insert method. Feel free to add new\n// properties and methods to the class.\nclass ContinuousMedianHandler {\n  constructor() {\n    // Write your code here.\n    this.median = null;\n  }\n\n  insert(number) {\n    // Write your code here.\n  }\n\n  getMedian() {\n    return this.median;\n  }\n}\n\n// Do not edit the line below.\nexports.ContinuousMedianHandler = ContinuousMedianHandler;\n',
      solutions: [
        'class ContinuousMedianHandler {\n  constructor() {\n    this.lowers = new Heap(MAX_HEAP_FUNC, []);\n    this.greaters = new Heap(MIN_HEAP_FUNC, []);\n    this.median = null;\n  }\n\n  // O(log(n)) time | O(n) space\n  insert(number) {\n    if (!this.lowers.length || number < this.lowers.peek()) {\n      this.lowers.insert(number);\n    } else {\n      this.greaters.insert(number);\n    }\n    this.rebalanceHeaps();\n    this.updateMedian();\n  }\n\n  rebalanceHeaps() {\n    if (this.lowers.length - this.greaters.length === 2) {\n      this.greaters.insert(this.lowers.remove());\n    } else if (this.greaters.length - this.lowers.length === 2) {\n      this.lowers.insert(this.greaters.remove());\n    }\n  }\n\n  updateMedian() {\n    if (this.lowers.length === this.greaters.length) {\n      this.median = (this.lowers.peek() + this.greaters.peek()) / 2;\n    } else if (this.lowers.length > this.greaters.length) {\n      this.median = this.lowers.peek();\n    } else {\n      this.median = this.greaters.peek();\n    }\n  }\n\n  getMedian() {\n    return this.median;\n  }\n}\n\nclass Heap {\n  constructor(comparisonFunc, array) {\n    this.comparisonFunc = comparisonFunc;\n    this.heap = this.buildHeap(array);\n    this.length = this.heap.length;\n  }\n\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1) {\n        if (this.comparisonFunc(heap[childTwoIdx], heap[childOneIdx])) {\n          idxToSwap = childTwoIdx;\n        } else {\n          idxToSwap = childOneIdx;\n        }\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (this.comparisonFunc(heap[idxToSwap], heap[currentIdx])) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0) {\n      if (this.comparisonFunc(heap[currentIdx], heap[parentIdx])) {\n        this.swap(currentIdx, parentIdx, heap);\n        currentIdx = parentIdx;\n        parentIdx = Math.floor((currentIdx - 1) / 2);\n      } else {\n        return;\n      }\n    }\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  remove() {\n    this.swap(0, this.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.length--;\n    this.siftDown(0, this.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  insert(value) {\n    this.heap.push(value);\n    this.length++;\n    this.siftUp(this.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\nfunction MAX_HEAP_FUNC(a, b) {\n  return a > b;\n}\n\nfunction MIN_HEAP_FUNC(a, b) {\n  return a < b;\n}\n\nexports.ContinuousMedianHandler = ContinuousMedianHandler;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const handler = new program.ContinuousMedianHandler();\n  handler.insert(5);\n  handler.insert(10);\n  chai.expect(handler.getMedian()).to.deep.equal(7.5);\n  handler.insert(100);\n  chai.expect(handler.getMedian()).to.deep.equal(10);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const handler = new program.ContinuousMedianHandler();\n  handler.insert(5);\n  handler.insert(10);\n  chai.expect(handler.getMedian()).to.deep.equal(7.5);\n  handler.insert(100);\n  chai.expect(handler.getMedian()).to.deep.equal(10);\n});\n",
    },
    bigO: 'Insert: O(log(n)) time | O(n) space - where n is the number of inserted numbers',
    tests: [
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [100], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [10], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [100], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [200], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [100], method: 'insert' },
          { arguments: [200], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [13], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [100], method: 'insert' },
          { arguments: [200], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [50], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [100], method: 'insert' },
          { arguments: [200], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [50], method: 'insert' },
          { arguments: [51], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [52], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [100], method: 'insert' },
          { arguments: [200], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [50], method: 'insert' },
          { arguments: [51], method: 'insert' },
          { arguments: [52], method: 'insert' },
          { arguments: [1000], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [10000], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [100], method: 'insert' },
          { arguments: [200], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [50], method: 'insert' },
          { arguments: [51], method: 'insert' },
          { arguments: [52], method: 'insert' },
          { arguments: [1000], method: 'insert' },
          { arguments: [10000], method: 'insert' },
          { arguments: [10001], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [10002], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [100], method: 'insert' },
          { arguments: [200], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [50], method: 'insert' },
          { arguments: [51], method: 'insert' },
          { arguments: [52], method: 'insert' },
          { arguments: [1000], method: 'insert' },
          { arguments: [10000], method: 'insert' },
          { arguments: [10001], method: 'insert' },
          { arguments: [10002], method: 'insert' },
          { arguments: [10003], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [10004], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [100], method: 'insert' },
          { arguments: [200], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [50], method: 'insert' },
          { arguments: [51], method: 'insert' },
          { arguments: [52], method: 'insert' },
          { arguments: [1000], method: 'insert' },
          { arguments: [10000], method: 'insert' },
          { arguments: [10001], method: 'insert' },
          { arguments: [10002], method: 'insert' },
          { arguments: [10003], method: 'insert' },
          { arguments: [10004], method: 'insert' },
          { arguments: [75], method: 'insert' },
          { arguments: [], method: 'getMedian' },
          { arguments: [80], method: 'insert' },
          { arguments: [], method: 'getMedian' },
        ],
      },
    ],
  },
  {
    id: 'merge-sorted-arrays',
    name: 'Merge Sorted Arrays',
    category: 'Heaps',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty list of non-empty sorted arrays of\n  integers and returns a merged list of all of those arrays.\n</p>\n<p>The integers in the merged list should be in sorted order.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">arrays</span> = [\n  [1, 5, 9, 21],\n  [-1, 0],\n  [-124, 81, 121],\n  [3, 6, 12, 20, 150],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]\n</pre>\n</div>',
    hints: [
      '<p>\nIf you were given just two sorted lists of numbers in real life, what steps would you take to merge them into a single sorted list? Apply the same process to k sorted lists.\n</p>\n',
      "\n<p>\nThe first element in each array is the smallest element in the respective array; to find the first element to add to the final sorted list, pick the smallest integer out of all of the smallest elements. Once you've found the smallest integer, move one position forward in the array that it came from and continue applying this logic until you run out of elements.\n</p>\n",
      '\n<p>\nThe approach described in Hint #2 involves repeatedly finding the smallest of k elements, since there are k arrays. Doing so can be naively implemented using a simple loop through the k relevant elements, which results in an O(k)-time operation. Can you speed up this operation by using a specific data structure that lends itself to quickly finding the minimum value in a set of values.\n</p>\n',
      '\n<p>\nFollow the approach described in Hint #2, using a Min Heap to store the k smallest elements at any given point in your algorithm.\n</p>',
    ],
    customInputVars: [
      {
        name: 'arrays',
        example: [
          [1, 5, 9, 21],
          [-1, 0],
          [-124, 81, 121],
          [3, 6, 12, 20, 150],
        ],
        schema: {
          items: { items: { type: 'integer' }, minItems: 1, type: 'array' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function mergeSortedArrays(arrays) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.mergeSortedArrays = mergeSortedArrays;\n',
      solutions: [
        '// O(nk) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nfunction mergeSortedArrays(arrays) {\n  const sortedList = [];\n  const elementIdxs = arrays.map(() => 0);\n  while (true) {\n    const smallestItems = [];\n    for (let arrayIdx = 0; arrayIdx < arrays.length; arrayIdx++) {\n      const relevantArray = arrays[arrayIdx];\n      const elementIdx = elementIdxs[arrayIdx];\n      if (elementIdx === relevantArray.length) continue;\n      smallestItems.push({\n        arrayIdx,\n        num: relevantArray[elementIdx],\n      });\n    }\n    if (smallestItems.length === 0) break;\n    const nextItem = getMinValue(smallestItems);\n    sortedList.push(nextItem.num);\n    elementIdxs[nextItem.arrayIdx]++;\n  }\n  return sortedList;\n}\n\nfunction getMinValue(items) {\n  let minValueIdx = 0;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].num < items[minValueIdx].num) minValueIdx = i;\n  }\n  return items[minValueIdx];\n}\n\nexports.mergeSortedArrays = mergeSortedArrays;\n',
        '// O(nlog(k) + k) time | O(n + k) space - where n is the total\n// number of array elements and k is the number of arrays\nfunction mergeSortedArrays(arrays) {\n  const sortedList = [];\n  const smallestItems = [];\n  for (let arrayIdx = 0; arrayIdx < arrays.length; arrayIdx++) {\n    smallestItems.push({\n      arrayIdx,\n      elementIdx: 0,\n      num: arrays[arrayIdx][0],\n    });\n  }\n  const minHeap = new MinHeap(smallestItems);\n  while (!minHeap.isEmpty()) {\n    const smallestItem = minHeap.remove();\n    const {arrayIdx, elementIdx, num} = smallestItem;\n    sortedList.push(num);\n    if (elementIdx === arrays[arrayIdx].length - 1) continue;\n    minHeap.insert({\n      arrayIdx,\n      elementIdx: elementIdx + 1,\n      num: arrays[arrayIdx][elementIdx + 1],\n    });\n  }\n  return sortedList;\n}\n\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx].num < heap[childOneIdx].num) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].num < heap[currentIdx].num) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx].num < heap[parentIdx].num) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\nexports.mergeSortedArrays = mergeSortedArrays;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const arrays = [\n    [1, 5, 9, 21],\n    [-1, 0],\n    [-124, 81, 121],\n    [3, 6, 12, 20, 150],\n  ];\n  const output = program.mergeSortedArrays(arrays);\n  chai.expect(output).to.deep.equal([-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const arrays = [\n    [1, 5, 9, 21],\n    [-1, 0],\n    [-124, 81, 121],\n    [3, 6, 12, 20, 150],\n  ];\n  const output = program.mergeSortedArrays(arrays);\n  chai.expect(output).to.deep.equal([-124, -1, 0, 1, 3, 5, 6, 9, 12, 20, 21, 81, 121, 150]);\n});\n",
    },
    bigO: 'O(nlog(k) + k) time | O(n + k) space - where where n is the total number of array elements and k is the number of arrays',
    tests: [
      {
        arrays: [
          [1, 5, 9, 21],
          [-1, 0],
          [-124, 81, 121],
          [3, 6, 12, 20, 150],
        ],
      },
      {
        arrays: [
          [-92, -78, -68, 43, 46, 46, 79, 79],
          [-66, -49, -26, -16, 21, 28, 33, 50],
          [-40, -8, 12, 20, 36, 38, 81],
          [-76, -74, -62, -46, -23, 33, 42, 48, 55, 94],
        ],
      },
      {
        arrays: [
          [-95, -74, 1],
          [-28, 28, 95],
          [-89, -78, -67, -66, -25, -22, 2, 38],
          [-86, -35, -25, -13, 41],
          [-85, -77, -21, 72],
          [-55, 4, 84, 98],
          [-75, -73, 22],
        ],
      },
      {
        arrays: [
          [-79, -43, -15, 89],
          [-48, 13, 20],
          [-33, -19, -8, 12, 40, 44, 50, 52, 91, 95],
          [-100, -43, -8, 17],
          [-15, 81],
        ],
      },
      {
        arrays: [
          [-88, -56, -43, -41, -13, -8, 82],
          [-38, 53],
          [-75, -48, -42, -27, 20, 35, 55],
          [-55, -50, -48, -45, 62, 69, 77],
          [-90, -27, -22, -19, -6, -3, 4, 6, 91],
          [-86, -67, -66, 2, 8, 8, 39, 74],
          [-62, 34, 40, 42, 47, 48, 55, 56, 68, 87],
        ],
      },
      {
        arrays: [
          [-93, -83, -43, -32, -32, -15, -14, 12, 78, 80],
          [-83],
          [-82, -51, -29, 40, 60, 76, 80],
          [50],
          [-33, -16],
          [-100],
          [-33, -11, 23, 29, 29, 43],
          [0, 70],
          [-57, -43, -41, -18, -5, 74],
        ],
      },
      {
        arrays: [
          [98],
          [-87, -79, -56, -33, -20, -10, -5, 19, 49, 86],
          [-73, -49],
          [-98, -63, -47, -4, 21],
          [-56, -43, -24, 8, 34, 80, 83],
          [-83, -65, -61, -30, -26, -16, 16, 19],
          [-91, -42, -21, 91],
          [-73, -62, -56, -30, 11, 67],
          [-91, -90, -40, 32, 94],
        ],
      },
      {
        arrays: [
          [-81, 36, 57, 59],
          [-65, -58, -47, -39, 29, 53, 66, 75, 88, 92],
          [-67, -54, -40, -25, 9, 17, 55, 75, 94],
          [-35, -3, 24, 82],
          [-86, 32, 95],
        ],
      },
      {
        arrays: [
          [-93, -83, -78, -75, -40, -32, 48],
          [-90, -75, -57, 7, 11, 21, 53, 84, 89],
          [-50, -40, -20, 71, 96],
          [-49, 13, 18, 61, 97],
          [42, 96],
        ],
      },
      {
        arrays: [
          [-63, -55, -9, 37, 86, 97],
          [-62, -48, -37, -16, 11, 33, 80, 97],
          [-51, 5, 34],
          [-24, -24, -19, 32, 46, 97],
          [-98, -56, -12, -2, -1, 11, 47, 79],
          [-59, 64, 93, 96],
          [-96, -51, -21, -18, 29, 57, 87, 90, 92],
          [-89, -85, -55, -12, 27],
          [-96, -96, -95, -95, -71, -45, -28, 8, 19, 100],
        ],
      },
      {
        arrays: [
          [49, 72],
          [-95, -49, -18, -16, 1, 16, 36, 40, 75, 92],
          [-77, 11, 65, 91],
        ],
      },
      {
        arrays: [
          [-94, -93, -25, -2, 67, 85],
          [-83, -74, 64],
          [-83, 10, 46, 64],
          [-94, -54, -40, 9, 22, 49],
        ],
      },
      {
        arrays: [
          [-87, -67, -56, -15, 67],
          [-98, -90, -85, -3, 5, 43, 44],
          [-97, -78, -73, -65, -17, 27, 66, 77, 78, 92],
          [-99, -62, 11, 15, 50],
        ],
      },
      {
        arrays: [
          [-79, -77, -48, -39, -27, 10, 39, 61, 83, 99],
          [-93, 10],
          [-98, -90, -44, -33, -5, 40, 69, 90, 96],
          [-93],
          [-32, 9, 14, 20, 85],
        ],
      },
      { arrays: [[14], [-88, -16, 26, 38, 51, 62, 84, 88]] },
      {
        arrays: [
          [-62, -54, -54, 31, 34, 51],
          [-41],
          [33, 34],
          [-98, 68, 83],
          [-25, -14],
        ],
      },
      {
        arrays: [
          [-53, -16, -13, -11, -6, 21, 26, 35],
          [-99, -93, -62, -47, -16, 4, 55, 59, 64, 76],
          [-96, -41, -8],
          [-39, -28, -4],
          [-95, -48, -45, -25, 63, 64, 98],
          [-38, -32, -7, 82],
          [-42, 25, 49, 79, 86],
          [-88, -65, 7, 8, 44],
        ],
      },
      {
        arrays: [
          [-33, 57, 74],
          [-76, -72, -46, -21, -16, -10, 16, 21, 47, 67],
          [-59, -55, -47, -46, -35, 38],
          [-62, -25, 3, 30, 46, 71],
          [-91, -37, -26, -12, -8, 2, 9, 46, 56, 93],
          [-58, 82, 97],
        ],
      },
      {
        arrays: [
          [-64, -51, -5, 1, 6, 12, 27, 32, 62, 88],
          [-66, -65, -60, 17, 22],
          [-57, -7, 13, 70, 79],
          [-88, -86, -73, -59, -36, -12, 11, 48, 58, 99],
          [-71, -28],
          [21, 38],
          [-55, -44, -27],
          [-96, -93, -5, 13],
          [-19, -11, 27, 36, 43, 79, 87],
          [-72, -53, -10, 1, 27, 77, 88],
        ],
      },
      {
        arrays: [
          [-19, 33, 34],
          [-94, -53, -10, -3, 44, 73],
          [27, 42, 70, 86],
          [-28, 91],
          [-53, -27, 31, 77, 96, 99],
        ],
      },
    ],
  },
  {
    id: 'sort-k-sorted-array',
    name: 'Sort K-Sorted Array',
    category: 'Heaps',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-negative integer k and a k-sorted array\n  of integers and returns the sorted version of the array. Your function can\n  either sort the array in place or create an entirely new array.\n</p>\n<p>\n  A k-sorted array is a partially sorted array in which all elements are at most\n  k positions away from their sorted position. For example, the array\n  <span>[3, 1, 2, 2]</span> is k-sorted with <span>k = 3</span>, because each\n  element in the array is at most 3 positions away from its sorted position.\n</p>\n<p>\n  Note that you\'re expected to come up with an algorithm that can sort the\n  k-sorted array faster than in O(nlog(n)) time.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [3, 2, 1, 5, 4, 7, 6, 5]\n<span class="CodeEditor-promptParameter">k</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 2, 3, 4, 5, 5, 6, 7]\n</pre>\n</div>',
    hints: [
      '<p>\nWhat does the k parameter tell you? How can you use it to come up with an algorithm that runs in O(nlog(k))?\n</p>\n',
      '\n<p>\nSince the input array is k-sorted, try repeatedly sorting k elements at a time and inserting the minimum element of all those k elements into its final sorted position in the array.\n</p>\n',
      '\n<p>\nWhat auxiliary data structure would be helpful to quickly determine the minimum element of k elements?\n</p>\n',
      '\n<p>\nAs you iterate through the array, use a min-heap to keep track of the most recent k elements. At each iteration, remove the minimum value from the heap, insert it into its final sorted position in the array, and add the current element in the array to the heap. Continue this process until the heap is empty.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [3, 2, 1, 5, 4, 7, 6, 5],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      { name: 'k', example: 3, schema: { minimum: 0, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function sortKSortedArray(array, k) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.sortKSortedArray = sortKSortedArray;\n',
      solutions: [
        '// O(nlog(k)) time | O(k) space - where n is the number\n// of elements in the array and k is how far away elements\n// are from their sorted position\nfunction sortKSortedArray(array, k) {\n  const minHeapWithKElements = new MinHeap(array.slice(0, Math.min(k + 1, array.length)));\n\n  let nextIndexToInsertElement = 0;\n  for (let idx = k + 1; idx < array.length; idx++) {\n    const minElement = minHeapWithKElements.remove();\n    array[nextIndexToInsertElement] = minElement;\n    nextIndexToInsertElement++;\n\n    const currentElement = array[idx];\n    minHeapWithKElements.insert(currentElement);\n  }\n\n  while (!minHeapWithKElements.isEmpty()) {\n    const minElement = minHeapWithKElements.remove();\n    array[nextIndexToInsertElement] = minElement;\n    nextIndexToInsertElement++;\n  }\n\n  return array;\n}\n\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap] < heap[currentIdx]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx] < heap[parentIdx]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\n// Do not edit the line below.\nexports.sortKSortedArray = sortKSortedArray;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [3, 2, 1, 5, 4, 7, 6, 5];\n  const k = 3;\n  const expected = [1, 2, 3, 4, 5, 5, 6, 7];\n  const actual = program.sortKSortedArray(input, k);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [3, 2, 1, 5, 4, 7, 6, 5];\n  const k = 3;\n  const expected = [1, 2, 3, 4, 5, 5, 6, 7];\n  const actual = program.sortKSortedArray(input, k);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlog(k)) time | O(k) space - where n is the number of elements in the array and k is how far away elements are from their sorted position',
    tests: [
      { array: [3, 2, 1, 5, 4, 7, 6, 5], k: 3 },
      { array: [-1, -3, -4, 2, 1, 3], k: 2 },
      { array: [1, 2, 3, 4, 5], k: 0 },
      { array: [], k: 5 },
      { array: [4, 3, 2, 1, 2, 5, 6], k: 4 },
      { array: [3, 2, 1, 0, 4, 7, 6, 5, 9, 8, 7], k: 3 },
      { array: [2, 1, 4, 3, 5, 6, 8, 7], k: 1 },
      { array: [1, 0, 1, 1, 1, 1, 1, 1], k: 1 },
      { array: [5, 4, 3, 2, -100], k: 5 },
      { array: [3, 3, 2, 1, 6, 4, 4, 5, 9, 7, 8, 11, 12], k: 3 },
      { array: [1], k: 1 },
      { array: [-1, -5], k: 1 },
      { array: [-2, -3, 1, 2, 3, 1, 1, 2, 3, 8, 100, 130, 9, 12], k: 4 },
      { array: [1, 2, 3, 4, 5, 6, 1], k: 8 },
    ],
  },
  {
    id: 'laptop-rentals',
    name: 'Laptop Rentals',
    category: 'Heaps',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a list of time intervals during which students at a school need a\n  laptop. These time intervals are represented by pairs of integers\n  <span>[start, end]</span>, where <span>0 &lt;= start &lt; end</span>. However,\n  <span>start</span> and <span>end</span> don\'t represent real times; therefore,\n  they may be greater than <span>24</span>.\n</p>\n<p>\n  No two students can use a laptop at the same time, but immediately after a\n  student is done using a laptop, another student can use that same laptop. For\n  example, if one student rents a laptop during the time interval\n  <span>[0, 2]</span>, another student can rent the same laptop during any time\n  interval starting with <span>2</span>.\n</p>\n<p>\n  Write a function that returns the minimum number of laptops that the school\n  needs to rent such that all students will always have access to a laptop when\n  they need one.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">times</span> = \n[\n  [0, 2],\n  [1, 4],\n  [4, 6],\n  [0, 4],\n  [7, 8],\n  [9, 11],\n  [3, 10],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3\n</pre>\n</div>',
    hints: [
      '<p>\n  There are many different ways to solve this problem, but only a few of them\n  run in the optimal time. Can you come up with an algorithm that solves this\n  problem in <span>O(nlog(n))</span> time?\n</p>\n',
      "\n<p>\n  Suppose that you're given two time intervals: <span>[s1, e1]</span> and\n  <span>[s2, e2]</span>, where <span>s1 &lt; s2</span>. If\n  <span>e1 &lt;= s2</span>, then the second time interval can use the same\n  laptop as the first time interval.\n</p>\n<p>\n  One method to solve this problem with an optimal time complexity is to use a\n  Min Heap. If you loop through time intervals that have been sorted by their\n  start times and keep track of the smallest end time of time intervals for\n  laptops that have already been rented out, you can determine how many laptops\n  are required. Use the Min Heap to efficiency determine if any previous rental\n  time intervals have ended as you loop through all the time intervals. If a\n  rental time interval is done and another one starts after it, no extra laptop\n  is required.\n</p>\n",
      "\n<p>\n  Another way to efficiently solve this problem is to realize that we don't need\n  to know what start time corresponds with what end time. So long as we know all\n  start times and all end times, we can determine the number of laptops\n  required.\n</p>\n",
      "\n<p>\n  Start by creating two arraysone for start times and one for end timesand\n  sort them both in ascending order. We can simply loop through the start times\n  and end times at the same time and compare the current start time to the\n  current end time. If the current start time is greater than the current end\n  time, then that means a laptop that was previously used is no longer being\n  used and can be given to the student renting a laptop at this starting time.\n  Thus, we can increment both our start-time and end-time pointers and continue\n  without needing an additional laptop. If the current start time is smaller\n  than the current end time, then another rental has started before a previous\n  rental has ended, and we thus require another laptop, so we increment the\n  start pointer and a variable keeping track of the number of laptops required.\n  See the Conceptual Overview section of this question's video explanation for a\n  more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'times',
        example: [
          [0, 2],
          [1, 4],
          [4, 6],
          [0, 4],
          [7, 8],
          [9, 11],
          [3, 10],
        ],
        schema: {
          items: {
            items: { minimum: 0, type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function laptopRentals(times) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.laptopRentals = laptopRentals;\n',
      solutions: [
        '// O(nlog(n)) time | O(n) space - where n is the number of times\nfunction laptopRentals(times) {\n  if (times.length === 0) return 0;\n\n  times.sort((a, b) => a[0] - b[0]);\n\n  const timesWhenLaptopIsUsed = [times[0]];\n  const heap = new MinHeap(timesWhenLaptopIsUsed);\n\n  for (let idx = 1; idx < times.length; idx++) {\n    const currentInterval = times[idx];\n    if (heap.peek()[1] <= currentInterval[0]) heap.remove();\n\n    heap.insert(currentInterval);\n  }\n\n  return timesWhenLaptopIsUsed.length;\n}\n\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx][1] < heap[childOneIdx][1]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap][1] < heap[currentIdx][1]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx][1] < heap[parentIdx][1]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.heap[0];\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\n// Do not edit the lines below.\nexports.laptopRentals = laptopRentals;\nexports.MinHeap = MinHeap;\n',
        '// O(nlog(n)) time | O(n) space - where n is the number of times\nfunction laptopRentals(times) {\n  if (times.length === 0) return 0;\n\n  let usedLaptops = 0;\n  const startTimes = times.map(a => a[0]).sort((a, b) => a - b);\n  const endTimes = times.map(a => a[1]).sort((a, b) => a - b);\n\n  let startIterator = 0;\n  let endIterator = 0;\n\n  while (startIterator < times.length) {\n    if (startTimes[startIterator] >= endTimes[endIterator]) {\n      usedLaptops--;\n      endIterator++;\n    }\n\n    usedLaptops++;\n    startIterator++;\n  }\n\n  return usedLaptops;\n}\n\n// Do not edit the line below.\nexports.laptopRentals = laptopRentals;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, 2],\n    [1, 4],\n    [4, 6],\n    [0, 4],\n    [7, 8],\n    [9, 11],\n    [3, 10],\n  ];\n  const expected = 3;\n  const actual = program.laptopRentals(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, 2],\n    [1, 4],\n    [4, 6],\n    [0, 4],\n    [7, 8],\n    [9, 11],\n    [3, 10],\n  ];\n  const expected = 3;\n  const actual = program.laptopRentals(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlog(n)) time | O(n) space - where n is the number of times',
    tests: [
      {
        times: [
          [0, 2],
          [1, 4],
          [4, 6],
          [0, 4],
          [7, 8],
          [9, 11],
          [3, 10],
        ],
      },
      {
        times: [
          [0, 4],
          [2, 3],
          [2, 3],
          [2, 3],
        ],
      },
      {
        times: [
          [1, 5],
          [5, 6],
          [6, 7],
          [7, 9],
        ],
      },
      { times: [[0, 4]] },
      { times: [] },
      {
        times: [
          [0, 5],
          [2, 4],
          [4, 7],
          [5, 7],
          [9, 20],
          [3, 15],
          [6, 10],
        ],
      },
      {
        times: [
          [10, 20],
          [0, 5],
          [5, 10],
          [10, 15],
        ],
      },
      {
        times: [
          [0, 5],
          [3, 8],
          [4, 10],
          [7, 11],
          [6, 10],
        ],
      },
      {
        times: [
          [0, 5],
          [1, 4],
          [2, 3],
          [3, 8],
          [7, 9],
          [11, 20],
          [0, 20],
          [3, 10],
        ],
      },
      {
        times: [
          [10, 20],
          [5, 15],
          [0, 6],
          [0, 20],
          [21, 22],
          [0, 1],
          [2, 5],
        ],
      },
      {
        times: [
          [0, 10],
          [1, 9],
          [2, 8],
          [3, 7],
          [4, 6],
          [5, 6],
        ],
      },
      {
        times: [
          [0, 20],
          [0, 10],
          [1, 9],
          [2, 8],
          [3, 7],
          [4, 6],
          [5, 6],
          [10, 15],
          [11, 12],
        ],
      },
      {
        times: [
          [5, 10],
          [1, 2],
          [1, 2],
          [1, 2],
          [3, 5],
          [4, 5],
        ],
      },
      {
        times: [
          [1, 3],
          [2, 5],
          [4, 5],
          [0, 20],
          [1, 10],
          [10, 20],
          [11, 15],
          [12, 13],
          [0, 1],
          [0, 2],
        ],
      },
      {
        times: [
          [5, 6],
          [4, 5],
          [3, 4],
          [2, 3],
          [1, 2],
        ],
      },
    ],
  },
  {
    id: 'branch-sums',
    name: 'Branch Sums',
    category: 'Binary Trees',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree and returns a list of its branch\n  sums ordered from leftmost branch sum to rightmost branch sum.\n</p>\n<p>\n  A branch sum is the sum of all values in a Binary Tree branch. A Binary Tree\n  branch is a path of nodes in a tree that starts at the root node and ends at\n  any leaf node.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =     1\n        /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       2       3\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\    /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    4     5  6    7\n  /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\  /\n 8    9 10\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[15, 16, 18, 10, 11]\n<span class="CodeEditor-promptComment">// 15 == 1 + 2 + 4 + 8</span>\n<span class="CodeEditor-promptComment">// 16 == 1 + 2 + 4 + 9</span>\n<span class="CodeEditor-promptComment">// 18 == 1 + 2 + 5 + 10</span>\n<span class="CodeEditor-promptComment">// 10 == 1 + 3 + 6</span>\n<span class="CodeEditor-promptComment">// 11 == 1 + 3 + 7</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry traversing the Binary Tree in a depth-first-search-like fashion.\n</p>\n',
      "\n<p>\nRecursively traverse the Binary Tree in a depth-first-search-like fashion, and pass a running sum of the values of every previously-visited node to each node that you're traversing.\n</p>\n",
      '\n<p>\nAs you recursively traverse the tree, if you reach a leaf node (a node with no "left" or "right" Binary Tree nodes), add the relevant running sum that you\'ve calculated to a list of sums (which you\'ll also have to pass to the recursive function). If you reach a node that isn\'t a leaf node, keep recursively traversing its children nodes, passing the correctly updated running sum to them.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: '10', right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is the class of the input root.\n// Do not edit it.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction branchSums(root) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.branchSums = branchSums;\n',
      solutions: [
        'class BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nfunction branchSums(root) {\n  const sums = [];\n  calculateBranchSums(root, 0, sums);\n  return sums;\n}\n\nfunction calculateBranchSums(node, runningSum, sums) {\n  if (!node) return;\n\n  const newRunningSum = runningSum + node.value;\n  if (!node.left && !node.right) {\n    sums.push(newRunningSum);\n    return;\n  }\n\n  calculateBranchSums(node.left, newRunningSum, sums);\n  calculateBranchSums(node.right, newRunningSum, sums);\n}\n\nexports.BinaryTree = BinaryTree;\nexports.branchSums = branchSums;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  chai.expect(program.branchSums(tree)).to.deep.equal([15, 16, 18, 10, 11]);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n}\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  chai.expect(program.branchSums(tree)).to.deep.equal([15, 16, 18, 10, 11]);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n}\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the number of nodes in the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: '10', right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: '10', right: '1-2', value: 5 },
            { id: '6', left: '1-3', right: '1-4', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '1-2', left: null, right: null, value: 1 },
            { id: '1-3', left: null, right: null, value: 1 },
            { id: '1-4', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '0', left: '1', right: null, value: 0 },
            { id: '1', left: '10', right: null, value: 1 },
            { id: '10', left: '100', right: null, value: 10 },
            { id: '100', left: null, right: null, value: 100 },
          ],
          root: '0',
        },
      },
      {
        tree: {
          nodes: [
            { id: '0', left: null, right: '1', value: 0 },
            { id: '1', left: null, right: '10', value: 1 },
            { id: '10', left: null, right: '100', value: 10 },
            { id: '100', left: null, right: null, value: 100 },
          ],
          root: '0',
        },
      },
      {
        tree: {
          nodes: [
            { id: '0', left: '9', right: '1', value: 0 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '1', left: '15', right: '10', value: 1 },
            { id: '15', left: null, right: null, value: 15 },
            { id: '10', left: '100', right: '200', value: 10 },
            { id: '100', left: null, right: null, value: 100 },
            { id: '200', left: null, right: null, value: 200 },
          ],
          root: '0',
        },
      },
    ],
  },
  {
    id: 'node-depths',
    name: 'Node Depths',
    category: 'Binary Trees',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  The distance between a node in a Binary Tree and the tree\'s root is called the\n  node\'s depth.\n</p>\n<p>\n  Write a function that takes in a Binary Tree and returns the sum of its nodes\'\n  depths.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =    1\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      2       3\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   4     5 6     7\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n8     9\n</pre>\n<h3>Sample Output</h3>\n<pre>\n16\n<span class="CodeEditor-promptComment">// The depth of the node with value 2 is 1.</span>\n<span class="CodeEditor-promptComment">// The depth of the node with value 3 is 1.</span>\n<span class="CodeEditor-promptComment">// The depth of the node with value 4 is 2.</span>\n<span class="CodeEditor-promptComment">// The depth of the node with value 5 is 2.</span>\n<span class="CodeEditor-promptComment">// Etc..</span>\n<span class="CodeEditor-promptComment">// Summing all of these depths yields 16.</span>\n</pre>\n</div>',
    hints: [
      "<p>\nAs obvious as it may seem, to solve this question, you'll have to figure out how to compute the depth of any given node; once you know how to do that, you can compute all of the depths and add them up to obtain the desired output.\n</p>\n",
      "\n<p>\nTo compute the depth of a given node, you need information about its position in the tree. Can you pass this information down from the node's parent?\n</p>\n",
      '\n<p>\nThe depth of any node in the tree is equal to the depth of its parent node plus 1. By starting at the root node whose depth is 0, you can pass down to every node in the tree its respective depth, and you can implement the algorithm that does this and that sums up all of the depths either recursively or iteratively.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function nodeDepths(root) {\n  // Write your code here.\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Do not edit the line below.\nexports.nodeDepths = nodeDepths;\n',
      solutions: [
        '// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction nodeDepths(root) {\n  let sumOfDepths = 0;\n  const stack = [{node: root, depth: 0}];\n  while (stack.length > 0) {\n    const {node, depth} = stack.pop();\n    if (node === null) continue;\n    sumOfDepths += depth;\n    stack.push({node: node.left, depth: depth + 1});\n    stack.push({node: node.right, depth: depth + 1});\n  }\n  return sumOfDepths;\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.nodeDepths = nodeDepths;\n',
        '// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction nodeDepths(root, depth = 0) {\n  if (root === null) return 0;\n  return depth + nodeDepths(root.left, depth + 1) + nodeDepths(root.right, depth + 1);\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.nodeDepths = nodeDepths;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2);\n  root.left.left = new BinaryTree(4);\n  root.left.left.left = new BinaryTree(8);\n  root.left.left.right = new BinaryTree(9);\n  root.left.right = new BinaryTree(5);\n  root.right = new BinaryTree(3);\n  root.right.left = new BinaryTree(6);\n  root.right.right = new BinaryTree(7);\n  const actual = program.nodeDepths(root);\n  chai.expect(actual).to.deep.equal(16);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2);\n  root.left.left = new BinaryTree(4);\n  root.left.left.left = new BinaryTree(8);\n  root.left.left.right = new BinaryTree(9);\n  root.left.right = new BinaryTree(5);\n  root.right = new BinaryTree(3);\n  root.right.left = new BinaryTree(6);\n  root.right.right = new BinaryTree(7);\n  const actual = program.nodeDepths(root);\n  chai.expect(actual).to.deep.equal(16);\n});\n",
    },
    bigO: 'Average case: when the tree is balanced\nO(n) time | O(h) space - where n is the number of nodes in the Binary Tree and h is the height of the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: '5', right: null, value: 4 },
            { id: '5', left: '6', right: null, value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '8', value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: '5', right: null, value: 4 },
            { id: '5', left: '6', right: null, value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: '9', value: 8 },
            { id: '9', left: null, right: '10', value: 9 },
            { id: '10', left: null, right: '11', value: 10 },
            { id: '11', left: null, right: '12', value: 11 },
            { id: '12', left: '13', right: null, value: 12 },
            { id: '13', left: null, right: null, value: 13 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: '10', right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: '11', value: 10 },
            { id: '11', left: '12', right: '13', value: 11 },
            { id: '12', left: '14', right: null, value: 12 },
            { id: '13', left: '15', right: '16', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '15', left: null, right: null, value: 15 },
            { id: '16', left: null, right: null, value: 16 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: '5', right: null, value: 4 },
            { id: '5', left: '6', right: null, value: 5 },
            { id: '6', left: '7', right: null, value: 6 },
            { id: '7', left: '8', right: null, value: 7 },
            { id: '8', left: '9', right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'invert-binary-tree',
    name: 'Invert Binary Tree',
    category: 'Binary Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree and inverts it. In other words,\n  the function should swap every left node in the tree for its corresponding\n  right node.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =    1\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      2       3\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   4     5 6     7\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n8     9\n</pre>\n<h3>Sample Output</h3>\n<pre>\n       1\n    /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   3       2\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n7     6 5     4\n            /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n           9     8\n</pre>\n</div>',
    hints: [
      '<p>\nStart by inverting the root node of the Binary Tree. Inverting this root node simply consists of swapping its left and right child nodes, which can be done the same way as swapping two variables.\n</p>\n',
      "\n<p>\nOnce the first swap mentioned in Hint #1 is done, you must invert the root node's left child node and its right child node. You can do so just as you did for the root node. Then, you will have to continue inverting child nodes' nodes until you reach the bottom of the tree.\n</p>\n",
      '\n<p>\nHow can you accomplish the process described in Hint #2? While recursion seems appropriate, would an iterative approach work? What would be the time and space complexity implications of both approaches?\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function invertBinaryTree(tree) {\n  // Write your code here.\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Do not edit the line below.\nexports.invertBinaryTree = invertBinaryTree;\n',
      solutions: [
        '// O(n) time | O(n) space\nfunction invertBinaryTree(tree) {\n  const queue = [tree];\n  while (queue.length) {\n    const current = queue.shift();\n    if (current === null) continue;\n    swapLeftAndRight(current);\n    queue.push(current.left);\n    queue.push(current.right);\n  }\n}\n\nfunction swapLeftAndRight(tree) {\n  const left = tree.left;\n  tree.left = tree.right;\n  tree.right = left;\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.invertBinaryTree = invertBinaryTree;\n',
        '// O(n) time | O(d) space\nfunction invertBinaryTree(tree) {\n  if (tree === null) return;\n  swapLeftAndRight(tree);\n  invertBinaryTree(tree.left);\n  invertBinaryTree(tree.right);\n}\n\nfunction swapLeftAndRight(tree) {\n  const left = tree.left;\n  tree.left = tree.right;\n  tree.right = left;\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.invertBinaryTree = invertBinaryTree;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  invertedInsert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n    }\n    this.invertedInsert(values, i + 1);\n    return this;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  const invertedTree = new BinaryTree(1).invertedInsert([2, 3, 4, 5, 6, 7, 8, 9]);\n  program.invertBinaryTree(tree);\n  chai.expect(tree).to.deep.equal(invertedTree);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  invertedInsert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n    }\n    this.invertedInsert(values, i + 1);\n    return this;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  const invertedTree = new BinaryTree(1).invertedInsert([2, 3, 4, 5, 6, 7, 8, 9]);\n  program.invertBinaryTree(tree);\n  chai.expect(tree).to.deep.equal(invertedTree);\n});\n",
    },
    bigO: 'O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: '10', right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: '10', right: null, value: 5 },
            { id: '6', left: null, right: '11', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: '12', value: 8 },
            { id: '9', left: '13', right: '14', value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '11', left: '15', right: '16', value: 11 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '13', left: null, right: null, value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '15', left: null, right: '17', value: 15 },
            { id: '16', left: null, right: null, value: 16 },
            { id: '17', left: null, right: '18', value: 17 },
            { id: '18', left: null, right: '19', value: 18 },
            { id: '19', left: '20', right: null, value: 19 },
            { id: '20', left: '21', right: null, value: 20 },
            { id: '21', left: null, right: null, value: 21 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'binary-tree-diameter',
    name: 'Binary Tree Diameter',
    category: 'Binary Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree and returns its diameter. The\n  diameter of a binary tree is defined as the length of its longest path, even\n  if that path doesn\'t pass through the root of the tree.\n</p>\n<p>\n  A path is a collection of connected nodes in a tree, where no node is\n  connected to more than two other nodes. The length of a path is the number of\n  edges between the path\'s first node and its last node.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =        1\n            /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n           3     2\n         /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \n        7     4\n       /       \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      8         5\n     /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    9             6\n</pre>\n<h3>Sample Output</h3>\n<pre>\n6 <span class="CodeEditor-promptComment">// 9 -> 8 -> 7 -> 3 -> 4 -> 5 -> 6</span>\n<span class="CodeEditor-promptComment">// There are 6 edges between the</span>\n<span class="CodeEditor-promptComment">// first node and the last node</span>\n<span class="CodeEditor-promptComment">// of this tree\'s longest path.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nHow can you use the height of a binary tree and the heights of its subtrees to calculate its diameter?\n</p>\n',
      '\n<p>\nThe length of the longest path that goes through the root of a binary tree is the sum of the heights of its left and right subtrees (left subtree height + right subtree height). The diameter of a binary tree can be calculated by taking the maximum of: 1) the maximum subtree diameter (max(left subtree diameter, right subtree diameter)); and 2) the length of the longest path that goes through the root (left subtree height + right subtree height).\n</p>\n',
      '\n<p>\nImplement a variation of depth-first search that recursively keeps track of both the diameter and the height of a each subtree in the input binary tree. Follow Hint #2 to continuously compute these diameters.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '3', right: '2', value: 1 },
            { id: '3', left: '7', right: '4', value: 3 },
            { id: '7', left: '8', right: null, value: 7 },
            { id: '8', left: '9', right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '4', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: '6', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction binaryTreeDiameter(tree) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.binaryTreeDiameter = binaryTreeDiameter;\n',
      solutions: [
        'class BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction binaryTreeDiameter(tree) {\n  return getTreeInfo(tree).diameter;\n}\n\nfunction getTreeInfo(tree) {\n  if (tree === null) {\n    return new TreeInfo(0, 0);\n  }\n\n  const leftTreeInfo = getTreeInfo(tree.left);\n  const rightTreeInfo = getTreeInfo(tree.right);\n\n  const longestPathThroughRoot = leftTreeInfo.height + rightTreeInfo.height;\n  const maxDiameterSoFar = Math.max(leftTreeInfo.diameter, rightTreeInfo.diameter);\n  const currentDiameter = Math.max(longestPathThroughRoot, maxDiameterSoFar);\n  const currentHeight = 1 + Math.max(leftTreeInfo.height, rightTreeInfo.height);\n\n  return new TreeInfo(currentDiameter, currentHeight);\n}\n\nclass TreeInfo {\n  constructor(diameter, height) {\n    this.diameter = diameter;\n    this.height = height;\n  }\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.binaryTreeDiameter = binaryTreeDiameter;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(7);\n  root.left.left.left = new program.BinaryTree(8);\n  root.left.left.left.left = new program.BinaryTree(9);\n  root.left.right = new program.BinaryTree(4);\n  root.left.right.right = new program.BinaryTree(5);\n  root.left.right.right.right = new program.BinaryTree(6);\n  root.right = new program.BinaryTree(2);\n  const expected = 6;\n  const actual = program.binaryTreeDiameter(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'Average case: when the tree is balanced\nO(n) time | O(h) space - where n is the number of nodes in the Binary Tree and h is the height of the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '2', value: 1 },
            { id: '3', left: '7', right: '4', value: 3 },
            { id: '7', left: '8', right: null, value: 7 },
            { id: '8', left: '9', right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '4', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: '6', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '-1', value: 1 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-5', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '-5', left: '6', right: null, value: -5 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '9', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '9', left: '14', right: '10', value: 9 },
            { id: '10', left: null, right: '11', value: 10 },
            { id: '11', left: null, right: '12', value: 11 },
            { id: '12', left: null, right: '17', value: 12 },
            { id: '17', left: null, right: null, value: 17 },
            { id: '14', left: null, right: '19', value: 14 },
            { id: '19', left: '25', right: null, value: 19 },
            { id: '25', left: null, right: null, value: 25 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '5', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '5', right: null, value: 1 },
            { id: '5', left: '7', right: '9', value: 5 },
            { id: '9', left: null, right: '12', value: 9 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '7', left: '8', right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '4', left: '2', right: null, value: 4 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '4',
        },
      },
      {
        tree: {
          nodes: [
            { id: '4', left: '2', right: null, value: 4 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '4',
        },
      },
      {
        tree: {
          nodes: [
            { id: '4', left: '2', right: null, value: 4 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: '3', value: 1 },
            { id: '3', left: '19', right: null, value: 3 },
            { id: '19', left: null, right: null, value: 19 },
          ],
          root: '4',
        },
      },
      {
        tree: {
          nodes: [
            { id: '6', left: null, right: '1', value: 6 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '6',
        },
      },
      {
        tree: {
          nodes: [
            { id: '3', left: null, right: '10', value: 3 },
            { id: '10', left: '1', right: null, value: 10 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '3',
        },
      },
      {
        tree: {
          nodes: [
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: '3', right: null, value: 1 },
            { id: '3', left: null, right: '5', value: 3 },
            { id: '5', left: null, right: '10', value: 5 },
            { id: '10', left: null, right: null, value: 10 },
          ],
          root: '2',
        },
      },
    ],
  },
  {
    id: 'max-path-sum-in-binary-tree',
    name: 'Max Path Sum In Binary Tree',
    category: 'Binary Trees',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree and returns its max path sum.\n</p>\n<p>\n  A path is a collection of connected nodes in a tree, where no node is\n  connected to more than two other nodes; a path sum is the sum of the values of\n  the nodes in a particular path.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> = 1\n    /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   2       3\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n4     5 6     7\n</pre>\n<h3>Sample Output</h3>\n<pre>\n18 <span class="CodeEditor-promptComment">// 5 + 2 + 1 + 3 + 7</span>\n</pre>\n</div>',
    hints: [
      '<p>\nIf you were to imagine each node in a Binary Tree as the root of the Binary Tree, temporarily eliminating all of the nodes that come above it, how would you find the max path sum for each of these newly imagined Binary Trees? In simpler terms, how can you find the max path sum for each subtree in the Binary Tree?\n</p>\n',
      "\n<p>\nFor every node in a Binary Tree, there are four options for the max path sum that includes its value: the node's value alone, the node's value plus the max path sum of its left subtree, the node's value plus the max path sum of its right subtree, or the node's value plus the max path sum of both its subtrees.\n</p>\n",
      "\n<p>\nA recursive algorithm that computes each node's max path sum and uses it to compute its parents' nodes' max path sums seems appropriate, but realize that you cannot have a path going through a node and both its subtrees as well as that node's parent node. In other words, the fourth option mentioned in Hint #2 poses a challenge to implementing a recursive algorithm that solves this problem. How can you get around it?\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function maxPathSum(tree) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.maxPathSum = maxPathSum;\n',
      solutions: [
        '// O(n) time | O(log(n)) space\nfunction maxPathSum(tree) {\n  const [_, maxSum] = findMaxSum(tree);\n  return maxSum;\n}\n\nfunction findMaxSum(tree) {\n  if (tree === null) return [0, -Infinity];\n\n  const [leftMaxSumAsBranch, leftMaxPathSum] = findMaxSum(tree.left);\n  const [rightMaxSumAsBranch, rightMaxPathSum] = findMaxSum(tree.right);\n  const maxChildSumAsBranch = Math.max(leftMaxSumAsBranch, rightMaxSumAsBranch);\n\n  const {value} = tree;\n  const maxSumAsBranch = Math.max(maxChildSumAsBranch + value, value);\n  const maxSumAsRootNode = Math.max(\n    leftMaxSumAsBranch + value + rightMaxSumAsBranch,\n    maxSumAsBranch,\n  );\n  const maxPathSum = Math.max(leftMaxPathSum, rightMaxPathSum, maxSumAsRootNode);\n\n  return [maxSumAsBranch, maxPathSum];\n}\n\nexports.maxPathSum = maxPathSum;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const test = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7]);\n  chai.expect(program.maxPathSum(test)).to.deep.equal(18);\n});\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n}\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const test = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7]);\n  chai.expect(program.maxPathSum(test)).to.deep.equal(18);\n});\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n}\n",
    },
    bigO: 'O(n) time | O(log(n)) space - where n is the number of nodes in the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '-1', value: 1 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-5', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '-5', left: '6', right: null, value: -5 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-10', right: '-5', value: 1 },
            { id: '-5', left: '-20', right: '-21', value: -5 },
            { id: '-21', left: '100-2', right: '1-3', value: -21 },
            { id: '1-3', left: null, right: null, value: 1 },
            { id: '100-2', left: null, right: null, value: 100 },
            { id: '-20', left: '100', right: '2', value: -20 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '100', left: null, right: null, value: 100 },
            { id: '-10', left: '30', right: '45', value: -10 },
            { id: '45', left: '3', right: '-3', value: 45 },
            { id: '-3', left: null, right: null, value: -3 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '30', left: '5', right: '1-2', value: 30 },
            { id: '1-2', left: null, right: null, value: 1 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-10', right: '-5', value: 1 },
            { id: '-5', left: '-20', right: '-21', value: -5 },
            { id: '-21', left: '100-3', right: '1-3', value: -21 },
            { id: '1-3', left: null, right: null, value: 1 },
            { id: '100-3', left: null, right: null, value: 100 },
            { id: '-20', left: '100-2', right: '2', value: -20 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '100-2', left: null, right: null, value: 100 },
            { id: '-10', left: '30', right: '45', value: -10 },
            { id: '45', left: '3', right: '-3', value: 45 },
            { id: '-3', left: null, right: null, value: -3 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '30', left: '5', right: '1-2', value: 30 },
            { id: '1-2', left: null, right: null, value: 1 },
            { id: '5', left: '100', right: null, value: 5 },
            { id: '100', left: null, right: null, value: 100 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-10', right: '-5', value: 1 },
            { id: '-5', left: '-20', right: '-21', value: -5 },
            { id: '-21', left: '100-3', right: '1-3', value: -21 },
            { id: '1-3', left: null, right: null, value: 1 },
            { id: '100-3', left: null, right: null, value: 100 },
            { id: '-20', left: '100-2', right: '2', value: -20 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '100-2', left: null, right: null, value: 100 },
            { id: '-10', left: '30', right: '75', value: -10 },
            { id: '75', left: '3', right: '-3', value: 75 },
            { id: '-3', left: null, right: null, value: -3 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '30', left: '5', right: '1-2', value: 30 },
            { id: '1-2', left: null, right: null, value: 1 },
            { id: '5', left: '100', right: null, value: 5 },
            { id: '100', left: null, right: null, value: 100 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-150', right: '-5', value: 1 },
            { id: '-5', left: '-20', right: '-21', value: -5 },
            { id: '-21', left: '100-4', right: '1-3', value: -21 },
            { id: '1-3', left: null, right: null, value: 1 },
            { id: '100-4', left: null, right: null, value: 100 },
            { id: '-20', left: '100-3', right: '2', value: -20 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '100-3', left: null, right: null, value: 100 },
            { id: '-150', left: '30', right: '75', value: -150 },
            { id: '75', left: '3', right: '-3', value: 75 },
            { id: '-3', left: null, right: null, value: -3 },
            { id: '3', left: '150', right: '-8', value: 3 },
            { id: '-8', left: null, right: null, value: -8 },
            { id: '150', left: null, right: null, value: 150 },
            { id: '30', left: '5', right: '1-2', value: 30 },
            { id: '1-2', left: '5-2', right: '10', value: 1 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '5', left: '100', right: '100-2', value: 5 },
            { id: '100-2', left: null, right: null, value: 100 },
            { id: '100', left: null, right: null, value: 100 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-150', right: '-5', value: 1 },
            { id: '-5', left: '-20', right: '-21', value: -5 },
            { id: '-21', left: '100-4', right: '1-3', value: -21 },
            { id: '1-3', left: null, right: null, value: 1 },
            { id: '100-4', left: null, right: null, value: 100 },
            { id: '-20', left: '100-3', right: '2', value: -20 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '100-3', left: null, right: null, value: 100 },
            { id: '-150', left: '30', right: '75', value: -150 },
            { id: '75', left: '3', right: '-3', value: 75 },
            { id: '-3', left: null, right: null, value: -3 },
            { id: '3', left: '150', right: '151', value: 3 },
            { id: '151', left: null, right: null, value: 151 },
            { id: '150', left: null, right: null, value: 150 },
            { id: '30', left: '5', right: '1-2', value: 30 },
            { id: '1-2', left: '5-2', right: '10', value: 1 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '5', left: '100', right: '100-2', value: 5 },
            { id: '100-2', left: null, right: null, value: 100 },
            { id: '100', left: null, right: null, value: 100 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-5', right: '-3-2', value: 1 },
            { id: '-3-2', left: '2-2', right: '1-7', value: -3 },
            { id: '1-7', left: '1-8', right: '1-10', value: 1 },
            { id: '1-10', left: '-5-2', right: '0-5', value: 1 },
            { id: '0-5', left: null, right: null, value: 0 },
            { id: '-5-2', left: null, right: null, value: -5 },
            { id: '1-8', left: '0-4', right: '1-9', value: 1 },
            { id: '1-9', left: null, right: null, value: 1 },
            { id: '0-4', left: null, right: null, value: 0 },
            { id: '2-2', left: '0-3', right: '5', value: 2 },
            { id: '5', left: '2-3', right: '1-6', value: 5 },
            { id: '1-6', left: null, right: null, value: 1 },
            { id: '2-3', left: null, right: null, value: 2 },
            { id: '0-3', left: '-9', right: '-91', value: 0 },
            { id: '-91', left: null, right: null, value: -91 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '-5', left: '0', right: '2', value: -5 },
            { id: '2', left: '1-4', right: '1-5', value: 2 },
            { id: '1-5', left: '-1-3', right: '-100', value: 1 },
            { id: '-100', left: null, right: null, value: -100 },
            { id: '-1-3', left: null, right: null, value: -1 },
            { id: '1-4', left: '-1-2', right: '-6', value: 1 },
            { id: '-6', left: null, right: null, value: -6 },
            { id: '-1-2', left: null, right: null, value: -1 },
            { id: '0', left: '-3', right: '3', value: 0 },
            { id: '3', left: '1-3', right: '-1', value: 3 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '1-3', left: null, right: null, value: 1 },
            { id: '-3', left: '0-2', right: '1-2', value: -3 },
            { id: '1-2', left: null, right: null, value: 1 },
            { id: '0-2', left: null, right: null, value: 0 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-5', right: '-3-2', value: 1 },
            { id: '-3-2', left: '2-2', right: '1-6', value: -3 },
            { id: '1-6', left: '1-7', right: '1-9', value: 1 },
            { id: '1-9', left: '-5-2', right: '0-5', value: 1 },
            { id: '0-5', left: null, right: null, value: 0 },
            { id: '-5-2', left: null, right: null, value: -5 },
            { id: '1-7', left: '0-4', right: '1-8', value: 1 },
            { id: '1-8', left: null, right: null, value: 1 },
            { id: '0-4', left: null, right: null, value: 0 },
            { id: '2-2', left: '0-3', right: '5', value: 2 },
            { id: '5', left: '2-3', right: '1-5', value: 5 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '2-3', left: null, right: null, value: 2 },
            { id: '0-3', left: '-9', right: '-91', value: 0 },
            { id: '-91', left: null, right: null, value: -91 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '-5', left: '0', right: '2', value: -5 },
            { id: '2', left: '1-3', right: '1-4', value: 2 },
            { id: '1-4', left: '-1-3', right: '-100', value: 1 },
            { id: '-100', left: null, right: null, value: -100 },
            { id: '-1-3', left: null, right: null, value: -1 },
            { id: '1-3', left: '-1-2', right: '-6', value: 1 },
            { id: '-6', left: null, right: null, value: -6 },
            { id: '-1-2', left: null, right: null, value: -1 },
            { id: '0', left: '-3', right: '-4', value: 0 },
            { id: '-4', left: '10', right: '-1', value: -4 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '-3', left: '0-2', right: '1-2', value: -3 },
            { id: '1-2', left: null, right: null, value: 1 },
            { id: '0-2', left: null, right: null, value: 0 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-5', right: '-3-2', value: 1 },
            { id: '-3-2', left: '2-4', right: '1-7', value: -3 },
            { id: '1-7', left: '1-8', right: '1-10', value: 1 },
            { id: '1-10', left: '-5-3', right: '0-5', value: 1 },
            { id: '0-5', left: null, right: null, value: 0 },
            { id: '-5-3', left: null, right: null, value: -5 },
            { id: '1-8', left: '0-4', right: '1-9', value: 1 },
            { id: '1-9', left: null, right: null, value: 1 },
            { id: '0-4', left: null, right: null, value: 0 },
            { id: '2-4', left: '0-3', right: '5', value: 2 },
            { id: '5', left: '2-5', right: '1-6', value: 5 },
            { id: '1-6', left: null, right: null, value: 1 },
            { id: '2-5', left: null, right: null, value: 2 },
            { id: '0-3', left: '-9', right: '-91', value: 0 },
            { id: '-91', left: null, right: null, value: -91 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '-5', left: '0', right: '2-3', value: -5 },
            { id: '2-3', left: '1-4', right: '1-5', value: 2 },
            { id: '1-5', left: '-1-3', right: '-100', value: 1 },
            { id: '-100', left: null, right: null, value: -100 },
            { id: '-1-3', left: null, right: null, value: -1 },
            { id: '1-4', left: '-1-2', right: '-6', value: 1 },
            { id: '-6', left: null, right: null, value: -6 },
            { id: '-1-2', left: null, right: null, value: -1 },
            { id: '0', left: '-3', right: '-4', value: 0 },
            { id: '-4', left: '3-2', right: '-1', value: -4 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '3-2', left: '7', right: '-5-2', value: 3 },
            { id: '-5-2', left: null, right: null, value: -5 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '-3', left: '0-2', right: '1-3', value: -3 },
            { id: '1-3', left: '2', right: '2-2', value: 1 },
            { id: '2-2', left: null, right: null, value: 2 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '0-2', left: '3', right: '1-2', value: 0 },
            { id: '1-2', left: null, right: null, value: 1 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-5', right: '-3-2', value: 1 },
            { id: '-3-2', left: '2-2', right: '1-7', value: -3 },
            { id: '1-7', left: '1-8', right: '1-10', value: 1 },
            { id: '1-10', left: '5-2', right: '0-5', value: 1 },
            { id: '0-5', left: null, right: null, value: 0 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '1-8', left: '0-4', right: '1-9', value: 1 },
            { id: '1-9', left: null, right: null, value: 1 },
            { id: '0-4', left: null, right: null, value: 0 },
            { id: '2-2', left: '0-3', right: '5', value: 2 },
            { id: '5', left: '2-3', right: '1-6', value: 5 },
            { id: '1-6', left: null, right: null, value: 1 },
            { id: '2-3', left: null, right: null, value: 2 },
            { id: '0-3', left: '-9', right: '-91', value: 0 },
            { id: '-91', left: null, right: null, value: -91 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '-5', left: '0', right: '2', value: -5 },
            { id: '2', left: '1-4', right: '1-5', value: 2 },
            { id: '1-5', left: '-1-3', right: '-100', value: 1 },
            { id: '-100', left: null, right: null, value: -100 },
            { id: '-1-3', left: null, right: null, value: -1 },
            { id: '1-4', left: '-1-2', right: '-6', value: 1 },
            { id: '-6', left: null, right: null, value: -6 },
            { id: '-1-2', left: null, right: null, value: -1 },
            { id: '0', left: '-3', right: '3', value: 0 },
            { id: '3', left: '1-3', right: '-1', value: 3 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '1-3', left: null, right: null, value: 1 },
            { id: '-3', left: '0-2', right: '1-2', value: -3 },
            { id: '1-2', left: null, right: null, value: 1 },
            { id: '0-2', left: null, right: null, value: 0 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '-2', left: null, right: null, value: -2 }],
          root: '-2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-2', left: '-1', right: null, value: -2 },
            { id: '-1', left: null, right: null, value: -1 },
          ],
          root: '-2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-2', left: '-1', right: null, value: -2 },
            { id: '-1', left: '2', right: '3', value: -1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '-2',
        },
      },
    ],
  },
  {
    id: 'iterative-in-order-traversal',
    name: 'Iterative In-order Traversal',
    category: 'Binary Trees',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree (where nodes have an additional\n  pointer to their parent node) and traverses it iteratively using the in-order\n  tree-traversal technique; the traversal should specifically <i>not</i> use\n  recursion. As the tree is being traversed, a callback function passed in as an\n  argument to the main function should be called on each node (i.e.,\n  <span>callback(currentNode)</span>).\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>parent</span> node, a <span>left</span> child node, and a\n  <span>right</span> child node. Children nodes can either be\n  <span>BinaryTree</span> nodes themselves or <span>None</span> /\n  <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =    1\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      2       3\n    /       /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   4       6     7\n     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      9\n<span class="CodeEditor-promptParameter">callback</span> = someCallback\n</pre>\n<h3>Sample Output</h3>\n<pre>\n<span class="CodeEditor-promptComment">// The input callback will have been called in the following order:</span>\ncallback(4)\ncallback(9)\ncallback(2)\ncallback(1)\ncallback(6)\ncallback(3)\ncallback(7)\n</pre>\n</div>',
    hints: [
      '<p>\nStart by realizing that in-order traversal always traverses left child nodes before parent nodes before right child nodes. In other words, you will somehow have to traverse the entire left side of the input Binary Tree before calling the input callback on the root node and before traversing the entire right side.\n</p>\n',
      '\n<p>\nWhile each node in the input Binary Tree does have a "parent" property, allowing you to traverse your way back up the tree if need be, the difficulty arises when you must choose which node to actually call the input callback on. For instance, on your way back up the left side of the input tree, how do you know whether to traverse the right side of a node or to keep going up? Is there something that you can keep track of in order to know which node to call the input callback back on next at any time during the life of your algorithm?\n</p>\n',
      "\n<p>\nTry keeping track of three nodes at all times: a current node (the node currently being traversed), a previous node (the node traversed just before the current one), and a next node (the next node to be traversed). Determine which node to traverse next and when to call the input callback on the current node by analyzing the previous node. For instance, if the previous node is actually the current node's left child node, then you know that you must call the callback on the current node and that you must then explore the right side of the current node before going back up. Figure out all of the possible scenarios, and develop an algorithm to handle all of these scenarios.\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: null, right: '9', value: 4 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes'\n<span>left</span> and <span>right</span> pointers and by the <span>root</span>. The\n<span>parent</span> pointer of each node will be deduced from the collection of <span>nodes</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function iterativeInOrderTraversal(tree, callback) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.iterativeInOrderTraversal = iterativeInOrderTraversal;\n',
      solutions: [
        '// O(n) time | O(1) space\nfunction iterativeInOrderTraversal(tree, callback) {\n  let previousNode = null;\n  let currentNode = tree;\n  while (currentNode !== null) {\n    let nextNode;\n    if (previousNode === null || previousNode === currentNode.parent) {\n      if (currentNode.left !== null) {\n        nextNode = currentNode.left;\n      } else {\n        callback(currentNode);\n        nextNode = currentNode.right !== null ? currentNode.right : currentNode.parent;\n      }\n    } else if (previousNode === currentNode.left) {\n      callback(currentNode);\n      nextNode = currentNode.right !== null ? currentNode.right : currentNode.parent;\n    } else {\n      nextNode = currentNode.parent;\n    }\n    previousNode = currentNode;\n    currentNode = nextNode;\n  }\n}\n\nexports.iterativeInOrderTraversal = iterativeInOrderTraversal;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value, parent = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2, root);\n  root.left.left = new BinaryTree(4, root.left);\n  root.left.left.right = new BinaryTree(9, root.left.left);\n  root.right = new BinaryTree(3, root);\n  root.right.left = new BinaryTree(6, root.right);\n  root.right.right = new BinaryTree(7, root.right);\n\n  const array = [];\n  function testCallback(tree) {\n    if (tree === null) return;\n    array.push(tree.value);\n  }\n\n  program.iterativeInOrderTraversal(root, testCallback);\n\n  chai.expect(array).to.deep.equal([4, 9, 2, 1, 6, 3, 7]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value, parent = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2, root);\n  root.left.left = new BinaryTree(4, root.left);\n  root.left.left.right = new BinaryTree(9, root.left.left);\n  root.right = new BinaryTree(3, root);\n  root.right.left = new BinaryTree(6, root.right);\n  root.right.right = new BinaryTree(7, root.right);\n\n  const array = [];\n  function testCallback(tree) {\n    if (tree === null) return;\n    array.push(tree.value);\n  }\n\n  program.iterativeInOrderTraversal(root, testCallback);\n\n  chai.expect(array).to.deep.equal([4, 9, 2, 1, 6, 3, 7]);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: null, right: '9', value: 4 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: '10', right: null, value: 5 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '6', left: '12', right: '13', value: 6 },
            { id: '13', left: null, right: null, value: 13 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: '10', right: '11', value: 5 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: '14', right: '15', value: 7 },
            { id: '15', left: null, right: null, value: 15 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '6', left: '12', right: '13', value: 6 },
            { id: '13', left: null, right: null, value: 13 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: '10', right: '11', value: 5 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '9', left: '18', right: null, value: 9 },
            { id: '18', left: null, right: null, value: 18 },
            { id: '8', left: '16', right: '17', value: 8 },
            { id: '17', left: null, right: null, value: 17 },
            { id: '16', left: null, right: null, value: 16 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'flatten-binary-tree',
    name: 'Flatten Binary Tree',
    category: 'Binary Trees',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree, flattens it, and returns its\n  leftmost node.\n</p>\n<p>\n  A flattened Binary Tree is a structure that\'s nearly identical to a Doubly\n  Linked List (except that nodes have <span>left</span> and\n  <span>right</span> pointers instead of <span>prev</span> and\n  <span>next</span> pointers), where nodes follow the original tree\'s\n  left-to-right order.\n</p>\n<p>\n  Note that if the input Binary Tree happens to be a valid Binary Search Tree,\n  the nodes in the flattened tree will be sorted.\n</p>\n<p>\n  The flattening should be done in place, meaning that the original data\n  structure should be mutated (no new structure should be created).\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =      1\n         /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        2       3\n      /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /\n     4     5 6\n          / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n         7   8\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 <-> 2 <-> 7 <-> 5 <-> 8 <-> 1 <-> 6 <-> 3 <span class="CodeEditor-promptComment">// the leftmost node with value 4</span>\n</pre>\n</div>',
    hints: [
      "<p>\nYou can solve this problem pretty easily by traversing the tree using the in-order tree-traversal technique, gathering all of the nodes in an array, and then iterating through them from left to right and connecting them accordingly. Can you solve this problem without storing an entire array of the tree's nodes?\n</p>\n",
      '\n<p>\nTry to figure out what the relation between two adjacent nodes in the in-order-traversal order is, as far as positioning in the tree is concerned.\n</p>\n',
      '\n<p>\nAt any given node in the in-order-traversal order, the node immediately to its left is the rightmost node of its left subtree, and the node immediately the its right is the leftmost node of its right subtree.\n</p>\n',
      "\n<p>\nWrite a function that recursively gets the leftmost and rightmost nodes of a given node's left subtree and right subtree and that connects the left subtree's rightmost node to the given node and the right subtree's leftmost node to the given node.\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: null, value: 3 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is the class of the input root. Do not edit it.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction flattenBinaryTree(root) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.flattenBinaryTree = flattenBinaryTree;\n',
      solutions: [
        'class BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nfunction flattenBinaryTree(root) {\n  const inOrderNodes = getNodesInOrder(root, []);\n  for (let i = 0; i < inOrderNodes.length - 1; i++) {\n    const leftNode = inOrderNodes[i];\n    const rightNode = inOrderNodes[i + 1];\n    leftNode.right = rightNode;\n    rightNode.left = leftNode;\n  }\n  return inOrderNodes[0];\n}\n\nfunction getNodesInOrder(tree, array) {\n  if (tree !== null) {\n    getNodesInOrder(tree.left, array);\n    array.push(tree);\n    getNodesInOrder(tree.right, array);\n  }\n  return array;\n}\n\nexports.BinaryTree = BinaryTree;\nexports.flattenBinaryTree = flattenBinaryTree;\n',
        'class BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree\nfunction flattenBinaryTree(root) {\n  const [leftMost, _] = flattenTree(root);\n  return leftMost;\n}\n\nfunction flattenTree(node) {\n  let leftMost, rightMost;\n\n  if (node.left === null) {\n    leftMost = node;\n  } else {\n    const [leftSubtreeLeftMost, leftSubtreeRightMost] = flattenTree(node.left);\n    connectNodes(leftSubtreeRightMost, node);\n    leftMost = leftSubtreeLeftMost;\n  }\n\n  if (node.right === null) {\n    rightMost = node;\n  } else {\n    const [rightSubtreeLeftMost, rightSubtreeRightMost] = flattenTree(node.right);\n    connectNodes(node, rightSubtreeLeftMost);\n    rightMost = rightSubtreeRightMost;\n  }\n\n  return [leftMost, rightMost];\n}\n\nfunction connectNodes(left, right) {\n  left.right = right;\n  right.left = left;\n}\n\nexports.BinaryTree = BinaryTree;\nexports.flattenBinaryTree = flattenBinaryTree;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1).insert([2, 3, 4, 5, 6]);\n  root.left.right.left = new BinaryTree(7);\n  root.left.right.right = new BinaryTree(8);\n  const leftMostNode = program.flattenBinaryTree(root);\n  const leftToRightToLeft = leftMostNode.leftToRightToLeft();\n  const expected = [4, 2, 7, 5, 8, 1, 6, 3, 3, 6, 1, 8, 5, 7, 2, 4];\n  chai.expect(leftToRightToLeft).to.deep.equal(expected);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  leftToRightToLeft() {\n    const nodes = [];\n    let current = this;\n    while (current.right !== null) {\n      nodes.push(current.value);\n      current = current.right;\n    }\n    nodes.push(current.value);\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.left;\n    }\n    return nodes;\n  }\n}\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1).insert([2, 3, 4, 5, 6]);\n  root.left.right.left = new BinaryTree(7);\n  root.left.right.right = new BinaryTree(8);\n  const leftMostNode = program.flattenBinaryTree(root);\n  const leftToRightToLeft = leftMostNode.leftToRightToLeft();\n  const expected = [4, 2, 7, 5, 8, 1, 6, 3, 3, 6, 1, 8, 5, 7, 2, 4];\n  chai.expect(leftToRightToLeft).to.deep.equal(expected);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  leftToRightToLeft() {\n    const nodes = [];\n    let current = this;\n    while (current.right !== null) {\n      nodes.push(current.value);\n      current = current.right;\n    }\n    nodes.push(current.value);\n    while (current !== null) {\n      nodes.push(current.value);\n      current = current.left;\n    }\n    return nodes;\n  }\n}\n",
    },
    bigO: 'O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: null, value: 3 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: null, value: 3 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '6', left: '12', right: null, value: 6 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: '10', right: '11', value: 5 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'right-sibling-tree',
    name: 'Right Sibling Tree',
    category: 'Binary Trees',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree, transforms it into a Right\n  Sibling Tree, and returns its root.\n</p>\n<p>\n  A Right Sibling Tree is obtained by making every node in a Binary Tree have\n  its <span>right</span> property point to its right sibling instead of its\n  right child. A node\'s right sibling is the node immediately to its right on\n  the same level or <span>None</span> / <span>null</span> if there is no node\n  immediately to its right.\n</p>\n<p>\n  Note that once the transformation is complete, some nodes might no longer have\n  a node pointing to them. For example, in the sample output below, the node\n  with value <span>10</span> no longer has any inbound pointers and is\n  effectively unreachable.\n</p>\n<p>\n  The transformation should be done in place, meaning that the original data\n  structure should be mutated (no new structure should be created).\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =     1\n      /         \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     2           3\n   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\       /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  4     5     6     7\n / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /     / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n8   9    10 11    12 13\n           /\n          14\n</pre>\n<h3>Sample Output</h3>\n<pre>\n           1 <span class="CodeEditor-promptComment">// the root node with value 1</span>\n      /\n     2-----------3\n   /           /\n  4-----5-----6-----7\n /           /     /\n8---9    10-11    12-13 <span class="CodeEditor-promptComment">// the node with value 10 no longer has a node pointing to it</span>\n           /\n          14\n</pre>\n</div>',
    hints: [
      "<p>\nTry to identify a pattern or formula that determines how to reach a given node's right sibling.\n</p>\n",
      "\n<p>\nThere are two patterns: if a node is the left child of another node, its right sibling is its parent's right child; if a node is the right child of another node, its right sibling is its parent's right sibling's left child.\n</p>\n",
      "\n<p>\nYou'll need to a find a way to quickly access a node's parent's right child and a node's parent's right sibling; this won't be trivial because the second one implies that the parent node's original right pointer has been overwritten.\n</p>\n",
      "\n<p>\nRecursively traverse the binary tree and sequence the transformation operations as follows: at any given node, recursively transform its left subtree into a right sibling tree, then edit the given node's right pointer to point to its right sibling, and then finally recursively transform its right subtree into a right sibling tree. This sequencing of operations will allow left child nodes to always access their parent's right child (before their parent's right pointer gets overwritten to point to the parent's right sibling) and will allow right child nodes to always access their parent's right sibling (after their parent's right pointer has gotten overwritten to point to the parent's right sibling).\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: '12', right: '13', value: 7 },
            { id: '13', left: null, right: null, value: 13 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '6', left: '11', right: null, value: 6 },
            { id: '11', left: '14', right: null, value: 11 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: '10', value: 5 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is the class of the input root. Do not edit it.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction rightSiblingTree(root) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.rightSiblingTree = rightSiblingTree;\n',
      solutions: [
        'class BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree\nfunction rightSiblingTree(root) {\n  mutate(root, null, null);\n  return root;\n}\n\nfunction mutate(node, parent, isLeftChild) {\n  if (node === null) return;\n  const {left, right} = node;\n  mutate(left, node, true);\n  if (parent === null) {\n    node.right = null;\n  } else if (isLeftChild) {\n    node.right = parent.right;\n  } else {\n    if (parent.right === null) {\n      node.right = null;\n    } else {\n      node.right = parent.right.left;\n    }\n  }\n  mutate(right, node, false);\n}\n\nexports.BinaryTree = BinaryTree;\nexports.rightSiblingTree = rightSiblingTree;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  root.left.right.right = new BinaryTree(10);\n  root.right.left.left = new BinaryTree(11);\n  root.right.right.left = new BinaryTree(12);\n  root.right.right.right = new BinaryTree(13);\n  root.right.left.left.left = new BinaryTree(14);\n  const mutatedRoot = program.rightSiblingTree(root);\n  const dfsOrder = mutatedRoot.getDfsOrder([]);\n  const expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13];\n  chai.expect(dfsOrder).to.deep.equal(expected);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  getDfsOrder(values) {\n    values.push(this.value);\n    if (this.left !== null) {\n      this.left.getDfsOrder(values);\n    }\n    if (this.right !== null) {\n      this.right.getDfsOrder(values);\n    }\n    return values;\n  }\n}\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1).insert([2, 3, 4, 5, 6, 7, 8, 9]);\n  root.left.right.right = new BinaryTree(10);\n  root.right.left.left = new BinaryTree(11);\n  root.right.right.left = new BinaryTree(12);\n  root.right.right.right = new BinaryTree(13);\n  root.right.left.left.left = new BinaryTree(14);\n  const mutatedRoot = program.rightSiblingTree(root);\n  const dfsOrder = mutatedRoot.getDfsOrder([]);\n  const expected = [1, 2, 4, 8, 9, 5, 6, 11, 14, 7, 12, 13, 3, 6, 11, 14, 7, 12, 13];\n  chai.expect(dfsOrder).to.deep.equal(expected);\n});\n\nclass BinaryTree extends program.BinaryTree {\n  constructor(value) {\n    super(value);\n  }\n\n  insert(values, i = 0) {\n    if (i >= values.length) return;\n    const queue = [this];\n    while (queue.length > 0) {\n      let current = queue.shift();\n      if (current.left === null) {\n        current.left = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.left);\n      if (current.right === null) {\n        current.right = new BinaryTree(values[i]);\n        break;\n      }\n      queue.push(current.right);\n    }\n    this.insert(values, i + 1);\n    return this;\n  }\n\n  getDfsOrder(values) {\n    values.push(this.value);\n    if (this.left !== null) {\n      this.left.getDfsOrder(values);\n    }\n    if (this.right !== null) {\n      this.right.getDfsOrder(values);\n    }\n    return values;\n  }\n}\n",
    },
    bigO: 'O(n) time | O(d) space - where n is the number of nodes in the Binary Tree and d is the depth (height) of the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: '12', right: '13', value: 7 },
            { id: '13', left: null, right: null, value: 13 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '6', left: '11', right: null, value: 6 },
            { id: '11', left: '14', right: null, value: 11 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: '10', value: 5 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: null, value: 3 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: null, value: 3 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '7', left: '14', right: '15', value: 7 },
            { id: '15', left: null, right: null, value: 15 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '6', left: '12', right: '13', value: 6 },
            { id: '13', left: null, right: null, value: 13 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '5', left: '10', right: '11', value: 5 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'all-kinds-of-node-depths',
    name: 'All Kinds Of Node Depths',
    category: 'Binary Trees',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  The distance between a node in a Binary Tree and the tree\'s root is called the\n  node\'s depth.\n</p>\n<p>\n  Write a function that takes in a Binary Tree and returns the sum of all of\n  its subtrees\' nodes\' depths.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =    1\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      2       3\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   4     5 6     7\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n8     9\n</pre>\n<h3>Sample Output</h3>\n<pre>\n26\n<span class="CodeEditor-promptComment">// The sum of the root tree\'s node depths is 16.</span>\n<span class="CodeEditor-promptComment">// The sum of the tree rooted at 2\'s node depths is 6.</span>\n<span class="CodeEditor-promptComment">// The sum of the tree rooted at 3\'s node depths is 2.</span>\n<span class="CodeEditor-promptComment">// The sum of the tree rooted at 4\'s node depths is 2.</span>\n<span class="CodeEditor-promptComment">// Summing all of these sums yields 26.</span>\n</pre>\n</div>',
    hints: [
      "<p>\nYou can calculate the sum of a tree's node depths with a simple recursive function. Iterate through every node in the tree, call the simple recursive function on each node to caculate the sum of the node depths of the tree rooted at the node in question, and add up all of the sums to obtain the final sum.\n</p>\n",
      "\n<p>\nYou can solve this question in linear time by coming up with a relation between a tree's sum of node depths and the sums of node depths of the trees rooted at its left and right child nodes.\n</p>\n",
      "\n<p>\nThe depth of a node relative to a node X is 1 value smaller than its depth relative to node X's parent node Y. It follows that, if a subtree rooted at node X has a sum of node depths S, you can get the sum of those node depths relative to node Y by calculating: S + number-of-nodes-in-subtree-rooted-at-X, since this effectively increments all of the node depths relative to node X by 1.\n</p>\n",
      '\n<p>\nFrom Hint #3, we can deduce the formula: nodeDepths(node) = nodeDepths(node.left) + numberOfNodesInLeftSubtree + nodeDepths(node.right) + numberOfNodesInRightSubtree. We can easily count the number of nodes in each subtree with a single pass in the input tree, and then we can apply this formula to calculate all of the node depths in linear time and finally sum them up.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function allKindsOfNodeDepths(root) {\n  // Write your code here.\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Do not edit the line below.\nexports.allKindsOfNodeDepths = allKindsOfNodeDepths;\n',
      solutions: [
        '// Average case: when the tree is balanced\n// O(nlog(n)) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction allKindsOfNodeDepths(root) {\n  let sumOfAllDepths = 0;\n  let stack = [root];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (node === null) continue;\n    sumOfAllDepths += nodeDepths(node);\n    stack.push(node.left);\n    stack.push(node.right);\n  }\n  return sumOfAllDepths;\n}\n\nfunction nodeDepths(node, depth = 0) {\n  if (node === null) return 0;\n  return depth + nodeDepths(node.left, depth + 1) + nodeDepths(node.right, depth + 1);\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.allKindsOfNodeDepths = allKindsOfNodeDepths;\n',
        '// Average case: when the tree is balanced\n// O(nlog(n)) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction allKindsOfNodeDepths(root) {\n  if (root == null) return 0;\n  return allKindsOfNodeDepths(root.left) + allKindsOfNodeDepths(root.right) + nodeDepths(root);\n}\n\nfunction nodeDepths(node, depth = 0) {\n  if (node === null) return 0;\n  return depth + nodeDepths(node.left, depth + 1) + nodeDepths(node.right, depth + 1);\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.allKindsOfNodeDepths = allKindsOfNodeDepths;\n',
        '// Average case: when the tree is balanced\n// O(n) time | O(n) space - where n is the number of nodes in the Binary Tree\nfunction allKindsOfNodeDepths(root) {\n  addNodeCounts(root);\n  addNodeDepths(root);\n  return sumAllNodeDepths(root);\n}\n\nfunction sumAllNodeDepths(node) {\n  if (node == null) return 0;\n  return sumAllNodeDepths(node.left) + sumAllNodeDepths(node.right) + node._sumOfDepths;\n}\n\nfunction addNodeDepths(node) {\n  node._sumOfDepths = 0;\n  if (node.left !== null) {\n    addNodeDepths(node.left);\n    node._sumOfDepths += node.left._sumOfDepths + node.left._numNodesInTree;\n  }\n  if (node.right !== null) {\n    addNodeDepths(node.right);\n    node._sumOfDepths += node.right._sumOfDepths + node.right._numNodesInTree;\n  }\n}\n\nfunction addNodeCounts(node) {\n  node._numNodesInTree = 1;\n  if (node.left !== null) {\n    addNodeCounts(node.left);\n    node._numNodesInTree += node.left._numNodesInTree;\n  }\n  if (node.right !== null) {\n    addNodeCounts(node.right);\n    node._numNodesInTree += node.right._numNodesInTree;\n  }\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.allKindsOfNodeDepths = allKindsOfNodeDepths;\n',
        '// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction allKindsOfNodeDepths(root) {\n  return getTreeInfo(root).sumOfAllDepths;\n}\n\nfunction getTreeInfo(tree) {\n  if (tree === null) {\n    return {\n      numNodesInTree: 0,\n      sumOfDepths: 0,\n      sumOfAllDepths: 0,\n    };\n  }\n\n  const leftTreeInfo = getTreeInfo(tree.left);\n  const rightTreeInfo = getTreeInfo(tree.right);\n\n  const sumOfLeftDepths = leftTreeInfo.sumOfDepths + leftTreeInfo.numNodesInTree;\n  const sumOfRightDepths = rightTreeInfo.sumOfDepths + rightTreeInfo.numNodesInTree;\n\n  const numNodesInTree = 1 + leftTreeInfo.numNodesInTree + rightTreeInfo.numNodesInTree;\n  const sumOfDepths = sumOfLeftDepths + sumOfRightDepths;\n  const sumOfAllDepths = sumOfDepths + leftTreeInfo.sumOfAllDepths + rightTreeInfo.sumOfAllDepths;\n\n  return {\n    numNodesInTree,\n    sumOfDepths,\n    sumOfAllDepths,\n  };\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.allKindsOfNodeDepths = allKindsOfNodeDepths;\n',
        '// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction allKindsOfNodeDepths(root, depthSum = 0, depth = 0) {\n  if (!root) return 0;\n\n  depthSum += depth;\n  return (\n    depthSum +\n    allKindsOfNodeDepths(root.left, depthSum, depth + 1) +\n    allKindsOfNodeDepths(root.right, depthSum, depth + 1)\n  );\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.allKindsOfNodeDepths = allKindsOfNodeDepths;\n',
        '// Average case: when the tree is balanced\n// O(n) time | O(h) space - where n is the number of nodes in\n// the Binary Tree and h is the height of the Binary Tree\nfunction allKindsOfNodeDepths(root, depth = 0) {\n  if (!root) return 0;\n\n  // Formula to calculate 1 + 2 + 3 + ... + depth - 1 + depth\n  const depthSum = (depth * (depth + 1)) / 2;\n  return (\n    depthSum +\n    allKindsOfNodeDepths(root.left, depth + 1) +\n    allKindsOfNodeDepths(root.right, depth + 1)\n  );\n}\n\n// This is the class of the input binary tree.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.allKindsOfNodeDepths = allKindsOfNodeDepths;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2);\n  root.left.left = new BinaryTree(4);\n  root.left.left.left = new BinaryTree(8);\n  root.left.left.right = new BinaryTree(9);\n  root.left.right = new BinaryTree(5);\n  root.right = new BinaryTree(3);\n  root.right.left = new BinaryTree(6);\n  root.right.right = new BinaryTree(7);\n  const actual = program.allKindsOfNodeDepths(root);\n  chai.expect(actual).to.deep.equal(26);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2);\n  root.left.left = new BinaryTree(4);\n  root.left.left.left = new BinaryTree(8);\n  root.left.left.right = new BinaryTree(9);\n  root.left.right = new BinaryTree(5);\n  root.right = new BinaryTree(3);\n  root.right.left = new BinaryTree(6);\n  root.right.right = new BinaryTree(7);\n  const actual = program.allKindsOfNodeDepths(root);\n  chai.expect(actual).to.deep.equal(26);\n});\n",
    },
    bigO: 'Average case: when the tree is balanced\nO(n) time | O(h) space - where n is the number of nodes in the Binary Tree and h is the height of the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: '5', right: null, value: 4 },
            { id: '5', left: '6', right: null, value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '8', value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: '5', right: null, value: 4 },
            { id: '5', left: '6', right: null, value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: '9', value: 8 },
            { id: '9', left: null, right: '10', value: 9 },
            { id: '10', left: null, right: '11', value: 10 },
            { id: '11', left: null, right: '12', value: 11 },
            { id: '12', left: '13', right: null, value: 12 },
            { id: '13', left: null, right: null, value: 13 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: '10', right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: '11', value: 10 },
            { id: '11', left: '12', right: '13', value: 11 },
            { id: '12', left: '14', right: null, value: 12 },
            { id: '13', left: '15', right: '16', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '15', left: null, right: null, value: 15 },
            { id: '16', left: null, right: null, value: 16 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: '5', right: null, value: 4 },
            { id: '5', left: '6', right: null, value: 5 },
            { id: '6', left: '7', right: null, value: 6 },
            { id: '7', left: '8', right: null, value: 7 },
            { id: '8', left: '9', right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'find-successor',
    name: 'Find Successor',
    category: 'Binary Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree (where nodes have an additional\n  pointer to their parent node) as well as a node contained in that tree and\n  returns the given node\'s successor.\n</p>\n<p>\n  A node\'s successor is the next node to be visited (immediately after the given\n  node) when traversing its tree using the in-order tree-traversal technique. A\n  node has no successor if it\'s the last node to be visited in the in-order\n  traversal.\n</p>\n<p>\n  If a node has no successor, your function should return <span>None</span> /\n  <span>null</span>.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>parent</span> node, a <span>left</span> child node, and a\n  <span>right</span> child node. Children nodes can either be\n  <span>BinaryTree</span> nodes themselves or <span>None</span> /\n  <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> = \n              1\n            /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n           2     3\n         /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \n        4     5\n       /       \n      6  \n<span class="CodeEditor-promptParameter">node</span> = 5   \n</pre>\n<h3>Sample Output</h3>\n<pre>\n1\n<span class="CodeEditor-promptComment">// This tree\'s in-order traversal order is:</span>\n<span class="CodeEditor-promptComment">// 6 -> 4 -> 2 -> 5 -> 1 -> 3 </span>\n<span class="CodeEditor-promptComment">// 1 comes immediately after 5.</span>\n</pre>\n</div>',
    hints: [
      "<p>\nStart by performing an in-order traversal of the tree and storing the nodes in an array as you go. Then, traverse the nodes that you've stored; once you find the input node, return the node immediately after it in the array.\n</p>\n",
      '\n<p>\nCan you think of a more time-efficient way to solve this problem without performing the entire in-order traversal?\n</p>\n',
      '\n<p>\nUse the fact that each node has a pointer to its parent to solve this problem in O(h) time, where h is the height of the tree.\n</p>\n',
      "\n<p>\nIf the given node has a right subtree, then the next node in the in-order traversal is simply the leftmost node in that right subtree. If it doesn't have a right subtree, then we need to traverse up the tree looking for an ancestor of this node that contains the node in question in its left subtree. The first node that we find that contains the input node in its left subtree is the one that will be visited next in the in-order traversal. If we reach the root node, and the input node isn't in the root node's left subtree, then the input node has no successor, because it must be the rightmost node of entire tree.\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', parent: null, right: '3', value: 1 },
            { id: '2', left: '4', parent: '1', right: '5', value: 2 },
            { id: '3', left: null, parent: '1', right: null, value: 3 },
            { id: '4', left: '6', parent: '2', right: null, value: 4 },
            { id: '5', left: null, parent: '2', right: null, value: 5 },
            { id: '6', left: null, parent: '4', right: null, value: 6 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node.\nEvery node has to have a unique string <span>id</span> that will be referenced by other nodes'\n<span>left</span> and <span>right</span> pointers and by the <span>root</span>. The\n<span>parent</span> pointer of each node will be deduced from the collection of <span>nodes</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
      { name: 'node', example: '5', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\nfunction findSuccessor(tree, node) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findSuccessor = findSuccessor;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfunction findSuccessor(tree, node) {\n  const inOrderTraversalOrder = getInOrderTraversalOrder(tree);\n\n  for (let idx = 0; idx < inOrderTraversalOrder.length; idx++) {\n    const currentNode = inOrderTraversalOrder[idx];\n    if (currentNode !== node) continue;\n\n    if (idx === inOrderTraversalOrder.length - 1) return null;\n\n    return inOrderTraversalOrder[idx + 1];\n  }\n}\n\nfunction getInOrderTraversalOrder(node, order = []) {\n  if (node === null) return order;\n\n  getInOrderTraversalOrder(node.left, order);\n  order.push(node);\n  getInOrderTraversalOrder(node.right, order);\n\n  return order;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findSuccessor = findSuccessor;\n',
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nfunction findSuccessor(tree, node) {\n  if (node.right != null) return getLeftmostChild(node.right);\n\n  return getRightmostParent(node);\n}\n\nfunction getLeftmostChild(node) {\n  let currentNode = node;\n  while (currentNode.left !== null) {\n    currentNode = currentNode.left;\n  }\n\n  return currentNode;\n}\n\nfunction getRightmostParent(node) {\n  let currentNode = node;\n  while (currentNode.parent !== null && currentNode.parent.right === currentNode) {\n    currentNode = currentNode.parent;\n  }\n\n  return currentNode.parent;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findSuccessor = findSuccessor;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(2);\n  root.left.parent = root;\n  root.right = new program.BinaryTree(3);\n  root.right.parent = root;\n  root.left.left = new program.BinaryTree(4);\n  root.left.left.parent = root.left;\n  root.left.right = new program.BinaryTree(5);\n  root.left.right.parent = root.left;\n  root.left.left.left = new program.BinaryTree(6);\n  root.left.left.left.parent = root.left.left;\n  const node = root.left.right;\n  const expected = root;\n  const actual = program.findSuccessor(root, node);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(2);\n  root.left.parent = root;\n  root.right = new program.BinaryTree(3);\n  root.right.parent = root;\n  root.left.left = new program.BinaryTree(4);\n  root.left.left.parent = root.left;\n  root.left.right = new program.BinaryTree(5);\n  root.left.right.parent = root.left;\n  root.left.left.left = new program.BinaryTree(6);\n  root.left.left.left.parent = root.left.left;\n  const node = root.left.right;\n  const expected = root;\n  const actual = program.findSuccessor(root, node);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(h) time | O(1) space - where h is the height of the tree',
    tests: [
      {
        node: '5',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: '3', value: 1 },
            { id: '2', left: '4', parent: '1', right: '5', value: 2 },
            { id: '3', left: null, parent: '1', right: null, value: 3 },
            { id: '4', left: '6', parent: '2', right: null, value: 4 },
            { id: '5', left: null, parent: '2', right: null, value: 5 },
            { id: '6', left: null, parent: '4', right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        node: '5',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: '3', value: 1 },
            { id: '2', left: '4', parent: '1', right: '5', value: 2 },
            { id: '3', left: null, parent: '1', right: null, value: 3 },
            { id: '4', left: null, parent: '2', right: null, value: 4 },
            { id: '5', left: '6', parent: '2', right: '7', value: 5 },
            { id: '6', left: null, parent: '5', right: null, value: 6 },
            { id: '7', left: '8', parent: '5', right: null, value: 7 },
            { id: '8', left: null, parent: '7', right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        node: '6',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: '3', value: 1 },
            { id: '2', left: '4', parent: '1', right: '5', value: 2 },
            { id: '3', left: '6', parent: '1', right: '7', value: 3 },
            { id: '4', left: null, parent: '2', right: null, value: 4 },
            { id: '5', left: null, parent: '2', right: null, value: 5 },
            { id: '6', left: null, parent: '3', right: null, value: 6 },
            { id: '7', left: null, parent: '3', right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        node: '2',
        tree: {
          nodes: [
            { id: '1', left: null, parent: null, right: '2', value: 1 },
            { id: '2', left: null, parent: '1', right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        node: '1',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: '3', value: 1 },
            { id: '2', left: null, parent: '1', right: null, value: 2 },
            { id: '3', left: '4', parent: '1', right: null, value: 3 },
            { id: '4', left: '5', parent: '3', right: null, value: 4 },
            { id: '5', left: '6', parent: '4', right: null, value: 5 },
            { id: '6', left: '7', parent: '5', right: null, value: 6 },
            { id: '7', left: null, parent: '6', right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        node: '3',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: null, value: 1 },
            { id: '2', left: '3', parent: '1', right: null, value: 2 },
            { id: '3', left: '4', parent: '2', right: null, value: 3 },
            { id: '4', left: '5', parent: '3', right: null, value: 4 },
            { id: '5', left: null, parent: '4', right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        node: '2',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: null, value: 1 },
            { id: '2', left: '3', parent: '1', right: '6', value: 2 },
            { id: '3', left: '4', parent: '2', right: null, value: 3 },
            { id: '4', left: '5', parent: '3', right: null, value: 4 },
            { id: '5', left: null, parent: '4', right: null, value: 5 },
            { id: '6', left: '7', parent: '2', right: '8', value: 6 },
            { id: '7', left: null, parent: '6', right: null, value: 7 },
            { id: '8', left: null, parent: '6', right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        node: '1',
        tree: {
          nodes: [{ id: '1', left: null, parent: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        node: '1',
        tree: {
          nodes: [
            { id: '1', left: null, parent: null, right: '2', value: 1 },
            { id: '2', left: null, parent: '1', right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        node: '1',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: '5', value: 1 },
            { id: '2', left: null, parent: '1', right: '3', value: 2 },
            { id: '3', left: null, parent: '2', right: '4', value: 3 },
            { id: '4', left: null, parent: '3', right: null, value: 4 },
            { id: '5', left: null, parent: '1', right: '6', value: 5 },
            { id: '6', left: '7', parent: '5', right: '8', value: 6 },
            { id: '7', left: null, parent: '6', right: null, value: 7 },
            { id: '8', left: null, parent: '6', right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        node: '1',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: '5', value: 1 },
            { id: '2', left: null, parent: '1', right: '3', value: 2 },
            { id: '3', left: null, parent: '2', right: '4', value: 3 },
            { id: '4', left: null, parent: '3', right: null, value: 4 },
            { id: '5', left: '9', parent: '1', right: '6', value: 5 },
            { id: '6', left: '7', parent: '5', right: '8', value: 6 },
            { id: '7', left: null, parent: '6', right: null, value: 7 },
            { id: '8', left: null, parent: '6', right: null, value: 8 },
            { id: '9', left: '10', parent: '5', right: null, value: 9 },
            { id: '10', left: '11', parent: '9', right: null, value: 10 },
            { id: '11', left: null, parent: '10', right: null, value: 11 },
          ],
          root: '1',
        },
      },
      {
        node: '1',
        tree: {
          nodes: [
            { id: '1', left: '2', parent: null, right: '3', value: 1 },
            { id: '2', left: '4', parent: '1', right: '5', value: 2 },
            { id: '3', left: null, parent: '1', right: '7', value: 3 },
            { id: '4', left: '6', parent: '2', right: null, value: 4 },
            { id: '5', left: null, parent: '2', right: null, value: 5 },
            { id: '6', left: null, parent: '4', right: null, value: 6 },
            { id: '7', left: null, parent: '3', right: '8', value: 7 },
            { id: '8', left: null, parent: '7', right: null, value: 8 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'find-nodes-distance-k',
    name: 'Find Nodes Distance K',
    category: 'Binary Trees',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given the root node of a Binary Tree, a <span>target</span> value of a\n  node that\'s contained in the tree, and a positive integer <span>k</span>.\n  Write a function that returns the values of all the nodes that are exactly\n  distance <span>k</span> from the node with <span>target</span> value.\n</p>\n<p>\n  The distance between two nodes is defined as the number of edges that must be\n  traversed to go from one node to the other. For example, the distance between\n  a node and its immediate left or right child is <span>1</span>. The same holds\n  in reverse: the distance between a node and its parent is <span>1</span>. In a\n  tree of three nodes where the root node has a left and right child, the left\n  and right children are distance <span>2</span> from each other.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<p>\n  Note that all <span>BinaryTree</span> node values will be unique, and your\n  function can return the output values in any order.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> = 1\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    2     3\n  /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n 4     5     6\n           /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n          7     8\n<span class="CodeEditor-promptParameter">target</span> = 3\n<span class="CodeEditor-promptParameter">k</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[2, 7, 8] <span class="CodeEditor-promptComment">// These values could be ordered differently.</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  Would it be easier to solve this problem if you had information about every\n  node's parent node?\n</p>\n",
      "\n<p>\n  One approach to this problem is to find the parent nodes of all nodes in the\n  tree. With this information you can perform a breadth-first search starting at\n  the target node and traverse through each neighbor (left, right, and parent\n  node) of every node, keeping track of your distance from the target node at\n  each iteration. Once you reach a node that is distance <span>k</span> from the\n  target node, you can add it to your output array. You'll have to also keep\n  track of which nodes you've visited so as to avoid visiting the same nodes\n  over and over again.\n</p>\n",
      '\n<p>\n  Another approach is to use a recursive depth-first-search algorithm as\n  follows:\n</p>\n<ul>\n  <li>\n    <b>Case #1</b>: when <span>currentNode == target</span>, search the subtree\n    rooted at <span>currentNode</span> for all nodes that are\n    <span>k</span> distance from <span>currentNode</span>.\n  </li>\n  <li>\n    <b>Case #2</b>: when <span>target</span> is in the left subtree of\n    <span>currentNode</span> at distance <span>L + 1</span>, look for nodes that\n    are distance <span>k - L - 1</span> in the right subtree of\n    <span>currentNode</span>.\n  </li>\n  <li>\n    <b>Case #3</b>: when <span>target</span> is in the right subtree of\n    <span>currentNode</span> at distance <span>L + 1</span>, do the same thing\n    as in case #2 but in the opposite subtree.\n  </li>\n  <li>\n    <b>Case #4</b>: when <span>target</span> is neither in the left nor in right\n    subtree of <span>currentNode</span>, stop recursing.\n  </li>\n</ul>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: '7', right: '8', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
      { name: 'target', example: 3, schema: { type: 'integer' } },
      { name: 'k', example: 2, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction findNodesDistanceK(tree, target, k) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findNodesDistanceK = findNodesDistanceK;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfunction findNodesDistanceK(tree, target, k) {\n  const nodesToParents = {};\n  populateNodesToParents(tree, nodesToParents);\n  const targetNode = getNodeFromValue(target, tree, nodesToParents);\n\n  return breadthFirstSearchForNodesDistanceK(targetNode, nodesToParents, k);\n}\n\nfunction breadthFirstSearchForNodesDistanceK(targetNode, nodesToParents, k) {\n  // We could use a more legitimate queue structure instead of a standard\n  // array if we wanted to optimize our `.shift() operations.`\n  const queue = [[targetNode, 0]];\n  const seen = new Set([targetNode.value]);\n  while (queue.length > 0) {\n    const [currentNode, distanceFromTarget] = queue.shift();\n\n    if (distanceFromTarget === k) {\n      const nodesDistanceK = queue.map(pair => pair[0].value);\n      nodesDistanceK.push(currentNode.value);\n      return nodesDistanceK;\n    }\n\n    const connectedNodes = [currentNode.left, currentNode.right, nodesToParents[currentNode.value]];\n    for (const node of connectedNodes) {\n      if (node === null) continue;\n\n      if (seen.has(node.value)) continue;\n\n      seen.add(node.value);\n      queue.push([node, distanceFromTarget + 1]);\n    }\n  }\n\n  return [];\n}\n\nfunction getNodeFromValue(value, tree, nodesToParents) {\n  if (tree.value === value) return tree;\n\n  const nodeParent = nodesToParents[value];\n  if (nodeParent.left !== null && nodeParent.left.value === value) return nodeParent.left;\n\n  return nodeParent.right;\n}\n\nfunction populateNodesToParents(node, nodesToParents, parent = null) {\n  if (node !== null) {\n    nodesToParents[node.value] = parent;\n    populateNodesToParents(node.left, nodesToParents, node);\n    populateNodesToParents(node.right, nodesToParents, node);\n  }\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findNodesDistanceK = findNodesDistanceK;\n',
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfunction findNodesDistanceK(tree, target, k) {\n  const nodesDistanceK = [];\n  findDistanceFromNodeToTarget(tree, target, k, nodesDistanceK);\n  return nodesDistanceK;\n}\n\nfunction findDistanceFromNodeToTarget(node, target, k, nodesDistanceK) {\n  if (node === null) return -1;\n\n  if (node.value === target) {\n    addSubtreeNodeAtDistanceK(node, 0, k, nodesDistanceK);\n    return 1;\n  }\n\n  const leftDistance = findDistanceFromNodeToTarget(node.left, target, k, nodesDistanceK);\n  const rightDistance = findDistanceFromNodeToTarget(node.right, target, k, nodesDistanceK);\n\n  if (leftDistance === k || rightDistance === k) nodesDistanceK.push(node.value);\n\n  if (leftDistance !== -1) {\n    addSubtreeNodeAtDistanceK(node.right, leftDistance + 1, k, nodesDistanceK);\n    return leftDistance + 1;\n  }\n\n  if (rightDistance !== -1) {\n    addSubtreeNodeAtDistanceK(node.left, rightDistance + 1, k, nodesDistanceK);\n    return rightDistance + 1;\n  }\n\n  return -1;\n}\n\nfunction addSubtreeNodeAtDistanceK(node, distance, k, nodesDistanceK) {\n  if (node === null) return;\n\n  if (distance === k) nodesDistanceK.push(node.value);\n  else {\n    addSubtreeNodeAtDistanceK(node.left, distance + 1, k, nodesDistanceK);\n    addSubtreeNodeAtDistanceK(node.right, distance + 1, k, nodesDistanceK);\n  }\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.findNodesDistanceK = findNodesDistanceK;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(2);\n  root.right = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(4);\n  root.left.right = new program.BinaryTree(5);\n  root.right.right = new program.BinaryTree(6);\n  root.right.right.left = new program.BinaryTree(7);\n  root.right.right.right = new program.BinaryTree(8);\n  const target = 3;\n  const k = 2;\n  const expected = [2, 7, 8];\n  const actual = program.findNodesDistanceK(root, target, k);\n  actual.sort();\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(1);\n  root.left = new program.BinaryTree(2);\n  root.right = new program.BinaryTree(3);\n  root.left.left = new program.BinaryTree(4);\n  root.left.right = new program.BinaryTree(5);\n  root.right.right = new program.BinaryTree(6);\n  root.right.right.left = new program.BinaryTree(7);\n  root.right.right.right = new program.BinaryTree(8);\n  const target = 3;\n  const k = 2;\n  const expected = [2, 7, 8];\n  const actual = program.findNodesDistanceK(root, target, k);\n  actual.sort();\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the number of nodes in the tree',
    tests: [
      {
        k: 2,
        target: 3,
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: '7', right: '8', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        k: 3,
        target: 2,
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: '5', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        k: 6,
        target: 8,
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: '5', right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: '8', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        k: 1,
        target: 3,
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: '5', right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: '8', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        k: 2,
        target: 1,
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        k: 2,
        target: 8,
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        k: 6,
        target: 6,
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: null, right: '5', value: 3 },
            { id: '4', left: '6', right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        k: 1,
        target: 1,
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        k: 17,
        target: 6,
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: null, right: '5', value: 3 },
            { id: '4', left: '6', right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        k: 2,
        target: 2,
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: '10', right: '11', value: 5 },
            { id: '6', left: '12', right: '13', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '13', left: null, right: null, value: 13 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'height-balanced-binary-tree',
    name: 'Height Balanced Binary Tree',
    category: 'Binary Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given the root node of a Binary Tree. Write a function that returns\n  <span>true</span> if this Binary Tree is height balanced and\n  <span>false</span> if it isn\'t.\n</p>\n<p>\n  A Binary Tree is height balanced if for each node in the tree, the difference\n  between the height of its left subtree and the height of its right subtree is\n  at most <span>1</span>.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> = 1\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    2     3\n  /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n 4     5     6\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    7     8\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      "<p>\n  To solve this problem, you'll have to determine if <b>every</b> subtree in the\n  Binary Tree is balanced. Which subtrees do you know will always be balanced?\n</p>\n",
      "\n<p>\n  To determine if a subtree is balanced, you need to know the height of its left\n  and right subtrees. The only exception to this is if a subtree has no left and\n  right subtrees (i.e., it's just a leaf node); in that case, the subtree must\n  be balanced.\n</p>\n",
      "\n<p>\n  Recursively calculate the left and right subtree heights from each node. Once\n  you know the heights of a particular node's left and right subtrees, you can\n  determine if the subtree rooted at that node is balanced. If a subtree ever\n  isn't balanced, you can immediately conclude that the entire tree isn't\n  balanced. If you make it through the entire tree without finding any\n  unbalanced subtrees, and if you determine that the heights of the main two\n  subtrees aren't more than <span>1</span> apart, then the entire tree is\n  balanced.\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction heightBalancedBinaryTree(tree) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.heightBalancedBinaryTree = heightBalancedBinaryTree;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass TreeInfo {\n  constructor(isBalanced, height) {\n    this.isBalanced = isBalanced;\n    this.height = height;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the binary tree\nfunction heightBalancedBinaryTree(tree) {\n  const treeInfo = getTreeInfo(tree);\n  return treeInfo.isBalanced;\n}\n\nfunction getTreeInfo(node) {\n  if (node === null) return new TreeInfo(true, -1);\n\n  const leftSubtreeInfo = getTreeInfo(node.left);\n  const rightSubtreeInfo = getTreeInfo(node.right);\n\n  const isBalanced =\n    leftSubtreeInfo.isBalanced &&\n    rightSubtreeInfo.isBalanced &&\n    Math.abs(leftSubtreeInfo.height - rightSubtreeInfo.height) <= 1;\n  const height = Math.max(leftSubtreeInfo.height, rightSubtreeInfo.height) + 1;\n  return new TreeInfo(isBalanced, height);\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.heightBalancedBinaryTree = heightBalancedBinaryTree;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {BinaryTree} = program;\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2);\n  root.right = new BinaryTree(3);\n  root.left.left = new BinaryTree(4);\n  root.left.right = new BinaryTree(5);\n  root.right.right = new BinaryTree(6);\n  root.left.right.left = new BinaryTree(7);\n  root.left.right.right = new BinaryTree(8);\n  const expected = true;\n  const actual = program.heightBalancedBinaryTree(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst {BinaryTree} = program;\n\nit('Test Case #1', function () {\n  const root = new BinaryTree(1);\n  root.left = new BinaryTree(2);\n  root.right = new BinaryTree(3);\n  root.left.left = new BinaryTree(4);\n  root.left.right = new BinaryTree(5);\n  root.right.right = new BinaryTree(6);\n  root.left.right.left = new BinaryTree(7);\n  root.left.right.right = new BinaryTree(8);\n  const expected = true;\n  const actual = program.heightBalancedBinaryTree(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(h) space - where n is the number of nodes in the binary tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: '9', right: '10', value: 6 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '11', right: '6', value: 3 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: '9', right: '10', value: 6 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: null, right: '5', value: 4 },
            { id: '4', left: '6', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '7', value: 2 },
            { id: '3', left: '8', right: '5', value: 4 },
            { id: '4', left: '6', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: '9', right: '10', value: 5 },
            { id: '6', left: '11', right: '12', value: 6 },
            { id: '7', left: '13', right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '13', left: null, right: null, value: 13 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: '9', value: 4 },
            { id: '5', left: '9', right: '10', value: 5 },
            { id: '6', left: null, right: '12', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '12', left: null, right: '13', value: 12 },
            { id: '13', left: null, right: null, value: 13 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '4', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 2 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: null, value: 4 },
            { id: '5', left: '12', right: null, value: 5 },
            { id: '6', left: '9', right: '10', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: '11', right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '12', left: null, right: null, value: 12 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: '8', right: null, value: 4 },
            { id: '5', left: '12', right: null, value: 5 },
            { id: '6', left: '9', right: '10', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '12', left: null, right: null, value: 12 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'compare-leaf-traversal',
    name: 'Compare Leaf Traversal',
    category: 'Binary Trees',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in the root nodes of two Binary Trees and returns\n  a boolean representing whether their leaf traversals are the same.\n</p>\n<p>\n  The leaf traversal of a Binary Tree traverses only its leaf nodes from left to\n  right. A leaf node is any node that has no <span>left</span> or\n  <span>right</span> children.\n</p>\n<p>\n  For example, the leaf traversal of the following Binary Tree is\n  <span>1, 3, 2</span>.\n</p>\n<pre>\n   4\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n1     5\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   3     2\n</pre>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree1</span> = 1\n      /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     2     3\n   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  4     5     6\n      /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     7     8\n<span class="CodeEditor-promptParameter">tree2</span> = 1\n      /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     2     3\n   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  4     7    5\n            /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n           8    6\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      "<p>\n  To traverse the leaf nodes of a tree from left to right, you'll need to use a\n  pre-order traversal.\n</p>\n",
      "\n<p>\n  The simplest approach to solving this problem is to perform a pre-order\n  traversal on both trees, to store their leaf nodes in arrays in the order in\n  which they're visited, and to then compare the two resulting arrays. This\n  solutions works, but it's not optimal from a space-complexity perspective. Can\n  you think of a way to solve this problem using less extra space? It's possible\n  to solve this with <span>O(h1 + h2)</span> space or better, where\n  <span>h1</span> is the height of <span>tree1</span> and <span>h2</span> is the\n  height of <span>tree2</span>.\n</p>\n",
      "\n<p>\n  To solve this problem with a more optimal space complexity, you can perform\n  pre-order traversals on both trees at the same time. As you traverse the\n  trees, you need to look for the next leaf node in each tree and pause the\n  traversal as soon as you find it. Once you've found the next leaf node in both\n  trees, you can compare their values and see if they match; if they do,\n  continue the traversal , and repeat the process. If they don't match, the leaf\n  traversals aren't the same, and you can return <span>false</span>.\n</p>\n",
      "\n<p>\n  Another unique way to solve this problem is to connect all of the leaf nodes\n  in each individual tree so as to form two linked lists. Since the leaf nodes\n  don't have any children, you can use their <span>right</span> pointers to\n  store the next leaf nodes in the leaf traversals. And since you're reusing the\n  input trees to store the leaf traversals, the only extra space you'll be using\n  comes from the recursion used in the traversal of the trees. Once both trees\n  have their leaf nodes connected, you can iterate through the linked lists and\n  check if they're the same. To compare the linked lists, you'll need to keep\n  track of their heads (the first leaf node in each tree).\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree1',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
      {
        name: 'tree2',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '7', value: 2 },
            { id: '3', left: null, right: '5', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '8', right: '6', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction compareLeafTraversal(tree1, tree2) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.compareLeafTraversal = compareLeafTraversal;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n + m) time | O(h1 + h2) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nfunction compareLeafTraversal(tree1, tree2) {\n  const tree1TraversalStack = [tree1];\n  const tree2TraversalStack = [tree2];\n\n  while (tree1TraversalStack.length > 0 && tree2TraversalStack.length > 0) {\n    const tree1Leaf = getNextLeafNode(tree1TraversalStack);\n    const tree2Leaf = getNextLeafNode(tree2TraversalStack);\n\n    if (tree1Leaf.value !== tree2Leaf.value) return false;\n  }\n\n  return tree1TraversalStack.length === 0 && tree2TraversalStack.length === 0;\n}\n\nfunction getNextLeafNode(traversalStack) {\n  let currentNode = traversalStack.pop();\n\n  while (!isLeafNode(currentNode)) {\n    if (currentNode.right !== null) traversalStack.push(currentNode.right);\n\n    // We purposely add the left node to the stack after the\n    // right node so that it gets popped off the stack first.\n    if (currentNode.left !== null) traversalStack.push(currentNode.left);\n\n    currentNode = traversalStack.pop();\n  }\n\n  return currentNode;\n}\n\nfunction isLeafNode(node) {\n  return node.left === null && node.right === null;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.compareLeafTraversal = compareLeafTraversal;\n',
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first\n// Binary Tree, m is the number in the second, h1 is the height of the first Binary\n// Tree, and h2 is the height of the second\nfunction compareLeafTraversal(tree1, tree2) {\n  const [tree1LeafNodesLinkedList, _1] = connectLeafNodes(tree1);\n  const [tree2LeafNodesLinkedList, _2] = connectLeafNodes(tree2);\n\n  let list1CurrentNode = tree1LeafNodesLinkedList;\n  let list2CurrentNode = tree2LeafNodesLinkedList;\n  while (list1CurrentNode !== null && list2CurrentNode !== null) {\n    if (list1CurrentNode.value !== list2CurrentNode.value) return false;\n\n    list1CurrentNode = list1CurrentNode.right;\n    list2CurrentNode = list2CurrentNode.right;\n  }\n\n  return list1CurrentNode === null && list2CurrentNode === null;\n}\n\nfunction connectLeafNodes(currentNode, head = null, previousNode = null) {\n  if (currentNode === null) return [head, previousNode];\n\n  if (isLeafNode(currentNode)) {\n    if (previousNode === null) {\n      head = currentNode;\n    } else {\n      previousNode.right = currentNode;\n    }\n\n    previousNode = currentNode;\n  }\n\n  const [leftHead, leftPreviousNode] = connectLeafNodes(currentNode.left, head, previousNode);\n  return connectLeafNodes(currentNode.right, leftHead, leftPreviousNode);\n}\n\nfunction isLeafNode(node) {\n  return node.left === null && node.right === null;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.compareLeafTraversal = compareLeafTraversal;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(2);\n  tree1.right = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(4);\n  tree1.left.right = new program.BinaryTree(5);\n  tree1.right.right = new program.BinaryTree(6);\n  tree1.left.right.left = new program.BinaryTree(7);\n  tree1.left.right.right = new program.BinaryTree(8);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(3);\n  tree2.left.left = new program.BinaryTree(4);\n  tree2.left.right = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(5);\n  tree2.right.right.left = new program.BinaryTree(8);\n  tree2.right.right.right = new program.BinaryTree(6);\n\n  const expected = true;\n  const actual = program.compareLeafTraversal(tree1, tree2);\n\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(2);\n  tree1.right = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(4);\n  tree1.left.right = new program.BinaryTree(5);\n  tree1.right.right = new program.BinaryTree(6);\n  tree1.left.right.left = new program.BinaryTree(7);\n  tree1.left.right.right = new program.BinaryTree(8);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(3);\n  tree2.left.left = new program.BinaryTree(4);\n  tree2.left.right = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(5);\n  tree2.right.right.left = new program.BinaryTree(8);\n  tree2.right.right.right = new program.BinaryTree(6);\n\n  const expected = true;\n  const actual = program.compareLeafTraversal(tree1, tree2);\n\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n + m) time | O(max(h1, h2)) space - where n is the number of nodes in the first Binary Tree, m is the number in the second, h1 is the height of the first Binary Tree, and h2 is the height of the second',
    tests: [
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '7', value: 2 },
            { id: '3', left: null, right: '5', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '8', right: '6', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
        tree2: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '4', left: '5', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '7', right: '8', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '7', value: 2 },
            { id: '3', left: null, right: '5', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '8', right: '6', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: '9', right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [{ id: '2', left: null, right: null, value: 2 }],
          root: '2',
        },
        tree2: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '2', left: null, right: '1', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '2',
        },
        tree2: {
          nodes: [
            { id: '2', left: null, right: null, value: 2 },
            { id: '1', left: '2', right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: null, value: 2 },
            { id: '3', left: null, right: '5', value: 3 },
            { id: '4', left: '7', right: null, value: 4 },
            { id: '5', left: '8', right: '9', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: '6', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: '6', right: null, value: 4 },
            { id: '5', left: '8', right: '9', value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: '8', right: null, value: 6 },
            { id: '7', left: null, right: '9', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: '4', right: '3', value: 2 },
            { id: '3', left: '5', right: '6', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: '7', right: '9', value: 6 },
            { id: '7', left: '8', right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '8', value: 1 },
            { id: '2', left: '3', right: '5', value: 2 },
            { id: '3', left: '4', right: '6', value: 3 },
            { id: '4', left: null, right: '7', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '8', right: '2', value: 1 },
            { id: '2', left: '5', right: '3', value: 2 },
            { id: '3', left: '6', right: '4', value: 3 },
            { id: '4', left: '7', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '8', value: 1 },
            { id: '2', left: '3', right: '5', value: 2 },
            { id: '3', left: '4', right: null, value: 3 },
            { id: '4', left: '6', right: '7', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '8', right: '2', value: 1 },
            { id: '2', left: '5', right: '3', value: 2 },
            { id: '3', left: '6', right: '4', value: 3 },
            { id: '4', left: '7', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '8', value: 1 },
            { id: '2', left: '3', right: '5', value: 2 },
            { id: '3', left: '4', right: '6', value: 3 },
            { id: '4', left: null, right: '7', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '7', right: '2', value: 1 },
            { id: '2', left: '6', right: '3', value: 2 },
            { id: '3', left: '5', right: '4', value: 3 },
            { id: '4', left: '8', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '8', value: 1 },
            { id: '2', left: '3', right: '5', value: 2 },
            { id: '3', left: '4', right: '6', value: 3 },
            { id: '4', left: null, right: '7', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: '1-2', value: 8 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '7', right: '2', value: 1 },
            { id: '2', left: '6', right: '3', value: 2 },
            { id: '3', left: '5', right: '4', value: 3 },
            { id: '4', left: '8', right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: null, right: '1-2', value: 8 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'merge-binary-trees',
    name: 'Merge Binary Trees',
    category: 'Binary Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    Write a function that takes in two Binary Trees, merges them, and returns\n    the resulting tree. If two nodes overlap during the merge, the value of the\n    merged node should be the sum of the overlapping nodes\' values.\n  </p>\n  <p>\n    Note that your solution can either mutate the input trees or return a new\n    tree.\n  </p>\n  <p>\n    Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n    <span>left</span> child node, and a <span>right</span> child node. Children\n    nodes can either be <span>BinaryTree</span> nodes themselves or\n    <span>None</span> / <span>null</span>.\n  </p>\n  <h3>Sample Input</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">tree1</span> =   1\n        /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       3     2\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    7     4\n\n<span class="CodeEditor-promptParameter">tree2</span> =   1\n        /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       5     9\n     /      / \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    2      7   6\n</pre>\n  <h3>Sample Output</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">output</span> =  2\n        /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      8      11\n    /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\    /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  9     4  7    6\n</pre>\n</div>',
    hints: [
      '<p>\nIf the function takes two tree nodes as parameters then what should be returned if either of the two nodes is null?\nRemember, if two nodes overlap during the merger then sum the values, otherwise use the existing node. How can you sum\nthe tree node values when they overlap?\n</p>\n',
      "\n<p>\nIf two tree nodes overlap then sum the values into either one of the nodes. This node will be returned from the function.\nRecursively call the function twice passing in both trees' left nodes as well as their right nodes.\n</p>\n",
      '\n<p>\nThe iterative approach to this problem uses a stack in replacement of the recusions stack space. What would you push onto\nthe stack in order to traverse and merge the binary trees?\n</p>\n',
      '\n<p>\nYou can either use a single stack and push associated pairs of nodes on the stack,\nor you can maintain a stack for each tree.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree1',
        example: {
          nodes: [{ id: '7', left: null, right: null, value: 7 }],
          root: '7',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
      {
        name: 'tree2',
        example: {
          nodes: [
            { id: '2', left: '3', right: '6', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '2',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.BinaryTree = BinaryTree;\n\nfunction mergeBinaryTrees(tree1, tree2) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the line below.\nexports.mergeBinaryTrees = mergeBinaryTrees;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nfunction mergeBinaryTrees(tree1, tree2) {\n  if (tree1 === null) return tree2;\n  if (tree2 === null) return tree1;\n\n  tree1.value += tree2.value;\n  tree1.left = mergeBinaryTrees(tree1.left, tree2.left);\n  tree1.right = mergeBinaryTrees(tree1.right, tree2.right);\n  return tree1;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.mergeBinaryTrees = mergeBinaryTrees;\n',
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the smaller of the\n// two trees and h is the height of the shorter tree.\nfunction mergeBinaryTrees(tree1, tree2) {\n  if (tree1 === null) return tree2;\n\n  const tree1Stack = [tree1];\n  const tree2Stack = [tree2];\n\n  while (tree1Stack.length > 0) {\n    const tree1Node = tree1Stack.pop();\n    const tree2Node = tree2Stack.pop();\n\n    if (tree2Node === null) continue;\n\n    tree1Node.value += tree2Node.value;\n\n    if (tree1Node.left === null) {\n      tree1Node.left = tree2Node.left;\n    } else {\n      tree1Stack.push(tree1Node.left);\n      tree2Stack.push(tree2Node.left);\n    }\n\n    if (tree1Node.right === null) {\n      tree1Node.right = tree2Node.right;\n    } else {\n      tree1Stack.push(tree1Node.right);\n      tree2Stack.push(tree2Node.right);\n    }\n  }\n\n  return tree1;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.mergeBinaryTrees = mergeBinaryTrees;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(7);\n  tree1.left.right = new program.BinaryTree(4);\n  tree1.right = new program.BinaryTree(2);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(5);\n  tree2.left.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(9);\n  tree2.right.left = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(6);\n\n  const actual = program.mergeBinaryTrees(tree1, tree2);\n  chai.expect(actual.value).to.deep.equal(2);\n  chai.expect(actual.left.value).to.deep.equal(8);\n  chai.expect(actual.left.left.value).to.deep.equal(9);\n  chai.expect(actual.left.right.value).to.deep.equal(4);\n  chai.expect(actual.right.value).to.deep.equal(11);\n  chai.expect(actual.right.left.value).to.deep.equal(7);\n  chai.expect(actual.right.right.value).to.deep.equal(6);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree1 = new program.BinaryTree(1);\n  tree1.left = new program.BinaryTree(3);\n  tree1.left.left = new program.BinaryTree(7);\n  tree1.left.right = new program.BinaryTree(4);\n  tree1.right = new program.BinaryTree(2);\n\n  const tree2 = new program.BinaryTree(1);\n  tree2.left = new program.BinaryTree(5);\n  tree2.left.left = new program.BinaryTree(2);\n  tree2.right = new program.BinaryTree(9);\n  tree2.right.left = new program.BinaryTree(7);\n  tree2.right.right = new program.BinaryTree(6);\n\n  const actual = program.mergeBinaryTrees(tree1, tree2);\n  chai.expect(actual.value).to.deep.equal(2);\n  chai.expect(actual.left.value).to.deep.equal(8);\n  chai.expect(actual.left.left.value).to.deep.equal(9);\n  chai.expect(actual.left.right.value).to.deep.equal(4);\n  chai.expect(actual.right.value).to.deep.equal(11);\n  chai.expect(actual.right.left.value).to.deep.equal(7);\n  chai.expect(actual.right.right.value).to.deep.equal(6);\n});\n",
    },
    bigO: 'O(n) time | O(h) space - where n is the number of nodes in the smaller of the two trees and h is the height of the shorter tree.',
    tests: [
      {
        tree1: {
          nodes: [{ id: '7', left: null, right: null, value: 7 }],
          root: '7',
        },
        tree2: {
          nodes: [
            { id: '2', left: '3', right: '6', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '2',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '3', right: '2', value: 1 },
            { id: '3', left: '5', right: null, value: 3 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '2', left: '3', right: '6', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '2',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '3', right: '2', value: 1 },
            { id: '3', left: '7', right: '4', value: 3 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '5', right: '9', value: 1 },
            { id: '5', left: '2', right: null, value: 5 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '9', left: '7', right: '6', value: 9 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '4', left: '5', right: '6', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '4',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '4', left: '5', right: '6', value: 4 },
            { id: '5', left: '1', right: '8', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '4',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '4', left: '5', right: '6', value: 4 },
            { id: '5', left: '1', right: '8', value: 5 },
            { id: '6', left: '10', right: '15', value: 6 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '15', left: null, right: null, value: 15 },
          ],
          root: '4',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '5', right: '8', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '4', left: '5', right: '6', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '4',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '2', left: '4', right: '1', value: 2 },
            { id: '4', left: '6', right: null, value: 4 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '2',
        },
        tree2: {
          nodes: [
            { id: '3', left: '1', right: '6', value: 3 },
            { id: '1', left: null, right: '9', value: 1 },
            { id: '6', left: null, right: '8', value: 6 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '3',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: '6', right: '7', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
        tree2: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '3', right: null, value: 1 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: null, right: '4', value: 1 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree1: {
          nodes: [
            { id: '1', left: '4', right: null, value: 1 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
        tree2: {
          nodes: [
            { id: '1', left: null, right: '3', value: 1 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'find-closest-value-in-bst',
    name: 'Find Closest Value In BST',
    category: 'Binary Search Trees',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Search Tree (BST) and a target integer\n  value and returns the closest value to that target value contained in the BST.\n</p>\n<p>You can assume that there will only be one closest value.</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =   10\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      5      15\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   2     5 13   22\n /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n1            14\n<span class="CodeEditor-promptParameter">target</span> = 12\n</pre>\n<h3>Sample Output</h3>\n<pre>13</pre>\n</div>',
    hints: [
      "<p>\nTry traversing the BST node by node, all the while keeping track of the node with the value closest to the target value. Calculating the absolute value of the difference between a node's value and the target value should allow you to check if that node is closer than the current closest one.\n</p>\n",
      '\n<p>\nMake use of the BST property to determine what side of any given node has values close to the target value and is therefore worth exploring.\n</p>\n',
      '\n<p>\nWhat are the advantages and disadvantages of solving this problem iteratively as opposed to recursively?\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
      { name: 'target', example: 12, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function findClosestValueInBst(tree, target) {\n  // Write your code here.\n}\n\n// This is the class of the input tree. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// Do not edit the line below.\nexports.findClosestValueInBst = findClosestValueInBst;\n',
      solutions: [
        '// Average: O(log(n)) time | O(log(n)) space\n// Worst: O(n) time | O(n) space\nfunction findClosestValueInBst(tree, target) {\n  return findClosestValueInBstHelper(tree, target, tree.value);\n}\n\nfunction findClosestValueInBstHelper(tree, target, closest) {\n  if (tree === null) return closest;\n  if (Math.abs(target - closest) > Math.abs(target - tree.value)) {\n    closest = tree.value;\n  }\n  if (target < tree.value) {\n    return findClosestValueInBstHelper(tree.left, target, closest);\n  } else if (target > tree.value) {\n    return findClosestValueInBstHelper(tree.right, target, closest);\n  } else {\n    return closest;\n  }\n}\n\n// This is the class of the input tree.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.findClosestValueInBst = findClosestValueInBst;\n',
        '// Average: O(log(n)) time | O(1) space\n// Worst: O(n) time | O(1) space\nfunction findClosestValueInBst(tree, target) {\n  return findClosestValueInBstHelper(tree, target, tree.value);\n}\n\nfunction findClosestValueInBstHelper(tree, target, closest) {\n  let currentNode = tree;\n  while (currentNode !== null) {\n    if (Math.abs(target - closest) > Math.abs(target - currentNode.value)) {\n      closest = currentNode.value;\n    }\n    if (target < currentNode.value) {\n      currentNode = currentNode.left;\n    } else if (target > currentNode.value) {\n      currentNode = currentNode.right;\n    } else {\n      break;\n    }\n  }\n  return closest;\n}\n\n// This is the class of the input tree.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.findClosestValueInBst = findClosestValueInBst;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n  const expected = 13;\n  const actual = program.findClosestValueInBst(root, 12);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n  const expected = 13;\n  const actual = program.findClosestValueInBst(root, 12);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'Average: O(log(n)) time | O(1) space - where n is the number of nodes in the BST\nWorst: O(n) time | O(1) space - where n is the number of nodes in the BST',
    tests: [
      {
        target: 12,
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        target: 100,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: 208,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: 4500,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: 4501,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: -70,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: 2000,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: 6,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: 30000,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: -1,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: 29751,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        target: 29749,
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
    ],
  },
  {
    id: 'bst-construction',
    name: 'BST Construction',
    category: 'Binary Search Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a <span>BST</span> class for a Binary Search Tree. The class should\n  support:\n</p>\n<ul>\n  <li>Inserting values with the <span>insert</span> method.</li>\n  <li>\n    Removing values with the <span>remove</span> method; this method should\n    only remove the first instance of a given value.\n  </li>\n  <li>Searching for values with the <span>contains</span> method.</li>\n</ul>\n<p>\n  Note that you can\'t remove values from a single-node tree. In other words,\n  calling the <span>remove</span> method on a single-node tree should simply not\n  do anything.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class="CodeEditor-promptComment">// Assume the following BST has already been created:</span>\n         10\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      5      15\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   2     5 13   22\n /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n1            14\n\n<span class="CodeEditor-promptComment">// All operations below are performed sequentially.</span>\n<span class="CodeEditor-promptParameter">insert</span>(12):   10\n            /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n           5      15\n         /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        2     5 13   22\n      /        /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     1        12  14\n\n<span class="CodeEditor-promptParameter">remove</span>(10):   12\n            /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n           5      15\n         /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        2     5 13   22\n      /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     1            14\n\n<span class="CodeEditor-promptParameter">contains</span>(15): true\n</pre>\n</div>',
    hints: [
      "<p>\nAs you try to insert, find, or a remove a value into, in, or from a BST, you will have to traverse the tree's nodes. The BST property allows you to eliminate half of the remaining tree at each node that you traverse: if the target value is strictly smaller than a node's value, then it must be (or can only be) located to the left of the node, otherwise it must be (or can only be) to the right of that node.\n</p>\n",
      "\n<p>\nTraverse the BST all the while applying the logic described in Hint #1. For insertion, add the target value to the BST once you reach a leaf (None / null) node. For searching, if you reach a leaf node without having found the target value that means the value isn't in the BST. For removal, consider the various cases that you might encounter: the node you need to remove might have two children nodes, one, or none; it might also be the root node; make sure to account for all of these cases.\n</p>\n",
      '\n<p>\nWhat are the advantages and disadvantages of implementing these methods iteratively as opposed to recursively?\n</p>',
    ],
    customInputVars: [
      { name: 'rootValue', example: 10, schema: { type: 'integer' } },
      {
        name: 'classMethodsToCall',
        example: [
          { arguments: [5], method: 'insert' },
          { arguments: [15], method: 'insert' },
          { arguments: [2], method: 'insert' },
          { arguments: [5], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [22], method: 'insert' },
          { arguments: [1], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [12], method: 'insert' },
          { arguments: [10], method: 'remove' },
          { arguments: [15], method: 'contains' },
        ],
        schema: {
          description:
            'These methods will be called in the order that they appear in below\non a <span>BST</span> built from the <span>rootValue</span> and with their respective arguments.\n',
          items: {
            properties: {
              arguments: {
                items: { type: 'integer' },
                maxItems: 1,
                minItems: 1,
                type: 'array',
              },
              method: {
                enum: ['contains', 'insert', 'remove'],
                type: 'string',
              },
            },
            required: ['method', 'arguments'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Do not edit the class below except for\n// the insert, contains, and remove methods.\n// Feel free to add new properties and methods\n// to the class.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value) {\n    // Write your code here.\n    // Do not edit the return statement of this method.\n    return this;\n  }\n\n  contains(value) {\n    // Write your code here.\n  }\n\n  remove(value) {\n    // Write your code here.\n    // Do not edit the return statement of this method.\n    return this;\n  }\n}\n\n// Do not edit the line below.\nexports.BST = BST;\n',
      solutions: [
        'class BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  insert(value) {\n    if (value < this.value) {\n      if (this.left === null) {\n        this.left = new BST(value);\n      } else {\n        this.left.insert(value);\n      }\n    } else {\n      if (this.right === null) {\n        this.right = new BST(value);\n      } else {\n        this.right.insert(value);\n      }\n    }\n    return this;\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  contains(value) {\n    if (value < this.value) {\n      if (this.left === null) {\n        return false;\n      } else {\n        return this.left.contains(value);\n      }\n    } else if (value > this.value) {\n      if (this.right === null) {\n        return false;\n      } else {\n        return this.right.contains(value);\n      }\n    } else {\n      return true;\n    }\n  }\n\n  // Average: O(log(n)) time | O(log(n)) space\n  // Worst: O(n) time | O(n) space\n  remove(value, parent = null) {\n    if (value < this.value) {\n      if (this.left !== null) {\n        this.left.remove(value, this);\n      }\n    } else if (value > this.value) {\n      if (this.right !== null) {\n        this.right.remove(value, this);\n      }\n    } else {\n      if (this.left !== null && this.right !== null) {\n        this.value = this.right.getMinValue();\n        this.right.remove(this.value, this);\n      } else if (parent === null) {\n        if (this.left !== null) {\n          this.value = this.left.value;\n          this.right = this.left.right;\n          this.left = this.left.left;\n        } else if (this.right !== null) {\n          this.value = this.right.value;\n          this.left = this.right.left;\n          this.right = this.right.right;\n        } else {\n          // This is a single-node tree; do nothing.\n        }\n      } else if (parent.left === this) {\n        parent.left = this.left !== null ? this.left : this.right;\n      } else if (parent.right === this) {\n        parent.right = this.left !== null ? this.left : this.right;\n      }\n    }\n    return this;\n  }\n\n  getMinValue() {\n    if (this.left === null) {\n      return this.value;\n    } else {\n      return this.left.getMinValue();\n    }\n  }\n}\n\nexports.BST = BST;\n',
        'class BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  insert(value) {\n    let currentNode = this;\n    while (true) {\n      if (value < currentNode.value) {\n        if (currentNode.left === null) {\n          currentNode.left = new BST(value);\n          break;\n        } else {\n          currentNode = currentNode.left;\n        }\n      } else {\n        if (currentNode.right === null) {\n          currentNode.right = new BST(value);\n          break;\n        } else {\n          currentNode = currentNode.right;\n        }\n      }\n    }\n    return this;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  contains(value) {\n    let currentNode = this;\n    while (currentNode !== null) {\n      if (value < currentNode.value) {\n        currentNode = currentNode.left;\n      } else if (value > currentNode.value) {\n        currentNode = currentNode.right;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Average: O(log(n)) time | O(1) space\n  // Worst: O(n) time | O(1) space\n  remove(value, parentNode = null) {\n    let currentNode = this;\n    while (currentNode !== null) {\n      if (value < currentNode.value) {\n        parentNode = currentNode;\n        currentNode = currentNode.left;\n      } else if (value > currentNode.value) {\n        parentNode = currentNode;\n        currentNode = currentNode.right;\n      } else {\n        if (currentNode.left !== null && currentNode.right !== null) {\n          currentNode.value = currentNode.right.getMinValue();\n          currentNode.right.remove(currentNode.value, currentNode);\n        } else if (parentNode === null) {\n          if (currentNode.left !== null) {\n            currentNode.value = currentNode.left.value;\n            currentNode.right = currentNode.left.right;\n            currentNode.left = currentNode.left.left;\n          } else if (currentNode.right !== null) {\n            currentNode.value = currentNode.right.value;\n            currentNode.left = currentNode.right.left;\n            currentNode.right = currentNode.right.right;\n          } else {\n            // This is a single-node tree; do nothing.\n          }\n        } else if (parentNode.left === currentNode) {\n          parentNode.left = currentNode.left !== null ? currentNode.left : currentNode.right;\n        } else if (parentNode.right === currentNode) {\n          parentNode.right = currentNode.left !== null ? currentNode.left : currentNode.right;\n        }\n        break;\n      }\n    }\n    return this;\n  }\n\n  getMinValue() {\n    let currentNode = this;\n    while (currentNode.left !== null) {\n      currentNode = currentNode.left;\n    }\n    return currentNode.value;\n  }\n}\n\nexports.BST = BST;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n\n  root.insert(12);\n  chai.expect(root.right.left.left.value).to.deep.equal(12);\n\n  root.remove(10);\n  chai.expect(root.contains(10)).to.deep.equal(false);\n  chai.expect(root.value).to.deep.equal(12);\n\n  chai.expect(root.contains(15)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n\n  root.insert(12);\n  chai.expect(root.right.left.left.value).to.deep.equal(12);\n\n  root.remove(10);\n  chai.expect(root.contains(10)).to.deep.equal(false);\n  chai.expect(root.value).to.deep.equal(12);\n\n  chai.expect(root.contains(15)).to.deep.equal(true);\n});\n",
    },
    bigO: 'Average (all 3 methods): O(log(n)) time | O(1) space - where n is the number of nodes in the BST\nWorst (all 3 methods): O(n) time | O(1) space - where n is the number of nodes in the BST',
    tests: [
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [15], method: 'insert' },
          { arguments: [2], method: 'insert' },
          { arguments: [5], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [22], method: 'insert' },
          { arguments: [1], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [12], method: 'insert' },
          { arguments: [10], method: 'remove' },
          { arguments: [15], method: 'contains' },
        ],
        rootValue: 10,
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [15], method: 'insert' },
        ],
        rootValue: 10,
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [15], method: 'insert' },
          { arguments: [10], method: 'contains' },
          { arguments: [5], method: 'contains' },
          { arguments: [15], method: 'contains' },
          { arguments: [1], method: 'contains' },
          { arguments: [6], method: 'contains' },
          { arguments: [11], method: 'contains' },
          { arguments: [16], method: 'contains' },
        ],
        rootValue: 10,
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [15], method: 'insert' },
          { arguments: [5], method: 'remove' },
          { arguments: [15], method: 'remove' },
          { arguments: [10], method: 'remove' },
        ],
        rootValue: 10,
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [15], method: 'insert' },
          { arguments: [10], method: 'contains' },
          { arguments: [5], method: 'contains' },
          { arguments: [15], method: 'contains' },
          { arguments: [10], method: 'remove' },
          { arguments: [5], method: 'remove' },
          { arguments: [15], method: 'remove' },
          { arguments: [10], method: 'contains' },
          { arguments: [5], method: 'contains' },
          { arguments: [15], method: 'contains' },
        ],
        rootValue: 10,
      },
      {
        classMethodsToCall: [
          { arguments: [2], method: 'insert' },
          { arguments: [3], method: 'insert' },
          { arguments: [4], method: 'insert' },
          { arguments: [5], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [7], method: 'insert' },
          { arguments: [8], method: 'insert' },
          { arguments: [9], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [11], method: 'insert' },
          { arguments: [12], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [15], method: 'insert' },
          { arguments: [16], method: 'insert' },
          { arguments: [17], method: 'insert' },
          { arguments: [18], method: 'insert' },
          { arguments: [19], method: 'insert' },
          { arguments: [20], method: 'insert' },
          { arguments: [2], method: 'remove' },
          { arguments: [4], method: 'remove' },
          { arguments: [6], method: 'remove' },
          { arguments: [8], method: 'remove' },
          { arguments: [11], method: 'remove' },
          { arguments: [13], method: 'remove' },
          { arguments: [15], method: 'remove' },
          { arguments: [17], method: 'remove' },
          { arguments: [19], method: 'remove' },
          { arguments: [1], method: 'insert' },
          { arguments: [2], method: 'insert' },
          { arguments: [3], method: 'insert' },
          { arguments: [4], method: 'insert' },
          { arguments: [5], method: 'insert' },
          { arguments: [6], method: 'insert' },
          { arguments: [7], method: 'insert' },
          { arguments: [8], method: 'insert' },
          { arguments: [9], method: 'insert' },
          { arguments: [10], method: 'insert' },
          { arguments: [9000], method: 'contains' },
        ],
        rootValue: 1,
      },
      {
        classMethodsToCall: [
          { arguments: [2], method: 'insert' },
          { arguments: [3], method: 'insert' },
          { arguments: [4], method: 'insert' },
          { arguments: [1], method: 'remove' },
        ],
        rootValue: 1,
      },
      {
        classMethodsToCall: [
          { arguments: [-2], method: 'insert' },
          { arguments: [-3], method: 'insert' },
          { arguments: [-4], method: 'insert' },
          { arguments: [1], method: 'remove' },
        ],
        rootValue: 1,
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [10], method: 'remove' },
          { arguments: [15], method: 'contains' },
        ],
        rootValue: 10,
      },
      {
        classMethodsToCall: [
          { arguments: [5], method: 'insert' },
          { arguments: [15], method: 'insert' },
          { arguments: [2], method: 'insert' },
          { arguments: [5], method: 'insert' },
          { arguments: [13], method: 'insert' },
          { arguments: [22], method: 'insert' },
          { arguments: [1], method: 'insert' },
          { arguments: [14], method: 'insert' },
          { arguments: [12], method: 'insert' },
          { arguments: [5], method: 'remove' },
          { arguments: [5], method: 'remove' },
          { arguments: [12], method: 'remove' },
          { arguments: [13], method: 'remove' },
          { arguments: [14], method: 'remove' },
          { arguments: [22], method: 'remove' },
          { arguments: [2], method: 'remove' },
          { arguments: [1], method: 'remove' },
          { arguments: [15], method: 'contains' },
        ],
        rootValue: 10,
      },
    ],
  },
  {
    id: 'validate-bst',
    name: 'Validate BST',
    category: 'Binary Search Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a potentially invalid Binary Search Tree (BST)\n  and returns a boolean representing whether the BST is valid.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<p>\n  A BST is valid if and only if all of its nodes are valid\n  <span>BST</span> nodes.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =   10\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      5      15\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   2     5 13   22\n /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n1            14\n</pre>\n<h3>Sample Output</h3>\n<pre>true</pre>\n</div>',
    hints: [
      '<p>\nEvery node in the BST has a maximum possible value and a minimum possible value. In other words, the value of any given node in the BST must be strictly smaller than some value (the value of its closest right parent) and must be greater than or equal to some other value (the value of its closest left parent).\n</p>\n',
      '\n<p>\nValidate the BST by recursively calling the validateBst function on every node, passing in the correct maximum and minimum possible values to each. Initialize those values to be -Infinity and +Infinity.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction validateBst(tree) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.BST = BST;\nexports.validateBst = validateBst;\n',
      solutions: [
        'class BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(d) space\nfunction validateBst(tree) {\n  return validateBstHelper(tree, -Infinity, Infinity);\n}\n\nfunction validateBstHelper(tree, minValue, maxValue) {\n  if (tree === null) return true;\n  if (tree.value < minValue || tree.value >= maxValue) return false;\n  const leftIsValid = validateBstHelper(tree.left, minValue, tree.value);\n  return leftIsValid && validateBstHelper(tree.right, tree.value, maxValue);\n}\n\nexports.BST = BST;\nexports.validateBst = validateBst;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n\n  chai.expect(program.validateBst(root)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.left = new BST(13);\n  root.right.left.right = new BST(14);\n  root.right.right = new BST(22);\n\n  chai.expect(program.validateBst(root)).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n) time | O(d) space - where n is the number of nodes in the BST and d is the depth (height) of the BST',
    tests: [
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: '-5', right: null, value: 1 },
            { id: '-5', left: '-15', right: '-5-2', value: -5 },
            { id: '-5-2', left: null, right: '-2', value: -5 },
            { id: '-2', left: null, right: '-1', value: -2 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '-15', left: '-22', right: null, value: -15 },
            { id: '-22', left: null, right: null, value: -22 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [{ id: '10', left: null, right: null, value: 10 }],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: '500', value: 22 },
            { id: '500', left: '50', right: '1500', value: 500 },
            { id: '1500', left: null, right: '10000', value: 1500 },
            { id: '10000', left: '2200', right: null, value: 10000 },
            { id: '2200', left: null, right: null, value: 2200 },
            { id: '50', left: null, right: '200', value: 50 },
            { id: '200', left: null, right: null, value: 200 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '5000', left: '5', right: '55000', value: 5000 },
            { id: '55000', left: null, right: null, value: 55000 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '502', value: 22 },
            { id: '502', left: '204', right: null, value: 502 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: null, right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
          ],
          root: '5000',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: '11', value: 5 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: '-5', right: null, value: 1 },
            { id: '-5', left: '-15', right: '-5-2', value: -5 },
            { id: '-5-2', left: null, right: '-2', value: -5 },
            { id: '-2', left: null, right: '-1', value: -2 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '-15', left: '-22', right: null, value: -15 },
            { id: '-22', left: '11', right: null, value: -22 },
            { id: '11', left: null, right: null, value: 11 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '11', right: '12', value: 10 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '11', left: null, right: null, value: 11 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: '500', value: 22 },
            { id: '500', left: '50', right: '1500', value: 500 },
            { id: '1500', left: null, right: '10000', value: 1500 },
            { id: '10000', left: '2200', right: '9999', value: 10000 },
            { id: '9999', left: null, right: null, value: 9999 },
            { id: '2200', left: null, right: null, value: 2200 },
            { id: '50', left: null, right: '200', value: 50 },
            { id: '200', left: null, right: null, value: 200 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: null, right: null, value: 55000 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: '300', right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '300', left: null, right: null, value: 300 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: null, right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
          ],
          root: '100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: null, value: 15 },
            { id: '5', left: null, right: '10-2', value: 5 },
            { id: '10-2', left: null, right: null, value: 10 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '16', value: 13 },
            { id: '16', left: null, right: null, value: 16 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 5 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
    ],
  },
  {
    id: 'bst-traversal',
    name: 'BST Traversal',
    category: 'Binary Search Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write three functions that take in a Binary Search Tree (BST) and an empty\n  array, traverse the BST, add its nodes\' values to the input array, and return\n  that array. The three functions should traverse the BST using the in-order,\n  pre-order, and post-order tree-traversal techniques, respectively.\n</p>\n<p>\n  If you\'re unfamiliar with tree-traversal techniques, we recommend watching the\n  Conceptual Overview section of this question\'s video explanation before\n  starting to code.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =   10\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      5      15\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\       \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   2     5       22\n /\n1\n<span class="CodeEditor-promptParameter">array</span> = []\n</pre>\n<h3>Sample Output</h3>\n<pre>\n<span class="CodeEditor-promptParameter">inOrderTraverse</span>: [1, 2, 5, 5, 10, 15, 22] <span class="CodeEditor-promptComment">// where the array is the input array</span>\n<span class="CodeEditor-promptParameter">preOrderTraverse</span>: [10, 5, 2, 1, 5, 15, 22] <span class="CodeEditor-promptComment">// where the array is the input array</span>\n<span class="CodeEditor-promptParameter">postOrderTraverse</span>: [1, 2, 5, 5, 22, 15, 10] <span class="CodeEditor-promptComment">// where the array is the input array</span>\n</pre>\n</div>',
    hints: [
      "<p>\nRealize that in-order traversal simply means traversing left nodes before traversing current nodes before traversing right nodes. Try implementing this algorithm recursively by calling the inOrderTraverse method on a left node, then appending the current node's value to the input array, and then calling the inOrderTraverse method on a right node.\n</p>\n",
      '\n<p>\nApply the same logic described in Hint #1 for the two other traversal methods, but change the order in which you do things.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function inOrderTraverse(tree, array) {\n  // Write your code here.\n}\n\nfunction preOrderTraverse(tree, array) {\n  // Write your code here.\n}\n\nfunction postOrderTraverse(tree, array) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.inOrderTraverse = inOrderTraverse;\nexports.preOrderTraverse = preOrderTraverse;\nexports.postOrderTraverse = postOrderTraverse;\n',
      solutions: [
        '// O(n) time | O(n) space\nfunction inOrderTraverse(tree, array) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n\n// O(n) time | O(n) space\nfunction preOrderTraverse(tree, array) {\n  if (tree !== null) {\n    array.push(tree.value);\n    preOrderTraverse(tree.left, array);\n    preOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n\n// O(n) time | O(n) space\nfunction postOrderTraverse(tree, array) {\n  if (tree !== null) {\n    postOrderTraverse(tree.left, array);\n    postOrderTraverse(tree.right, array);\n    array.push(tree.value);\n  }\n  return array;\n}\n\nexports.inOrderTraverse = inOrderTraverse;\nexports.preOrderTraverse = preOrderTraverse;\nexports.postOrderTraverse = postOrderTraverse;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.right = new BST(22);\n  chai.expect(program.inOrderTraverse(root, [])).to.deep.equal([1, 2, 5, 5, 10, 15, 22]);\n  chai.expect(program.preOrderTraverse(root, [])).to.deep.equal([10, 5, 2, 1, 5, 15, 22]);\n  chai.expect(program.postOrderTraverse(root, [])).to.deep.equal([1, 2, 5, 5, 22, 15, 10]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const root = new BST(10);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.right = new BST(5);\n  root.right = new BST(15);\n  root.right.right = new BST(22);\n  chai.expect(program.inOrderTraverse(root, [])).to.deep.equal([1, 2, 5, 5, 10, 15, 22]);\n  chai.expect(program.preOrderTraverse(root, [])).to.deep.equal([10, 5, 2, 1, 5, 15, 22]);\n  chai.expect(program.postOrderTraverse(root, [])).to.deep.equal([1, 2, 5, 5, 22, 15, 10]);\n});\n",
    },
    bigO: 'All three methods: O(n) time | O(n) space - where n is the number of nodes in the BST',
    tests: [
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '100', left: '5', right: '502', value: 100 },
            { id: '502', left: '204', right: '55000', value: 502 },
            { id: '55000', left: '1001', right: null, value: 55000 },
            { id: '1001', left: null, right: '4500', value: 1001 },
            { id: '4500', left: null, right: null, value: 4500 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '57', value: 22 },
            { id: '57', left: null, right: '60', value: 57 },
            { id: '60', left: null, right: null, value: 60 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: '-51', right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
            { id: '-51', left: '-403', right: null, value: -51 },
            { id: '-403', left: null, right: null, value: -403 },
          ],
          root: '100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: '-5', right: null, value: 1 },
            { id: '-5', left: '-15', right: '-5-2', value: -5 },
            { id: '-5-2', left: null, right: '-2', value: -5 },
            { id: '-2', left: null, right: '-1', value: -2 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '-15', left: '-22', right: null, value: -15 },
            { id: '-22', left: null, right: null, value: -22 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [{ id: '10', left: null, right: null, value: 10 }],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: '500', value: 22 },
            { id: '500', left: '50', right: '1500', value: 500 },
            { id: '1500', left: null, right: '10000', value: 1500 },
            { id: '10000', left: '2200', right: null, value: 10000 },
            { id: '2200', left: null, right: null, value: 2200 },
            { id: '50', left: null, right: '200', value: 50 },
            { id: '200', left: null, right: null, value: 200 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '5000', left: '5', right: '55000', value: 5000 },
            { id: '55000', left: null, right: null, value: 55000 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '5-2', right: '22', value: 15 },
            { id: '22', left: null, right: '502', value: 22 },
            { id: '502', left: '204', right: null, value: 502 },
            { id: '204', left: '203', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: null, right: '1-2', value: 1 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
          ],
          root: '5000',
        },
      },
    ],
  },
  {
    id: 'same-bsts',
    name: 'Same BSTs',
    category: 'Binary Search Trees',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  An array of integers is said to represent the Binary Search Tree (BST)\n  obtained by inserting each integer in the array, from left to right, into the\n  BST.\n</p>\n<p>\n  Write a function that takes in two arrays of integers and determines whether\n  these arrays represent the same BST. Note that you\'re <i>not</i> allowed to\n  construct any BSTs in your code.\n</p>\n<p>\n  A BST is a Binary Tree that consists only of <span>BST</span> nodes. A node is said to be a\n  valid <span>BST</span> node if and only if it satisfies the BST property: its value is\n  strictly greater than the values of every node to its left; its value is less\n  than or equal to the values of every node to its right; and its children nodes\n  are either valid <span>BST</span> nodes themselves or <span>None</span> /\n  <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">arrayOne</span> = [10, 15, 8, 12, 94, 81, 5, 2, 11]\n<span class="CodeEditor-promptParameter">arrayTwo</span> = [10, 8, 5, 15, 2, 12, 11, 94, 81]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue <span class="CodeEditor-promptComment">// both arrays represent the BST below</span>\n<span class="CodeEditor-promptComment">         10\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      8      15\n    /       /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   5      12    94\n /       /     /\n2       11    81\n</span>\n</pre>\n</div>',
    hints: [
      "<p>\nYou can immediately conclude that the input arrays don't represent the same BST if their first values aren't equal to each other, since their first values represent the root of the BST. Similarly, you can conclude this if their lengths are different. If their first values are equal to each other and their lengths are the same, what should your next step be?\n</p>\n",
      '\n<p>\nGiven an array of integers, all of the values in the array that are smaller than the first value in the array are located in the left subtree of the BST that the array represents, and all of the values in the array that are greater than or equal to the first value in the array are located in the right subtree of the BST that the array represents. Use this fact and Hint #1 to recursively determine whether all subtrees in the BSTs represented by the arrays are equal to each other.\n</p>\n',
      "\n<p>\nWrite a recursive function that takes in two arrays of integers. If the first values of the arrays aren't equal to each other or if the arrays don't have the same length, the arrays don't represent the same BST. If the first values and lengths are equal to each other, respectively, perform the following actions on both arrays: gather all integers that are smaller than the first integer; these form a new array that represents the left subtree of the relevant BST; gather all integers that are greater than or equal to the first integer; these form a new array that represents the right subtree of the relevant BST. Call the recursive function twice: once with the two left-subtree arrays and once with the two right-subtree arrays.\n</p>\n",
      '\n<p>\nDo you actually need to create all of the auxiliary arrays mentioned in Hint #3?\n</p>',
    ],
    customInputVars: [
      {
        name: 'arrayOne',
        example: [10, 15, 8, 12, 94, 81, 5, 2, 11],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      {
        name: 'arrayTwo',
        example: [10, 8, 5, 15, 2, 12, 11, 94, 81],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function sameBsts(arrayOne, arrayTwo) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.sameBsts = sameBsts;\n',
      solutions: [
        '// O(n^2) time | O(n^2) space - where n is the number of\n// nodes in each array, respectively\nfunction sameBsts(arrayOne, arrayTwo) {\n  if (arrayOne.length !== arrayTwo.length) return false;\n\n  if (arrayOne.length === 0 && arrayTwo.length === 0) return true;\n\n  if (arrayOne[0] !== arrayTwo[0]) return false;\n\n  const leftOne = getSmaller(arrayOne);\n  const leftTwo = getSmaller(arrayTwo);\n  const rightOne = getBiggerOrEqual(arrayOne);\n  const rightTwo = getBiggerOrEqual(arrayTwo);\n\n  return sameBsts(leftOne, leftTwo) && sameBsts(rightOne, rightTwo);\n}\n\nfunction getSmaller(array) {\n  const smaller = [];\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] < array[0]) smaller.push(array[i]);\n  }\n  return smaller;\n}\n\nfunction getBiggerOrEqual(array) {\n  const biggerOrEqual = [];\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] >= array[0]) biggerOrEqual.push(array[i]);\n  }\n  return biggerOrEqual;\n}\n\nexports.sameBsts = sameBsts;\n',
        "// O(n^2) time | O(d) space - where n is the number of\n// nodes in each array, respectively, and d is the depth\n// of the BST that they represent\nfunction sameBsts(arrayOne, arrayTwo) {\n  return areSameBsts(arrayOne, arrayTwo, 0, 0, -Infinity, Infinity);\n}\n\nfunction areSameBsts(arrayOne, arrayTwo, rootIdxOne, rootIdxTwo, minVal, maxVal) {\n  if (rootIdxOne === -1 || rootIdxTwo === -1) return rootIdxOne === rootIdxTwo;\n\n  if (arrayOne[rootIdxOne] !== arrayTwo[rootIdxTwo]) return false;\n\n  const leftRootIdxOne = getIdxOfFirstSmaller(arrayOne, rootIdxOne, minVal);\n  const leftRootIdxTwo = getIdxOfFirstSmaller(arrayTwo, rootIdxTwo, minVal);\n  const rightRootIdxOne = getIdxOfFirstBiggerOrEqual(arrayOne, rootIdxOne, maxVal);\n  const rightRootIdxTwo = getIdxOfFirstBiggerOrEqual(arrayTwo, rootIdxTwo, maxVal);\n\n  const currentValue = arrayOne[rootIdxOne];\n  const leftAreSame = areSameBsts(\n    arrayOne,\n    arrayTwo,\n    leftRootIdxOne,\n    leftRootIdxTwo,\n    minVal,\n    currentValue,\n  );\n  const rightAreSame = areSameBsts(\n    arrayOne,\n    arrayTwo,\n    rightRootIdxOne,\n    rightRootIdxTwo,\n    currentValue,\n    maxVal,\n  );\n\n  return leftAreSame && rightAreSame;\n}\n\nfunction getIdxOfFirstSmaller(array, startingIdx, minVal) {\n  // Find the index of the first smaller value after the startingIdx.\n  // Make sure that this value is greater than or equal to the minVal,\n  // which is the value of the previous parent node in the BST. If it\n  // isn't, then that value is located in the left subtree of the\n  // previous parent node.\n  for (let i = startingIdx + 1; i < array.length; i++) {\n    if (array[i] < array[startingIdx] && array[i] >= minVal) return i;\n  }\n  return -1;\n}\n\nfunction getIdxOfFirstBiggerOrEqual(array, startingIdx, maxVal) {\n  // Find the index of the first bigger/equal value after the startingIdx.\n  // Make sure that this value is smaller than maxVal, which is the value\n  // of the previous parent node in the BST. If it isn't, then that value\n  // is located in the right subtree of the previous parent node.\n  for (let i = startingIdx + 1; i < array.length; i++) {\n    if (array[i] >= array[startingIdx] && array[i] < maxVal) return i;\n  }\n  return -1;\n}\n\nexports.sameBsts = sameBsts;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const arrayOne = [10, 15, 8, 12, 94, 81, 5, 2, 11];\n  const arrayTwo = [10, 8, 5, 15, 2, 12, 11, 94, 81];\n  chai.expect(program.sameBsts(arrayOne, arrayTwo)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const arrayOne = [10, 15, 8, 12, 94, 81, 5, 2, 11];\n  const arrayTwo = [10, 8, 5, 15, 2, 12, 11, 94, 81];\n  chai.expect(program.sameBsts(arrayOne, arrayTwo)).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n^2) time | O(d) space - where n is the number of nodes in each array, respectively, and d is the depth of the BST that they represent',
    tests: [
      {
        arrayOne: [10, 15, 8, 12, 94, 81, 5, 2, 11],
        arrayTwo: [10, 8, 5, 15, 2, 12, 11, 94, 81],
      },
      { arrayOne: [1, 2, 3, 4, 5, 6, 7], arrayTwo: [1, 2, 3, 4, 5, 6, 7] },
      { arrayOne: [7, 6, 5, 4, 3, 2, 1], arrayTwo: [7, 6, 5, 4, 3, 2, 1] },
      {
        arrayOne: [10, 15, 8, 12, 94, 81, 5, 2],
        arrayTwo: [10, 8, 5, 15, 2, 12, 94, 81],
      },
      {
        arrayOne: [10, 15, 8, 12, 94, 81, 5, 2],
        arrayTwo: [11, 8, 5, 15, 2, 12, 94, 81],
      },
      {
        arrayOne: [
          10, 15, 8, 12, 94, 81, 5, 2, -1, 100, 45, 12, 8, -1, 8, 2, -34,
        ],
        arrayTwo: [
          10, 8, 5, 15, 2, 12, 94, 81, -1, -1, -34, 8, 2, 8, 12, 45, 100,
        ],
      },
      {
        arrayOne: [
          10, 15, 8, 12, 94, 81, 5, 2, -1, 101, 45, 12, 8, -1, 8, 2, -34,
        ],
        arrayTwo: [
          10, 8, 5, 15, 2, 12, 94, 81, -1, -1, -34, 8, 2, 8, 12, 45, 100,
        ],
      },
      {
        arrayOne: [
          5, 2, -1, 100, 45, 12, 8, -1, 8, 10, 15, 8, 12, 94, 81, 2, -34,
        ],
        arrayTwo: [
          5, 8, 10, 15, 2, 8, 12, 45, 100, 2, 12, 94, 81, -1, -1, -34, 8,
        ],
      },
      {
        arrayOne: [
          10, 15, 8, 12, 94, 81, 5, 2, -1, 100, 45, 12, 9, -1, 8, 2, -34,
        ],
        arrayTwo: [
          10, 8, 5, 15, 2, 12, 94, 81, -1, -1, -34, 8, 2, 9, 12, 45, 100,
        ],
      },
      { arrayOne: [1, 2, 3, 4, 5, 6, 7, 8], arrayTwo: [1, 2, 3, 4, 5, 6, 7] },
      { arrayOne: [7, 6, 5, 4, 3, 2, 1], arrayTwo: [7, 6, 5, 4, 3, 2, 1, 0] },
      {
        arrayOne: [10, 15, 8, 12, 94, 81, 5, 2, 10],
        arrayTwo: [10, 8, 5, 15, 2, 10, 12, 94, 81],
      },
      {
        arrayOne: [50, 76, 81, 23, 23, 23, 100, 56, 12, -1, 3],
        arrayTwo: [50, 23, 76, 23, 23, 12, 56, 81, -1, 3, 100],
      },
    ],
  },
  {
    id: 'min-height-bst',
    name: 'Min Height BST',
    category: 'Binary Search Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty sorted array of distinct integers,\n  constructs a BST from the integers, and returns the root of the BST.\n</p>\n<p>\n  The function should minimize the height of the BST.\n</p>\n<p>\n  You\'ve been provided with a <span>BST</span> class that you\'ll have to use to\n  construct the BST.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<p>\n  A BST is valid if and only if all of its nodes are valid\n  <span>BST</span> nodes.\n</p>\n<p>\n  Note that the <span>BST</span> class already has an <span>insert</span> method\n  which you can use if you want.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 2, 5, 7, 10, 13, 14, 15, 22]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n         10\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      2      14\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   1     5 13   15\n          \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\       \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n           7      22\n<span class="CodeEditor-promptComment">// This is one example of a BST with min height</span>\n<span class="CodeEditor-promptComment">// that you could create from the input array.</span>\n<span class="CodeEditor-promptComment">// You could create other BSTs with min height</span>\n<span class="CodeEditor-promptComment">// from the same array; for example:</span>\n         10\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      5      15\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   2     7 13   22\n /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n1            14\n</pre>\n</div>',
    hints: [
      '<p>\nIn order for the BST to have the smallest height possible, it needs to be balanced; in other words, it needs to have roughly the same number of nodes in its left subtree as in its right subtree.\n</p>\n',
      '\n<p>\nHow can you use the sorted nature of the input array to construct a balanced BST?\n</p>\n',
      "\n<p>\nGrab the middle element of the array, and make that element be the root node of the BST. Then, grab the middle element between the beginning of the array and the first middle element, and make that element be the root of the BST's left subtree; similarly, make the middle element between the end of the array and the first middle element be the root of the BST's right subtree. Continue this approach until you run out of elements in the array.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 2, 5, 7, 10, 13, 14, 15, 22],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function minHeightBst(array) {\n  // Write your code here.\n}\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value) {\n    if (value < this.value) {\n      if (this.left === null) {\n        this.left = new BST(value);\n      } else {\n        this.left.insert(value);\n      }\n    } else {\n      if (this.right === null) {\n        this.right = new BST(value);\n      } else {\n        this.right.insert(value);\n      }\n    }\n  }\n}\n\n// Do not edit the line below.\nexports.minHeightBst = minHeightBst;\n',
      solutions: [
        '// O(nlog(n)) time | O(n) space - where n is the length of the array\nfunction minHeightBst(array) {\n  return constructMinHeightBst(array, null, 0, array.length - 1);\n}\n\nfunction constructMinHeightBst(array, bst, startIdx, endIdx) {\n  if (endIdx < startIdx) return;\n  const midIdx = Math.floor((startIdx + endIdx) / 2);\n  const valueToAdd = array[midIdx];\n  if (bst === null) {\n    bst = new BST(valueToAdd);\n  } else {\n    bst.insert(valueToAdd);\n  }\n  constructMinHeightBst(array, bst, startIdx, midIdx - 1);\n  constructMinHeightBst(array, bst, midIdx + 1, endIdx);\n  return bst;\n}\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value) {\n    if (value < this.value) {\n      if (this.left === null) {\n        this.left = new BST(value);\n      } else {\n        this.left.insert(value);\n      }\n    } else {\n      if (this.right === null) {\n        this.right = new BST(value);\n      } else {\n        this.right.insert(value);\n      }\n    }\n  }\n}\n\nexports.minHeightBst = minHeightBst;\n',
        "// O(n) time | O(n) space - where n is the length of the array\nfunction minHeightBst(array) {\n  return constructMinHeightBst(array, null, 0, array.length - 1);\n}\n\nfunction constructMinHeightBst(array, bst, startIdx, endIdx) {\n  if (endIdx < startIdx) return;\n  const midIdx = Math.floor((startIdx + endIdx) / 2);\n  const newBstNode = new BST(array[midIdx]);\n  if (bst === null) {\n    bst = newBstNode;\n  } else {\n    if (array[midIdx] < bst.value) {\n      bst.left = newBstNode;\n      bst = bst.left;\n    } else {\n      bst.right = newBstNode;\n      bst = bst.right;\n    }\n  }\n  constructMinHeightBst(array, bst, startIdx, midIdx - 1);\n  constructMinHeightBst(array, bst, midIdx + 1, endIdx);\n  return bst;\n}\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  // We don't use this method for this solution.\n  insert(value) {\n    if (value < this.value) {\n      if (this.left === null) {\n        this.left = new BST(value);\n      } else {\n        this.left.insert(value);\n      }\n    } else {\n      if (this.right === null) {\n        this.right = new BST(value);\n      } else {\n        this.right.insert(value);\n      }\n    }\n  }\n}\n\nexports.minHeightBst = minHeightBst;\n",
        "// O(n) time | O(n) space - where n is the length of the array\nfunction minHeightBst(array) {\n  return constructMinHeightBst(array, 0, array.length - 1);\n}\n\nfunction constructMinHeightBst(array, startIdx, endIdx) {\n  if (endIdx < startIdx) return null;\n  const midIdx = Math.floor((startIdx + endIdx) / 2);\n  const bst = new BST(array[midIdx]);\n  bst.left = constructMinHeightBst(array, startIdx, midIdx - 1);\n  bst.right = constructMinHeightBst(array, midIdx + 1, endIdx);\n  return bst;\n}\n\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n\n  // We don't use this method for this solution.\n  insert(value) {\n    if (value < this.value) {\n      if (this.left === null) {\n        this.left = new BST(value);\n      } else {\n        this.left.insert(value);\n      }\n    } else {\n      if (this.right === null) {\n        this.right = new BST(value);\n      } else {\n        this.right.insert(value);\n      }\n    }\n  }\n}\n\nexports.minHeightBst = minHeightBst;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [1, 2, 5, 7, 10, 13, 14, 15, 22];\n  const tree = program.minHeightBst(array);\n\n  chai.expect(validateBst(tree)).to.deep.equal(true);\n  chai.expect(getTreeHeight(tree)).to.deep.equal(4);\n\n  const inOrder = inOrderTraverse(tree, []);\n  const expected = [1, 2, 5, 7, 10, 13, 14, 15, 22];\n\n  chai.expect(inOrder).to.deep.equal(expected);\n});\n\nfunction validateBst(tree) {\n  return validateBstHelper(tree, -Infinity, Infinity);\n}\n\nfunction validateBstHelper(tree, minValue, maxValue) {\n  if (tree === null) return true;\n  if (tree.value < minValue || tree.value >= maxValue) return false;\n  const leftIsValid = validateBstHelper(tree.left, minValue, tree.value);\n  return leftIsValid && validateBstHelper(tree.right, tree.value, maxValue);\n}\n\nfunction inOrderTraverse(tree, array) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n\nfunction getTreeHeight(tree, height = 0) {\n  if (tree === null) return height;\n  const leftTreeHeight = getTreeHeight(tree.left, height + 1);\n  const rightTreeHeight = getTreeHeight(tree.right, height + 1);\n  return Math.max(leftTreeHeight, rightTreeHeight);\n}\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [1, 2, 5, 7, 10, 13, 14, 15, 22];\n  const tree = program.minHeightBst(array);\n\n  chai.expect(validateBst(tree)).to.deep.equal(true);\n  chai.expect(getTreeHeight(tree)).to.deep.equal(4);\n\n  const inOrder = inOrderTraverse(tree, []);\n  const expected = [1, 2, 5, 7, 10, 13, 14, 15, 22];\n\n  chai.expect(inOrder).to.deep.equal(expected);\n});\n\nfunction validateBst(tree) {\n  return validateBstHelper(tree, -Infinity, Infinity);\n}\n\nfunction validateBstHelper(tree, minValue, maxValue) {\n  if (tree === null) return true;\n  if (tree.value < minValue || tree.value >= maxValue) return false;\n  const leftIsValid = validateBstHelper(tree.left, minValue, tree.value);\n  return leftIsValid && validateBstHelper(tree.right, tree.value, maxValue);\n}\n\nfunction inOrderTraverse(tree, array) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n\nfunction getTreeHeight(tree, height = 0) {\n  if (tree === null) return height;\n  const leftTreeHeight = getTreeHeight(tree.left, height + 1);\n  const rightTreeHeight = getTreeHeight(tree.right, height + 1);\n  return Math.max(leftTreeHeight, rightTreeHeight);\n}\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the array',
    tests: [
      { array: [1, 2, 5, 7, 10, 13, 14, 15, 22] },
      { array: [1] },
      { array: [1, 2] },
      { array: [1, 2, 5] },
      { array: [1, 2, 5, 7] },
      { array: [1, 2, 5, 7, 10] },
      { array: [1, 2, 5, 7, 10, 13] },
      { array: [1, 2, 5, 7, 10, 13, 14] },
      { array: [1, 2, 5, 7, 10, 13, 14, 15] },
      { array: [1, 2, 5, 7, 10, 13, 14, 15, 22] },
      { array: [1, 2, 5, 7, 10, 13, 14, 15, 22, 28] },
      { array: [1, 2, 5, 7, 10, 13, 14, 15, 22, 28, 32] },
      { array: [1, 2, 5, 7, 10, 13, 14, 15, 22, 28, 32, 36] },
      { array: [1, 2, 5, 7, 10, 13, 14, 15, 22, 28, 32, 36, 89] },
      { array: [1, 2, 5, 7, 10, 13, 14, 15, 22, 28, 32, 36, 89, 92] },
      { array: [1, 2, 5, 7, 10, 13, 14, 15, 22, 28, 32, 36, 89, 92, 9000] },
      {
        array: [1, 2, 5, 7, 10, 13, 14, 15, 22, 28, 32, 36, 89, 92, 9000, 9001],
      },
    ],
  },
  {
    id: 'right-smaller-than',
    name: 'Right Smaller Than',
    category: 'Binary Search Trees',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns an array of\n  the same length, where each element in the output array corresponds to the\n  number of integers in the input array that are to the right of the relevant\n  index and that are strictly smaller than the integer at that index.\n</p>\n<p>\n  In other words, the value at <span>output[i]</span> represents the number of\n  integers that are to the right of <span>i</span> and that are strictly smaller\n  than <span>input[i]</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 11, -1, 3, 4, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[5, 4, 4, 0, 1, 1, 0]\n<span class="CodeEditor-promptComment">// There are 5 integers smaller than 8 to the right of it.</span>\n<span class="CodeEditor-promptComment">// There are 4 integers smaller than 5 to the right of it.</span>\n<span class="CodeEditor-promptComment">// There are 4 integers smaller than 11 to the right of it.</span>\n<span class="CodeEditor-promptComment">// Etc..</span>\n</pre>\n</div>',
    hints: [
      "<p>\nThe naive solution to this problem involves a simple pair of nested for loops and runs in O(n^2) time, where n is the length of the input array. This problem doesn't seem like it can be solved in linear time, so what time complexity could we realistically achieve if we somehow optimized our algorithm?\n</p>\n",
      '\n<p>\nThe only better time complexity than the O(n^2) one of our naive solution that we could realistically achieve would be an O(nlog(n)) complexity. What data structure has log(n) operations, and how could it help for this problem?\n</p>\n',
      "\n<p>\nA Binary Search Tree supports log(n) insertions and has the relevant property of every left-subtree-node having a smaller value than a given node's value; can we construct a BST from the input array in such a way that it leads us to the result array that we're looking for?\n</p>\n",
      "\n<p>\nConstruct a BST by inserting the input array's integers one by one, in reverse order (from right to left). At each insertion, once a new BST node is positioned in the BST, the number of nodes in its parent node's left subtree (plus the parent node itself, if its value is smaller than the inserted node's value) is the number of \"right-smaller-than\" elements for the element being inserted.\n</p>\n",
      "\n<p>\nGoing off of Hint #4, you can construct a special type of BST that stores the size of every node's left subtree. This value can then be used to obtain the right-smaller-than numbers for every element in the array.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8, 5, 11, -1, 3, 4, 2],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function rightSmallerThan(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.rightSmallerThan = rightSmallerThan;\n',
      solutions: [
        '// O(n^2) time | O(n) space - where n is the length of the array\nfunction rightSmallerThan(array) {\n  const rightSmallerCounts = [];\n  for (let i = 0; i < array.length; i++) {\n    let rightSmallerCount = 0;\n    for (let j = i + 1; j < array.length; j++) {\n      if (array[j] < array[i]) rightSmallerCount++;\n    }\n    rightSmallerCounts.push(rightSmallerCount);\n  }\n  return rightSmallerCounts;\n}\n\nexports.rightSmallerThan = rightSmallerThan;\n',
        '// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nfunction rightSmallerThan(array) {\n  if (array.length === 0) return [];\n\n  const lastIdx = array.length - 1;\n  const bst = new SpecialBST(array[lastIdx], lastIdx, 0);\n  for (let i = array.length - 2; i >= 0; i--) {\n    bst.insert(array[i], i);\n  }\n\n  const rightSmallerCounts = array.slice();\n  getRightSmallerCounts(bst, rightSmallerCounts);\n  return rightSmallerCounts;\n}\n\nfunction getRightSmallerCounts(bst, rightSmallerCounts) {\n  if (bst === null) return;\n  rightSmallerCounts[bst.idx] = bst.numSmallerAtInsertTime;\n  getRightSmallerCounts(bst.left, rightSmallerCounts);\n  getRightSmallerCounts(bst.right, rightSmallerCounts);\n}\n\nclass SpecialBST {\n  constructor(value, idx, numSmallerAtInsertTime) {\n    this.value = value;\n    this.idx = idx;\n    this.numSmallerAtInsertTime = numSmallerAtInsertTime;\n    this.leftSubtreeSize = 0;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value, idx, numSmallerAtInsertTime = 0) {\n    if (value < this.value) {\n      this.leftSubtreeSize++;\n      if (this.left === null) {\n        this.left = new SpecialBST(value, idx, numSmallerAtInsertTime);\n      } else {\n        this.left.insert(value, idx, numSmallerAtInsertTime);\n      }\n    } else {\n      numSmallerAtInsertTime += this.leftSubtreeSize;\n      if (value > this.value) numSmallerAtInsertTime++;\n      if (this.right === null) {\n        this.right = new SpecialBST(value, idx, numSmallerAtInsertTime);\n      } else {\n        this.right.insert(value, idx, numSmallerAtInsertTime);\n      }\n    }\n  }\n}\n\nexports.rightSmallerThan = rightSmallerThan;\n',
        '// Average case: when the created BST is balanced\n// O(nlog(n)) time | O(n) space - where n is the length of the array\n// ---\n// Worst case: when the created BST is like a linked list\n// O(n^2) time | O(n) space\nfunction rightSmallerThan(array) {\n  if (array.length === 0) return [];\n\n  const rightSmallerCounts = array.slice();\n  const lastIdx = array.length - 1;\n  const bst = new SpecialBST(array[lastIdx]);\n  rightSmallerCounts[lastIdx] = 0;\n  for (let i = array.length - 2; i >= 0; i--) {\n    bst.insert(array[i], i, rightSmallerCounts);\n  }\n\n  return rightSmallerCounts;\n}\n\nclass SpecialBST {\n  constructor(value) {\n    this.value = value;\n    this.leftSubTreeSize = 0;\n    this.left = null;\n    this.right = null;\n  }\n\n  insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime = 0) {\n    if (value < this.value) {\n      this.leftSubTreeSize++;\n      if (this.left === null) {\n        this.left = new SpecialBST(value);\n        rightSmallerCounts[idx] = numSmallerAtInsertTime;\n      } else {\n        this.left.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime);\n      }\n    } else {\n      numSmallerAtInsertTime += this.leftSubTreeSize;\n      if (value > this.value) numSmallerAtInsertTime++;\n      if (this.right === null) {\n        this.right = new SpecialBST(value);\n        rightSmallerCounts[idx] = numSmallerAtInsertTime;\n      } else {\n        this.right.insert(value, idx, rightSmallerCounts, numSmallerAtInsertTime);\n      }\n    }\n  }\n}\n\nexports.rightSmallerThan = rightSmallerThan;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [8, 5, 11, -1, 3, 4, 2];\n  const expected = [5, 4, 4, 0, 1, 1, 0];\n  const actual = program.rightSmallerThan(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [8, 5, 11, -1, 3, 4, 2];\n  const expected = [5, 4, 4, 0, 1, 1, 0];\n  const actual = program.rightSmallerThan(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'Average case: when the created BST is balanced\nO(nlog(n)) time | O(n) space - where n is the length of the array\n---\nWorst case: when the created BST is like a linked list\nO(n^2) time | O(n) space',
    tests: [
      { array: [8, 5, 11, -1, 3, 4, 2] },
      { array: [] },
      { array: [1] },
      { array: [0, 1, 1, 2, 3, 5, 8, 13] },
      { array: [13, 8, 5, 3, 2, 1, 1, 0] },
      { array: [8, 5, 2, 9, 5, 6, 3] },
      {
        array: [
          991, -731, -882, 100, 280, -43, 432, 771, -581, 180, -382, -998, 847,
          80, -220, 680, 769, -75, -817, 366, 956, 749, 471, 228, -435, -269,
          652, -331, -387, -657, -255, 382, -216, -6, -163, -681, 980, 913,
          -169, 972, -523, 354, 747, 805, 382, -827, -796, 372, 753, 519, 906,
        ],
      },
      {
        array: [
          384, -67, 120, 759, 697, 232, -7, -557, -772, -987, 687, 397, -763,
          -86, -491, 947, 921, 421, 825, -679, 946, -562, -626, -898, 204, 776,
          -343, 393, 51, -796, -425, 31, 165, 975, -720, 878, -785, -367, -609,
          662, -79, -112, -313, -94, 187, 260, 43, 85, -746, 612, 67, -389, 508,
          777, 624, 993, -581, 34, 444, -544, 243, -995, 432, -755, -978, 515,
          -68, -559, 489, 732, -19, -489, 737, 924,
        ],
      },
      {
        array: [
          -823, 164, 48, -987, 323, 399, -293, 183, -908, -376, 14, 980, 965,
          842, 422, 829, 59, 724, -415, -733, 356, -855, -155, 52, 328, -544,
          -371, -160, -942, -51, 700, -363, -353, -359, 238, 892, -730, -575,
          892, 490, 490, 995, 572, 888, -935, 919, -191, 646, -120, 125, -817,
          341, -575, 372, -874, 243, 610, -36, -685, -337, -13, 295, 800, -950,
          -949, -257, 631, -542, 201, -796, 157, 950, 540, -846, -265, 746, 355,
          -578, -441, -254, -941, -738, -469, -167, -420, -126, -410, 59,
        ],
      },
    ],
  },
  {
    id: 'find-kth-largest-value-in-bst',
    name: 'Find Kth Largest Value In BST',
    category: 'Binary Search Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Search Tree (BST) and a positive\n  integer <span>k</span> and returns the kth largest integer contained in the\n  BST.\n</p>\n<p>\n  You can assume that there will only be integer values in the BST and that\n  <span>k</span> is less than or equal to the number of nodes in the tree.\n</p>\n<p>\n  Also, for the purpose of this question, duplicate integers will be treated as\n  distinct values. In other words, the second largest value in a BST containing\n  values <span>{5, 7, 7}</span> will be <span>7</span>not <span>5</span>.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =   15\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      5      20\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   2     5 17   22\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\         \n1     3       \n<span class="CodeEditor-promptParameter">k</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>17</pre>\n</div>',
    hints: [
      '<p>\n  Make sure to consider the fact that the given tree is a Binary Search Treenot\n  just a regular Binary Tree. How does this fact help you solve the problem in a\n  more optimal time complexity?\n</p>\n',
      "\n<p>\n  The brute-force approach to this problem is to simply perform an in-order\n  traversal of this BST and to store all of its node' values in the order in\n  which they're visited. Since an in-order traversal of a BST visits the nodes\n  in ascending order, the <span>k</span>th value from the end of the traversal\n  order will be the <span>k</span>th largest value.\n</p>\n",
      '\n<p>\n  You can actually solve this problem in <span>O(h + k)</span> time, where\n  <span>h</span> is the height of the tree. Rather than looking at the nodes in\n  ascending order, you should look at them in descending order.\n</p>\n',
      "\n<p>\n  To solve this problem in <span>O(h + k)</span> time as mentioned in Hint #3,\n  you need to perform a <b>reverse</b> in-order traversal. Since you'll be\n  looking at nodes in descending order, you can simply return the\n  <span>k</span>th visited node in the reverse in-order traversal.\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '15', left: '5', right: '20', value: 15 },
            { id: '20', left: '17', right: '22', value: 20 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '17', left: null, right: null, value: 17 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '15',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
      { name: 'k', example: 3, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction findKthLargestValueInBst(tree, k) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.findKthLargestValueInBst = findKthLargestValueInBst;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(n) space - where n is the number of nodes in the tree\nfunction findKthLargestValueInBst(tree, k) {\n  const sortedNodeValues = [];\n  inOrderTraverse(tree, sortedNodeValues);\n  return sortedNodeValues[sortedNodeValues.length - k];\n}\n\nfunction inOrderTraverse(node, sortedNodeValues) {\n  if (node === null) return;\n\n  inOrderTraverse(node.left, sortedNodeValues);\n  sortedNodeValues.push(node.value);\n  inOrderTraverse(node.right, sortedNodeValues);\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.findKthLargestValueInBst = findKthLargestValueInBst;\n',
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass TreeInfo {\n  constructor(numberOfNodesVisited, latestVisitedNodeValue) {\n    this.numberOfNodesVisited = numberOfNodesVisited;\n    this.latestVisitedNodeValue = latestVisitedNodeValue;\n  }\n}\n\n// O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter\nfunction findKthLargestValueInBst(tree, k) {\n  const treeInfo = new TreeInfo(0, -1);\n  reverseInOrderTraverse(tree, k, treeInfo);\n  return treeInfo.latestVisitedNodeValue;\n}\n\nfunction reverseInOrderTraverse(node, k, treeInfo) {\n  if (node === null || treeInfo.numberOfNodesVisited >= k) return;\n\n  reverseInOrderTraverse(node.right, k, treeInfo);\n  if (treeInfo.numberOfNodesVisited < k) {\n    treeInfo.numberOfNodesVisited++;\n    treeInfo.latestVisitedNodeValue = node.value;\n    reverseInOrderTraverse(node.left, k, treeInfo);\n  }\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.findKthLargestValueInBst = findKthLargestValueInBst;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(15);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.left.right = new BST(3);\n  root.left.right = new BST(5);\n  root.right = new BST(20);\n  root.right.left = new BST(17);\n  root.right.right = new BST(22);\n  const k = 3;\n  const expected = 17;\n  const actual = program.findKthLargestValueInBst(root, k);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nit('Test Case #1', function () {\n  const root = new BST(15);\n  root.left = new BST(5);\n  root.left.left = new BST(2);\n  root.left.left.left = new BST(1);\n  root.left.left.right = new BST(3);\n  root.left.right = new BST(5);\n  root.right = new BST(20);\n  root.right.left = new BST(17);\n  root.right.right = new BST(22);\n  const k = 3;\n  const expected = 17;\n  const actual = program.findKthLargestValueInBst(root, k);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(h + k) time | O(h) space - where h is the height of the tree and k is the input parameter',
    tests: [
      {
        k: 3,
        tree: {
          nodes: [
            { id: '15', left: '5', right: '20', value: 15 },
            { id: '20', left: '17', right: '22', value: 20 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '17', left: null, right: null, value: 17 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '15',
        },
      },
      {
        k: 1,
        tree: {
          nodes: [
            { id: '5', left: '4', right: '6', value: 5 },
            { id: '4', left: '3', right: null, value: 4 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '5',
        },
      },
      {
        k: 1,
        tree: {
          nodes: [{ id: '5', left: null, right: null, value: 5 }],
          root: '5',
        },
      },
      {
        k: 3,
        tree: {
          nodes: [
            { id: '20', left: '15', right: '25', value: 20 },
            { id: '15', left: '10', right: '19', value: 15 },
            { id: '25', left: '21', right: '30', value: 25 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '19', left: null, right: null, value: 19 },
            { id: '21', left: null, right: '22', value: 21 },
            { id: '30', left: null, right: null, value: 30 },
            { id: '22', left: null, right: null, value: 22 },
          ],
          root: '20',
        },
      },
      {
        k: 5,
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '4', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        k: 2,
        tree: {
          nodes: [
            { id: '10', left: '8', right: null, value: 10 },
            { id: '8', left: '6', right: null, value: 8 },
            { id: '6', left: '4', right: null, value: 6 },
            { id: '4', left: '2', right: null, value: 4 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '10',
        },
      },
      {
        k: 5,
        tree: {
          nodes: [
            { id: '10', left: '8', right: null, value: 10 },
            { id: '8', left: '6', right: '9', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '6', left: '4', right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '4', left: '2', right: '5', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '10',
        },
      },
      {
        k: 1,
        tree: {
          nodes: [
            { id: '99727', left: '99', right: null, value: 99727 },
            { id: '99', left: null, right: '727', value: 99 },
            { id: '727', left: null, right: null, value: 727 },
          ],
          root: '99727',
        },
      },
      {
        k: 7,
        tree: {
          nodes: [
            { id: '15', left: '5', right: '20', value: 15 },
            { id: '20', left: '17', right: '22', value: 20 },
            { id: '22', left: null, right: '24', value: 22 },
            { id: '24', left: '23', right: '25', value: 24 },
            { id: '23', left: null, right: null, value: 23 },
            { id: '25', left: null, right: null, value: 25 },
            { id: '17', left: null, right: null, value: 17 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '15',
        },
      },
      {
        k: 5,
        tree: {
          nodes: [
            { id: '15', left: '5', right: '20', value: 15 },
            { id: '20', left: '17', right: '22', value: 20 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '17', left: null, right: null, value: 17 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '15',
        },
      },
      {
        k: 6,
        tree: {
          nodes: [
            { id: '15', left: '5', right: '20', value: 15 },
            { id: '20', left: '17', right: '22', value: 20 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '17', left: null, right: null, value: 17 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '15',
        },
      },
    ],
  },
  {
    id: 'reconstruct-bst',
    name: 'Reconstruct BST',
    category: 'Binary Search Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  The pre-order traversal of a Binary Tree is a traversal technique that starts\n  at the tree\'s root node and visits nodes in the following order:\n</p>\n<ol>\n  <li>Current node</li>\n  <li>Left subtree</li>\n  <li>Right subtree</li>\n</ol>\n<p>\n  Given a non-empty array of integers representing the pre-order traversal of a\n  Binary Search Tree (BST), write a function that creates the relevant BST and\n  returns its root node.\n</p>\n<p>\n  The input array will contain the values of BST nodes in the order in which\n  these nodes would be visited with a pre-order traversal.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">preOrderTraversalValues</span> = [10, 4, 2, 1, 5, 17, 19, 18]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n        10 \n      /    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n     4      17\n   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\      \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  2     5     19\n /           /\n1           18 \n</pre>\n</div>',
    hints: [
      '<p>\n  Think about the properties of a BST. Looking at the pre-order-traversal nodes\n  (values), how can you determine the right child of a particular node?\n</p>\n',
      "\n<p>\n  The right child of any BST node is simply the first node in the pre-order\n  traversal whose value is larger than or equal to the particular node's value.\n  From this, we know that the nodes in the pre-order traversal that come before\n  the right child of a node must be in the left subtree of that node.\n</p>\n",
      "\n<p>\n  Once you determine the right child of any given node, you're able to generate\n  the entire left and right subtrees of that node. You can do so by recursively\n  creating the left and right child nodes of each subsequent node using the fact\n  stated in Hint #2. A node that has no left and right children is naturally a\n  leaf node.\n</p>\n",
      "\n<p>\n  To solve this problem with an optimal time complexity, you need to realize\n  that it's unnecessary to locate the right child of every node. You can simply\n  keep track of the pre-order-traversal position of the current node that needs\n  to be created and try to insert that node as the left or right child of the\n  relevant previously visited node. Since this tree is a BST, every node must\n  satisfy the BST property; by somehow keeping track of lower and upper bounds\n  for node values, you should be able to determine if a node can be inserted as\n  the left or right child of another node. With this approach, you can solve\n  this problem in linear time. See this question's video explanation for a more\n  detailed explanation of this approach.\n</p>",
    ],
    customInputVars: [
      {
        name: 'preOrderTraversalValues',
        example: [10, 4, 2, 1, 5, 17, 19, 18],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value, left = null, right = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction reconstructBst(preOrderTraversalValues) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.reconstructBst = reconstructBst;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value, left = null, right = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// O(n^2) time | O(n) space - where n is the length of the input array\nfunction reconstructBst(preOrderTraversalValues) {\n  if (preOrderTraversalValues.length === 0) return null;\n\n  const currentValue = preOrderTraversalValues[0];\n  let rightSubtreeRootIdx = preOrderTraversalValues.length;\n\n  for (let idx = 1; idx < preOrderTraversalValues.length; idx++) {\n    const value = preOrderTraversalValues[idx];\n    if (value >= currentValue) {\n      rightSubtreeRootIdx = idx;\n      break;\n    }\n  }\n\n  const leftSubtree = reconstructBst(preOrderTraversalValues.slice(1, rightSubtreeRootIdx));\n  const rightSubtree = reconstructBst(preOrderTraversalValues.slice(rightSubtreeRootIdx));\n  return new BST(currentValue, leftSubtree, rightSubtree);\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.reconstructBst = reconstructBst;\n',
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value, left = null, right = null) {\n    this.value = value;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nclass TreeInfo {\n  constructor(rootIdx) {\n    this.rootIdx = rootIdx;\n  }\n}\n\n// O(n) time | O(n) space - where n is the length of the input array\nfunction reconstructBst(preOrderTraversalValues) {\n  const treeInfo = new TreeInfo(0);\n  return reconstructBstFromRange(-Infinity, Infinity, preOrderTraversalValues, treeInfo);\n}\n\nfunction reconstructBstFromRange(\n  lowerBound,\n  upperBound,\n  preOrderTraversalValues,\n  currentSubtreeInfo,\n) {\n  if (currentSubtreeInfo.rootIdx === preOrderTraversalValues.length) return null;\n\n  const rootValue = preOrderTraversalValues[currentSubtreeInfo.rootIdx];\n  if (rootValue < lowerBound || rootValue >= upperBound) return null;\n\n  currentSubtreeInfo.rootIdx++;\n  const leftSubtree = reconstructBstFromRange(\n    lowerBound,\n    rootValue,\n    preOrderTraversalValues,\n    currentSubtreeInfo,\n  );\n  const rightSubtree = reconstructBstFromRange(\n    rootValue,\n    upperBound,\n    preOrderTraversalValues,\n    currentSubtreeInfo,\n  );\n  return new BST(rootValue, leftSubtree, rightSubtree);\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.reconstructBst = reconstructBst;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nfunction getDfsOrder(node, values) {\n  if (node === null) return;\n  values.push(node.value);\n  getDfsOrder(node.left, values);\n  getDfsOrder(node.right, values);\n  return values;\n}\n\nit('Test Case #1', function () {\n  const preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18];\n  const tree = new BST(10);\n  tree.left = new BST(4);\n  tree.left.left = new BST(2);\n  tree.left.left.left = new BST(1);\n  tree.left.right = new BST(3);\n  tree.right = new BST(17);\n  tree.right.right = new BST(19);\n  tree.right.right.left = new BST(18);\n  const expected = getDfsOrder(tree, []);\n  const actual = program.reconstructBst(preOrderTraversalValues);\n  const actualDfsOrder = getDfsOrder(actual, []);\n  chai.expect(actualDfsOrder).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst {BST} = program;\n\nfunction getDfsOrder(node, values) {\n  if (node === null) return;\n  values.push(node.value);\n  getDfsOrder(node.left, values);\n  getDfsOrder(node.right, values);\n  return values;\n}\n\nit('Test Case #1', function () {\n  const preOrderTraversalValues = [10, 4, 2, 1, 3, 17, 19, 18];\n  const tree = new BST(10);\n  tree.left = new BST(4);\n  tree.left.left = new BST(2);\n  tree.left.left.left = new BST(1);\n  tree.left.right = new BST(3);\n  tree.right = new BST(17);\n  tree.right.right = new BST(19);\n  tree.right.right.left = new BST(18);\n  const expected = getDfsOrder(tree, []);\n  const actual = program.reconstructBst(preOrderTraversalValues);\n  const actualDfsOrder = getDfsOrder(actual, []);\n  chai.expect(actualDfsOrder).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input array',
    tests: [
      { preOrderTraversalValues: [10, 4, 2, 1, 5, 17, 19, 18] },
      { preOrderTraversalValues: [100] },
      { preOrderTraversalValues: [10, 9, 8, 7, 6, 5] },
      { preOrderTraversalValues: [5, 6, 7, 8] },
      { preOrderTraversalValues: [5, -10, -5, 6, 9, 7] },
      { preOrderTraversalValues: [10, 4, 2, 1, 3, 5, 6, 9, 7, 17, 19, 18] },
      { preOrderTraversalValues: [1, 0, 2] },
      { preOrderTraversalValues: [2, 0, 1] },
      { preOrderTraversalValues: [2, 0, 1, 4, 3] },
      { preOrderTraversalValues: [2, 0, 1, 4, 3, 3] },
      { preOrderTraversalValues: [2, 0, 1, 3, 4, 3] },
      {
        preOrderTraversalValues: [
          10, 4, 2, 1, 3, 5, 5, 6, 5, 5, 9, 7, 17, 19, 18, 18, 19,
        ],
      },
    ],
  },
  {
    id: 'validate-three-nodes',
    name: 'Validate Three Nodes',
    category: 'Binary Search Trees',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given three nodes that are contained in the same Binary Search Tree:\n  <span>nodeOne</span>, <span>nodeTwo</span>, and <span>nodeThree</span>. Write\n  a function that returns a boolean representing whether one of\n  <span>nodeOne</span> or <span>nodeThree</span> is an ancestor of\n  <span>nodeTwo</span> and the other node is a descendant of\n  <span>nodeTwo</span>. For example, if your function determines that\n  <span>nodeOne</span> is an ancestor of <span>nodeTwo</span>, then it needs to\n  see if <span>nodeThree</span> is a descendant of <span>nodeTwo</span>. If your\n  function determines that <span>nodeThree</span> is an ancestor, then it needs\n  to see if <span>nodeOne</span> is a descendant.\n</p>\n<p>\n  A <b>descendant</b> of a node <span>N</span> is defined as a node contained in\n  the tree rooted at <span>N</span>. A node <span>N</span> is an ancestor of\n  another node <span>M</span> if <span>M</span> is a descendant of\n  <span>N</span>.\n</p>\n<p>\n  It isn\'t guaranteed that <span>nodeOne</span> or <span>nodeThree</span> will\n  be ancestors or descendants of <span>nodeTwo</span>, but it is guaranteed that\n  all three nodes will be unique and will never be <span>None</span> /\n  <span>null</span>. In other words, you\'ll be given valid input nodes.\n</p>\n<p>\n  Each <span>BST</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. A node is\n  said to be a valid <span>BST</span> node if and only if it satisfies the BST\n  property: its <span>value</span> is strictly greater than the values of every\n  node to its left; its <span>value</span> is less than or equal to the values\n  of every node to its right; and its children nodes are either valid\n  <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =    5\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      2       7\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   1     4 6     8\n  /     /\n 0     3  \n<span class="CodeEditor-promptComment">// This tree won\'t actually be passed as an input; it\'s here to help you visualize the problem.</span>\n<span class="CodeEditor-promptParameter">nodeOne</span> = 5 <span class="CodeEditor-promptComment">// The actual node with value 5.</span>\n<span class="CodeEditor-promptParameter">nodeTwo</span> = 2 <span class="CodeEditor-promptComment">// The actual node with value 2.</span>\n<span class="CodeEditor-promptParameter">nodeThree</span> = 3 <span class="CodeEditor-promptComment">// The actual node with value 3.</span>\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue <span class="CodeEditor-promptComment">// nodeOne is an ancestor of nodeTwo, and nodeThree is a descendant of nodeTwo.</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  Keep in mind that the nodes passed to you are contained in a Binary\n  <b><i>Search</i></b>\n  Treenot just a normal Binary Tree. How might this help you traverse the tree\n  faster?\n</p>\n',
      "\n<p>\n  There are multiple ways to solve this problem, but the simplest is to just\n  check the possible relationships between the nodes. Since you're looking for a\n  descendant and an ancestor, simply check if <span>nodeOne</span> is a\n  descendant of <span>nodeTwo</span>, and if it is, then check if\n  <span>nodeThree</span> is an ancestor of <span>nodeTwo</span>. If the previous\n  checks come out negative, check if <span>nodeThree</span> is a descendant of\n  <span>nodeTwo</span>, and if it is, then check if <span>nodeOne</span> is an\n  ancestor of <span>nodeTwo</span>.\n</p>\n",
      "\n<p>\n  Although the approach mentioned in Hint #2 is fairly efficient (it runs in\n  <span>O(h)</span> time, where h is the height of the tree), there's a way to\n  solve this problem faster. It involves realizing that, when searching for\n  <span>nodeTwo</span> from either <span>nodeOne</span> or\n  <span>nodeThree</span>, if you ever reach <span>nodeThree</span> from\n  <span>nodeOne</span> or <span>nodeOne</span> from\n  <span>nodeThree</span> before reaching <span>nodeTwo</span>, then you can\n  immediately stop the algorithm, because <span>nodeTwo</span> cannot be between\n  these nodes. See the Conceptual Overview section of this question's video\n  explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '0', left: null, right: null, value: 0 },
            { id: '1', left: '0', right: null, value: 1 },
            { id: '2', left: '1', right: '4', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: '3', right: null, value: 4 },
            { id: '5', left: '2', right: '7', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: '6', right: '8', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '5',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
      { name: 'nodeOne', example: '5', schema: { type: 'string' } },
      { name: 'nodeTwo', example: '2', schema: { type: 'string' } },
      { name: 'nodeThree', example: '3', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction validateThreeNodes(nodeOne, nodeTwo, nodeThree) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.validateThreeNodes = validateThreeNodes;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(h) time | O(h) space - where h is the height of the tree\nfunction validateThreeNodes(nodeOne, nodeTwo, nodeThree) {\n  if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo);\n\n  if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo);\n\n  return false;\n}\n\n// Whether the `target` is a descendant of the `node`.\nfunction isDescendant(node, target) {\n  if (node === null) return false;\n\n  if (node === target) return true;\n\n  return target.value < node.value\n    ? isDescendant(node.left, target)\n    : isDescendant(node.right, target);\n}\n\n// Do not edit the lines below.\nexports.validateThreeNodes = validateThreeNodes;\nexports.BST = BST;\n',
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(h) time | O(1) space - where h is the height of the tree\nfunction validateThreeNodes(nodeOne, nodeTwo, nodeThree) {\n  if (isDescendant(nodeTwo, nodeOne)) return isDescendant(nodeThree, nodeTwo);\n\n  if (isDescendant(nodeTwo, nodeThree)) return isDescendant(nodeOne, nodeTwo);\n\n  return false;\n}\n\n// Whether the `target` is a descendant of the `node`.\nfunction isDescendant(node, target) {\n  while (node !== null && node !== target) {\n    node = target.value < node.value ? node.left : node.right;\n  }\n\n  return node === target;\n}\n\n// Do not edit the lines below.\nexports.validateThreeNodes = validateThreeNodes;\nexports.BST = BST;\n',
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree\nfunction validateThreeNodes(nodeOne, nodeTwo, nodeThree) {\n  let searchOne = nodeOne;\n  let searchTwo = nodeThree;\n\n  while (true) {\n    const foundThreeFromOne = searchOne === nodeThree;\n    const foundOneFromThree = searchTwo === nodeOne;\n    const foundNodeTwo = searchOne === nodeTwo || searchTwo === nodeTwo;\n    const finishedSearching = searchOne === null && searchTwo === null;\n    if (foundThreeFromOne || foundOneFromThree || foundNodeTwo || finishedSearching) {\n      break;\n    }\n\n    if (searchOne !== null) {\n      searchOne = searchOne.value > nodeTwo.value ? searchOne.left : searchOne.right;\n    }\n\n    if (searchTwo !== null) {\n      searchTwo = searchTwo.value > nodeTwo.value ? searchTwo.left : searchTwo.right;\n    }\n  }\n\n  const foundNodeFromOther = searchOne === nodeThree || searchTwo === nodeOne;\n  const foundNodeTwo = searchOne === nodeTwo || searchTwo === nodeTwo;\n  if (!foundNodeTwo || foundNodeFromOther) return false;\n\n  return searchForTarget(nodeTwo, searchOne === nodeTwo ? nodeThree : nodeOne);\n}\n\nfunction searchForTarget(node, target) {\n  while (node !== null && node !== target) {\n    node = target.value < node.value ? node.left : node.right;\n  }\n\n  return node === target;\n}\n\n// Do not edit the lines below.\nexports.validateThreeNodes = validateThreeNodes;\nexports.BST = BST;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BST(5);\n  root.left = new program.BST(2);\n  root.right = new program.BST(7);\n  root.left.left = new program.BST(1);\n  root.left.right = new program.BST(4);\n  root.right.left = new program.BST(6);\n  root.right.right = new program.BST(8);\n  root.left.left.left = new program.BST(0);\n  root.left.right.left = new program.BST(3);\n\n  const nodeOne = root;\n  const nodeTwo = root.left;\n  const nodeThree = root.left.right.left;\n  const expected = true;\n  const actual = program.validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BST(5);\n  root.left = new program.BST(2);\n  root.right = new program.BST(7);\n  root.left.left = new program.BST(1);\n  root.left.right = new program.BST(4);\n  root.right.left = new program.BST(6);\n  root.right.right = new program.BST(8);\n  root.left.left.left = new program.BST(0);\n  root.left.right.left = new program.BST(3);\n\n  const nodeOne = root;\n  const nodeTwo = root.left;\n  const nodeThree = root.left.right.left;\n  const expected = true;\n  const actual = program.validateThreeNodes(nodeOne, nodeTwo, nodeThree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(d) time | O(1) space - where d is the distance between nodeOne and nodeThree',
    tests: [
      {
        nodeOne: '5',
        nodeThree: '3',
        nodeTwo: '2',
        tree: {
          nodes: [
            { id: '0', left: null, right: null, value: 0 },
            { id: '1', left: '0', right: null, value: 1 },
            { id: '2', left: '1', right: '4', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: '3', right: null, value: 4 },
            { id: '5', left: '2', right: '7', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: '6', right: '8', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '5',
        },
      },
      {
        nodeOne: '5',
        nodeThree: '1',
        nodeTwo: '8',
        tree: {
          nodes: [
            { id: '0', left: null, right: null, value: 0 },
            { id: '1', left: '0', right: null, value: 1 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '3', left: '2', right: '4', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '3', right: '7', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: '6', right: '8', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '5',
        },
      },
      {
        nodeOne: '8',
        nodeThree: '2',
        nodeTwo: '5',
        tree: {
          nodes: [
            { id: '0', left: null, right: null, value: 0 },
            { id: '1', left: '0', right: null, value: 1 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '3', left: '2', right: '4', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '3', right: '7', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: '6', right: '8', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '5',
        },
      },
      {
        nodeOne: '2',
        nodeThree: '8',
        nodeTwo: '5',
        tree: {
          nodes: [
            { id: '1', left: null, right: null, value: 1 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '4', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: '6', value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: '8', value: 7 },
            { id: '8', left: null, right: '9', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '2',
        },
      },
      {
        nodeOne: '4',
        nodeThree: '2',
        nodeTwo: '1',
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: '1', right: null, value: 3 },
            { id: '4', left: '3', right: null, value: 4 },
            { id: '5', left: null, right: '5', value: 5 },
            { id: '6', left: '4', right: '8', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: '7', right: '9', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '6',
        },
      },
      {
        nodeOne: '1',
        nodeThree: '3',
        nodeTwo: '2',
        tree: {
          nodes: [
            { id: '1', left: null, right: null, value: 1 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '2',
        },
      },
      {
        nodeOne: '2',
        nodeThree: '13',
        nodeTwo: '4',
        tree: {
          nodes: [
            { id: '1', left: null, right: null, value: 1 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '3', left: '2', right: null, value: 3 },
            { id: '4', left: '3', right: '5', value: 4 },
            { id: '5', left: null, right: '7', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: '6', right: null, value: 7 },
            { id: '8', left: '4', right: '10', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: '9', right: '14', value: 10 },
            { id: '11', left: null, right: null, value: 11 },
            { id: '12', left: '11', right: '13', value: 12 },
            { id: '13', left: null, right: null, value: 13 },
            { id: '14', left: '12', right: null, value: 14 },
          ],
          root: '8',
        },
      },
      {
        nodeOne: '8',
        nodeThree: '1',
        nodeTwo: '7',
        tree: {
          nodes: [
            { id: '1', left: null, right: null, value: 1 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '3', left: '2', right: null, value: 3 },
            { id: '4', left: '3', right: null, value: 4 },
            { id: '5', left: '4', right: null, value: 5 },
            { id: '6', left: '5', right: null, value: 6 },
            { id: '7', left: '6', right: null, value: 7 },
            { id: '8', left: '7', right: '9', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '8',
        },
      },
      {
        nodeOne: '2',
        nodeThree: '3',
        nodeTwo: '1',
        tree: {
          nodes: [
            { id: '1', left: null, right: null, value: 1 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '3', left: '2', right: null, value: 3 },
          ],
          root: '3',
        },
      },
      {
        nodeOne: '1',
        nodeThree: '3',
        nodeTwo: '2',
        tree: {
          nodes: [
            { id: '1', left: null, right: null, value: 1 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '3', left: '2', right: null, value: 3 },
          ],
          root: '3',
        },
      },
      {
        nodeOne: '9',
        nodeThree: '6',
        nodeTwo: '8',
        tree: {
          nodes: [
            { id: '1', left: null, right: null, value: 1 },
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '4', left: '2', right: '5', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '6', left: '4', right: '8', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: '7', right: '9', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '6',
        },
      },
      {
        nodeOne: '12',
        nodeThree: '15',
        nodeTwo: '13',
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: '1', right: '4', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '3', right: null, value: 5 },
            { id: '6', left: '5', right: '8', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: '7', right: '9', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: '6', right: '15', value: 10 },
            { id: '11', left: null, right: '12', value: 11 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '13', left: '11', right: null, value: 13 },
            { id: '14', left: '13', right: null, value: 14 },
            { id: '15', left: '14', right: '18', value: 15 },
            { id: '16', left: null, right: null, value: 16 },
            { id: '17', left: '16', right: null, value: 17 },
            { id: '18', left: '17', right: null, value: 18 },
          ],
          root: '10',
        },
      },
      {
        nodeOne: '5',
        nodeThree: '15',
        nodeTwo: '10',
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: '1', right: '4', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '3', right: null, value: 5 },
            { id: '6', left: '5', right: '8', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '8', left: '7', right: '9', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: '6', right: '15', value: 10 },
            { id: '11', left: null, right: '12', value: 11 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '13', left: '11', right: null, value: 13 },
            { id: '14', left: '13', right: null, value: 14 },
            { id: '15', left: '14', right: '18', value: 15 },
            { id: '16', left: null, right: null, value: 16 },
            { id: '17', left: '16', right: null, value: 17 },
            { id: '18', left: '17', right: null, value: 18 },
          ],
          root: '10',
        },
      },
      {
        nodeOne: '5',
        nodeThree: '4',
        nodeTwo: '3',
        tree: {
          nodes: [
            { id: '0', left: null, right: null, value: 0 },
            { id: '1', left: '0', right: null, value: 1 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '3', left: '2', right: '4', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '3', right: '7', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: '6', right: '8', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '5',
        },
      },
      {
        nodeOne: '5',
        nodeThree: '1',
        nodeTwo: '3',
        tree: {
          nodes: [
            { id: '0', left: null, right: null, value: 0 },
            { id: '1', left: '0', right: null, value: 1 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '3', left: '2', right: '4', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: '3', right: '7', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '7', left: '6', right: '8', value: 7 },
            { id: '8', left: null, right: null, value: 8 },
          ],
          root: '5',
        },
      },
    ],
  },
  {
    id: 'two-number-sum',
    name: 'Two Number Sum',
    category: 'Arrays',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of distinct integers and an\n  integer representing a target sum. If any two numbers in the input array sum\n  up to the target sum, the function should return them in an array, in any\n  order. If no two numbers sum up to the target sum, the function should return\n  an empty array.\n</p>\n<p>\n  Note that the target sum has to be obtained by summing two different integers\n  in the array; you can\'t add a single integer to itself in order to obtain the\n  target sum.\n</p>\n<p>\n  You can assume that there will be at most one pair of numbers summing up to\n  the target sum.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [3, 5, -4, 8, 11, 1, -1, 6]\n<span class="CodeEditor-promptParameter">targetSum</span> = 10\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[-1, 11] <span class="CodeEditor-promptComment">// the numbers could be in reverse order</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry using two for loops to sum all possible pairs of numbers in the input array. What are the time and space implications of this approach?\n</p>\n',
      "\n<p>\nRealize that for every number X in the input array, you are essentially trying to find a corresponding number Y such that X + Y = targetSum. With two variables in this equation known to you, it shouldn't be hard to solve for Y.\n</p>\n",
      '\n<p>\nTry storing every number in a hash table, solving the equation mentioned in Hint #2 for every number, and checking if the Y that you find is stored in the hash table. What are the time and space implications of this approach?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [3, 5, -4, 8, 11, 1, -1, 6],
        schema: {
          items: { type: 'integer' },
          minItems: 1,
          type: 'array',
          uniqueItems: true,
        },
      },
      { name: 'targetSum', example: 10, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function twoNumberSum(array, targetSum) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.twoNumberSum = twoNumberSum;\n',
      solutions: [
        '// O(n^2) time | O(1) space\nfunction twoNumberSum(array, targetSum) {\n  for (let i = 0; i < array.length - 1; i++) {\n    const firstNum = array[i];\n    for (let j = i + 1; j < array.length; j++) {\n      const secondNum = array[j];\n      if (firstNum + secondNum === targetSum) {\n        return [firstNum, secondNum];\n      }\n    }\n  }\n  return [];\n}\n\nexports.twoNumberSum = twoNumberSum;\n',
        '// O(n) time | O(n) space\nfunction twoNumberSum(array, targetSum) {\n  const nums = {};\n  for (const num of array) {\n    const potentialMatch = targetSum - num;\n    if (potentialMatch in nums) {\n      return [potentialMatch, num];\n    } else {\n      nums[num] = true;\n    }\n  }\n  return [];\n}\n\nexports.twoNumberSum = twoNumberSum;\n',
        '// O(nlog(n)) | O(1) space\nfunction twoNumberSum(array, targetSum) {\n  array.sort((a, b) => a - b);\n  let left = 0;\n  let right = array.length - 1;\n  while (left < right) {\n    const currentSum = array[left] + array[right];\n    if (currentSum === targetSum) {\n      return [array[left], array[right]];\n    } else if (currentSum < targetSum) {\n      left++;\n    } else if (currentSum > targetSum) {\n      right--;\n    }\n  }\n  return [];\n}\n\nexports.twoNumberSum = twoNumberSum;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const output = program.twoNumberSum([3, 5, -4, 8, 11, 1, -1, 6], 10);\n  chai.expect(output.length === 2).to.deep.equal(true);\n  chai.expect(output.includes(11)).to.deep.equal(true);\n  chai.expect(output.includes(-1)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const output = program.twoNumberSum([3, 5, -4, 8, 11, 1, -1, 6], 10);\n  chai.expect(output.length === 2).to.deep.equal(true);\n  chai.expect(output.includes(11)).to.deep.equal(true);\n  chai.expect(output.includes(-1)).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input array',
    tests: [
      { array: [3, 5, -4, 8, 11, 1, -1, 6], targetSum: 10 },
      { array: [4, 6], targetSum: 10 },
      { array: [4, 6, 1], targetSum: 5 },
      { array: [4, 6, 1, -3], targetSum: 3 },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9], targetSum: 17 },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 15], targetSum: 18 },
      { array: [-7, -5, -3, -1, 0, 1, 3, 5, 7], targetSum: -5 },
      { array: [-21, 301, 12, 4, 65, 56, 210, 356, 9, -47], targetSum: 163 },
      { array: [-21, 301, 12, 4, 65, 56, 210, 356, 9, -47], targetSum: 164 },
      { array: [3, 5, -4, 8, 11, 1, -1, 6], targetSum: 15 },
      { array: [14], targetSum: 15 },
      { array: [15], targetSum: 15 },
    ],
  },
  {
    id: 'three-number-sum',
    name: 'Three Number Sum',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of distinct integers and an\n  integer representing a target sum. The function should find all triplets in\n  the array that sum up to the target sum and return a two-dimensional array of\n  all these triplets. The numbers in each triplet should be ordered in ascending\n  order, and the triplets themselves should be ordered in ascending order with\n  respect to the numbers they hold.\n</p>\n<p>\n  If no three numbers sum up to the target sum, the function should return an\n  empty array.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [12, 3, 1, 2, -6, 5, -8, 6]\n<span class="CodeEditor-promptParameter">targetSum</span> = 0\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]\n</pre>\n</div>',
    hints: [
      '<p>\nUsing three for loops to calculate the sums of all possible triplets in the array would generate an algorithm that runs in O(n^3) time, where n is the length of the input array. Can you come up with something faster using only two for loops?\n</p>\n',
      '\n<p>\nTry sorting the array and traversing it once. At each number, place a left pointer on the number immediately to the right of your current number and a right pointer on the final number in the array. Check if the current number, the left number, and the right number sum up to the target sum. How can you proceed from there, remembering the fact that you sorted the array?\n</p>\n',
      "\n<p>\nSince the array is now sorted (see Hint #2), you know that moving the left pointer mentioned in Hint #2 one place to the right will lead to a greater left number and thus a greater sum. Similarly, you know that moving the right pointer one place to the left will lead to a smaller right number and thus a smaller sum. This means that, depending on the size of each triplet's (current number, left number, right number) sum relative to the target sum, you should either move the left pointer, the right pointer, or both to obtain a potentially valid triplet.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [12, 3, 1, 2, -6, 5, -8, 6],
        schema: {
          items: { type: 'integer' },
          minItems: 1,
          type: 'array',
          uniqueItems: true,
        },
      },
      { name: 'targetSum', example: 0, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function threeNumberSum(array, targetSum) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.threeNumberSum = threeNumberSum;\n',
      solutions: [
        '// O(n^2) time | O(n) space\nfunction threeNumberSum(array, targetSum) {\n  array.sort((a, b) => a - b);\n  const triplets = [];\n  for (let i = 0; i < array.length - 2; i++) {\n    let left = i + 1;\n    let right = array.length - 1;\n    while (left < right) {\n      const currentSum = array[i] + array[left] + array[right];\n      if (currentSum === targetSum) {\n        triplets.push([array[i], array[left], array[right]]);\n        left++;\n        right--;\n      } else if (currentSum < targetSum) {\n        left++;\n      } else if (currentSum > targetSum) {\n        right--;\n      }\n    }\n  }\n  return triplets;\n}\n\nexports.threeNumberSum = threeNumberSum;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.threeNumberSum([12, 3, 1, 2, -6, 5, -8, 6], 0)).to.deep.equal([\n    [-8, 2, 6],\n    [-8, 3, 5],\n    [-6, 1, 5],\n  ]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.threeNumberSum([12, 3, 1, 2, -6, 5, -8, 6], 0)).to.deep.equal([\n    [-8, 2, 6],\n    [-8, 3, 5],\n    [-6, 1, 5],\n  ]);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the length of the input array',
    tests: [
      { array: [12, 3, 1, 2, -6, 5, -8, 6], targetSum: 0 },
      { array: [1, 2, 3], targetSum: 6 },
      { array: [1, 2, 3], targetSum: 7 },
      { array: [8, 10, -2, 49, 14], targetSum: 57 },
      { array: [12, 3, 1, 2, -6, 5, 0, -8, -1], targetSum: 0 },
      { array: [12, 3, 1, 2, -6, 5, 0, -8, -1, 6], targetSum: 0 },
      { array: [12, 3, 1, 2, -6, 5, 0, -8, -1, 6, -5], targetSum: 0 },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 15], targetSum: 18 },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 15], targetSum: 32 },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 15], targetSum: 33 },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 15], targetSum: 5 },
    ],
  },
  {
    id: 'four-number-sum',
    name: 'Four Number Sum',
    category: 'Arrays',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of distinct integers and an\n  integer representing a target sum. The function should find all quadruplets in\n  the array that sum up to the target sum and return a two-dimensional array of\n  all these quadruplets in no particular order.\n</p>\n<p>\n  If no four numbers sum up to the target sum, the function should return an\n  empty array.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [7, 6, 4, -1, 1, 2]\n<span class="CodeEditor-promptParameter">targetSum</span> = 16\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[7, 6, 4, -1], [7, 6, 1, 2]] <span class="CodeEditor-promptComment">// the quadruplets could be ordered differently</span>\n</pre>\n</div>',
    hints: [
      '<p>\nUsing four for loops to calculate the sums of all possible quadruplets in the array would generate an algorithm that runs in O(n^4) time, where n is the length of the input array. Can you come up with something faster using fewer for loops?\n</p>\n',
      "\n<p>\nYou can calculate the sums of every pair of numbers in the array in O(n^2) time using just two for loops. Then, assuming that you've stored all of these sums in a hash table, you can fairly easily find which two sums can be paired to add up to the target sum: the numbers summing up to these two sums constitute candidates for valid quadruplets; you just have to make sure that no number was used to generate both of the two sums.\n</p>\n",
      "\n<p>\nYou can do everything described in Hint #2 with just two sibling for loops nested inside a third for loop. Your goal is to create a hash table mapping the sums of every pair of numbers in the array to an array of arrays, with each subarray representing the indices of each pair summing up to that number. Loop through the input array with a simple for loop. Inside this loop, loop through the input array again, starting at the index of the first loop. At each iteration, calculate the difference between the target sum and the sum of the two numbers represented by the indices of the for loops. If that difference is in the hash table that you're building, then valid quadruplets can be formed by combining the current pair of numbers with each pair stored in the hash table at the difference just calculated. Following this nested for loop, loop through the array again, this time starting at index zero all the way to the index of the first for loop. At each iteration, calculate the sum of the two numbers represented by the indices of the for loops and add it to the hash table if it isn't already there; then add the pair of indices to the array that the sum in the hash table maps to.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [7, 6, 4, -1, 1, 2],
        schema: {
          items: { type: 'integer' },
          minItems: 1,
          type: 'array',
          uniqueItems: true,
        },
      },
      { name: 'targetSum', example: 16, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function fourNumberSum(array, targetSum) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.fourNumberSum = fourNumberSum;\n',
      solutions: [
        '// Average: O(n^2) time | O(n^2) space\n// Worst: O(n^3) time | O(n^2) space\nfunction fourNumberSum(array, targetSum) {\n  const allPairSums = {};\n  const quadruplets = [];\n  for (let i = 1; i < array.length - 1; i++) {\n    for (let j = i + 1; j < array.length; j++) {\n      const currentSum = array[i] + array[j];\n      const difference = targetSum - currentSum;\n      if (difference in allPairSums) {\n        for (const pair of allPairSums[difference]) {\n          quadruplets.push(pair.concat([array[i], array[j]]));\n        }\n      }\n    }\n    for (let k = 0; k < i; k++) {\n      const currentSum = array[i] + array[k];\n      if (!(currentSum in allPairSums)) {\n        allPairSums[currentSum] = [[array[k], array[i]]];\n      } else {\n        allPairSums[currentSum].push([array[k], array[i]]);\n      }\n    }\n  }\n  return quadruplets;\n}\n\nexports.fourNumberSum = fourNumberSum;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nfunction sortAndStringify(array) {\n  return array.sort((a, b) => a - b).join(',');\n}\n\nit('Test Case #1', function () {\n  let output = program.fourNumberSum([7, 6, 4, -1, 1, 2], 16);\n  output = output.map(sortAndStringify);\n  const quadruplets = [\n    [7, 6, 4, -1],\n    [7, 6, 1, 2],\n  ];\n  chai.expect(output.length === 2).to.be.true;\n  for (const quadruplet of quadruplets) {\n    chai.expect(output).to.include(sortAndStringify(quadruplet));\n  }\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nfunction sortAndStringify(array) {\n  return array.sort((a, b) => a - b).join(',');\n}\n\nit('Test Case #1', function () {\n  let output = program.fourNumberSum([7, 6, 4, -1, 1, 2], 16);\n  output = output.map(sortAndStringify);\n  const quadruplets = [\n    [7, 6, 4, -1],\n    [7, 6, 1, 2],\n  ];\n  chai.expect(output.length === 2).to.be.true;\n  for (const quadruplet of quadruplets) {\n    chai.expect(output).to.include(sortAndStringify(quadruplet));\n  }\n});\n",
    },
    bigO: 'Average: O(n^2) time | O(n^2) space - where n is the length of the input array\nWorst: O(n^3) time | O(n^2) space - where n is the length of the input array',
    tests: [
      { array: [7, 6, 4, -1, 1, 2], targetSum: 16 },
      { array: [1, 2, 3, 4, 5, 6, 7], targetSum: 10 },
      { array: [5, -5, -2, 2, 3, -3], targetSum: 0 },
      { array: [-2, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9], targetSum: 4 },
      { array: [-1, 22, 18, 4, 7, 11, 2, -5, -3], targetSum: 30 },
      { array: [-10, -3, -5, 2, 15, -7, 28, -6, 12, 8, 11, 5], targetSum: 20 },
      { array: [1, 2, 3, 4, 5], targetSum: 100 },
      { array: [1, 2, 3, 4, 5, -5, 6, -6], targetSum: 5 },
    ],
  },
  {
    id: 'smallest-difference',
    name: 'Smallest Difference',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in two non-empty arrays of integers, finds the\n  pair of numbers (one from each array) whose absolute difference is closest to\n  zero, and returns an array containing these two numbers, with the number from\n  the first array in the first position.\n</p>\n<p>\n  Note that the absolute difference of two integers is the distance between\n  them on the real number line. For example, the absolute difference of -5 and 5\n  is 10, and the absolute difference of -5 and -4 is 1.\n</p>\n<p>\n  You can assume that there will only be one pair of numbers with the smallest\n  difference.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">arrayOne</span> = [-1, 5, 10, 20, 28, 3]\n<span class="CodeEditor-promptParameter">arrayTwo</span> = [26, 134, 135, 15, 17]\n</pre>\n<h3>Sample Output</h3>\n<pre>[28, 26]</pre>\n</div>',
    hints: [
      '<p>\nInstead of generating all possible pairs of numbers, try somehow only looking at pairs that you know could actually have the smallest difference. How can you accomplish this?\n</p>\n',
      '\n<p>\nWould it help if the two arrays were sorted? If the arrays were sorted and you were looking at a given pair of numbers, could you efficiently find the next pair of numbers to look at? What are the runtime implications of sorting the arrays?\n</p>\n',
      "\n<p>\nStart by sorting both arrays, as per Hint #2. Put a pointer at the beginning of both arrays and evaluate the absolute difference of the pointer-numbers. If the difference is equal to zero, then you've found the closest pair; otherwise, increment the pointer of the smaller of the two numbers to find a potentially better pair. Continue until you get a pair with a difference of zero or until one of the pointers gets out of range of its array.\n</p>",
    ],
    customInputVars: [
      {
        name: 'arrayOne',
        example: [-1, 5, 10, 20, 28, 3],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
      {
        name: 'arrayTwo',
        example: [26, 134, 135, 15, 17],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function smallestDifference(arrayOne, arrayTwo) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.smallestDifference = smallestDifference;\n',
      solutions: [
        '// O(nlog(n) + mlog(m)) time | O(1) space\nfunction smallestDifference(arrayOne, arrayTwo) {\n  arrayOne.sort((a, b) => a - b);\n  arrayTwo.sort((a, b) => a - b);\n  let idxOne = 0;\n  let idxTwo = 0;\n  let smallest = Infinity;\n  let current = Infinity;\n  let smallestPair = [];\n  while (idxOne < arrayOne.length && idxTwo < arrayTwo.length) {\n    let firstNum = arrayOne[idxOne];\n    let secondNum = arrayTwo[idxTwo];\n    if (firstNum < secondNum) {\n      current = secondNum - firstNum;\n      idxOne++;\n    } else if (secondNum < firstNum) {\n      current = firstNum - secondNum;\n      idxTwo++;\n    } else {\n      return [firstNum, secondNum];\n    }\n    if (smallest > current) {\n      smallest = current;\n      smallestPair = [firstNum, secondNum];\n    }\n  }\n  return smallestPair;\n}\n\nexports.smallestDifference = smallestDifference;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.smallestDifference([-1, 5, 10, 20, 28, 3], [26, 134, 135, 15, 17]))\n    .to.deep.equal([28, 26]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.smallestDifference([-1, 5, 10, 20, 28, 3], [26, 134, 135, 15, 17]))\n    .to.deep.equal([28, 26]);\n});\n",
    },
    bigO: 'O(nlog(n) + mlog(m)) time | O(1) space - where n is the length of the first input array and m is the length of the second input array',
    tests: [
      { arrayOne: [-1, 5, 10, 20, 28, 3], arrayTwo: [26, 134, 135, 15, 17] },
      { arrayOne: [-1, 5, 10, 20, 3], arrayTwo: [26, 134, 135, 15, 17] },
      { arrayOne: [10, 0, 20, 25], arrayTwo: [1005, 1006, 1014, 1032, 1031] },
      {
        arrayOne: [10, 0, 20, 25, 2200],
        arrayTwo: [1005, 1006, 1014, 1032, 1031],
      },
      {
        arrayOne: [10, 0, 20, 25, 2000],
        arrayTwo: [1005, 1006, 1014, 1032, 1031],
      },
      {
        arrayOne: [240, 124, 86, 111, 2, 84, 954, 27, 89],
        arrayTwo: [1, 3, 954, 19, 8],
      },
      { arrayOne: [0, 20], arrayTwo: [21, -2] },
      {
        arrayOne: [10, 1000],
        arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
      },
      {
        arrayOne: [10, 1000, 9124, 2142, 59, 24, 596, 591, 124, -123],
        arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
      },
      {
        arrayOne: [10, 1000, 9124, 2142, 59, 24, 596, 591, 124, -123, 530],
        arrayTwo: [-1441, -124, -25, 1014, 1500, 660, 410, 245, 530],
      },
    ],
  },
  {
    id: 'subarray-sort',
    name: 'Subarray Sort',
    category: 'Arrays',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of at least two integers and that\n  returns an array of the starting and ending indices of the smallest subarray\n  in the input array that needs to be sorted in place in order for the entire\n  input array to be sorted (in ascending order).\n</p>\n<p>\n  If the input array is already sorted, the function should return\n  <span>[-1, -1]</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[3, 9]\n</pre>\n</div>',
    hints: [
      '<p>\nRealize that even a single out-of-order number in the input array can call for a large subarray to have to be sorted. This is because, depending on how out-of-place the number is, it might need to be moved very far away from its original position in order to be in its sorted position.\n</p>\n',
      '\n<p>\nFind the smallest and largest numbers that are out of order in the input array. You should be able to do this in a single pass through the array.\n</p>\n',
      "\n<p>\nOnce you've found the smallest and largest out-of-order numbers mentioned in Hint #2, find their final sorted positions in the array. This should give you the extremities of the smallest subarray that needs to be sorted.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19],
        schema: { items: { type: 'integer' }, minItems: 2, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function subarraySort(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.subarraySort = subarraySort;\n',
      solutions: [
        '// O(n) time | O(1) space\nfunction subarraySort(array) {\n  let minOutOfOrder = Infinity;\n  let maxOutOfOrder = -Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const num = array[i];\n    if (isOutOfOrder(i, num, array)) {\n      minOutOfOrder = Math.min(minOutOfOrder, num);\n      maxOutOfOrder = Math.max(maxOutOfOrder, num);\n    }\n  }\n  if (minOutOfOrder === Infinity) {\n    return [-1, -1];\n  }\n  let subarrayLeftIdx = 0;\n  while (minOutOfOrder >= array[subarrayLeftIdx]) {\n    subarrayLeftIdx++;\n  }\n  let subarrayRightIdx = array.length - 1;\n  while (maxOutOfOrder <= array[subarrayRightIdx]) {\n    subarrayRightIdx--;\n  }\n  return [subarrayLeftIdx, subarrayRightIdx];\n}\n\nfunction isOutOfOrder(i, num, array) {\n  if (i === 0) return num > array[i + 1];\n  if (i === array.length - 1) return num < array[i - 1];\n  return num > array[i + 1] || num < array[i - 1];\n}\n\nexports.subarraySort = subarraySort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.subarraySort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]))\n    .to.deep.equal([3, 9]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.subarraySort([1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19]))\n    .to.deep.equal([3, 9]);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19] },
      { array: [1, 2] },
      { array: [2, 1] },
      { array: [1, 2, 4, 7, 10, 11, 7, 12, 7, 7, 16, 18, 19] },
      { array: [1, 2, 4, 7, 10, 11, 7, 12, 13, 14, 16, 18, 19] },
      { array: [1, 2, 8, 4, 5] },
      { array: [4, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 51, 7] },
      { array: [4, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 11, 57] },
      { array: [-41, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 11, 57] },
      { array: [-41, 8, 7, 12, 11, 9, -1, 3, 9, 16, -15, 51, 7] },
      { array: [1, 2, 3, 4, 5, 6, 8, 7, 9, 10, 11] },
      {
        array: [1, 2, 3, 4, 5, 6, 18, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19],
      },
      {
        array: [
          1, 2, 3, 4, 5, 6, 18, 21, 22, 7, 14, 9, 10, 11, 12, 13, 14, 15, 16,
          17, 19, 4, 14, 11, 6, 33, 35, 41, 55,
        ],
      },
      {
        array: [
          1, 2, 20, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        ],
      },
      {
        array: [
          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2,
        ],
      },
      {
        array: [
          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
        ],
      },
      { array: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] },
    ],
  },
  {
    id: 'largest-range',
    name: 'Largest Range',
    category: 'Arrays',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns an array of\n  length 2 representing the largest range of integers contained in that array.\n</p>\n<p>\n  The first number in the output array should be the first number in the range,\n  while the second number should be the last number in the range.\n</p>\n<p>\n  A range of numbers is defined as a set of numbers that come right after each\n  other in the set of real integers. For instance, the output array\n  <span>[2, 6]</span> represents the range <span>{2, 3, 4, 5, 6}</span>, which\n  is a range of length 5. Note that numbers don\'t need to be sorted or adjacent\n  in the input array in order to form a range.\n</p>\n<p>You can assume that there will only be one largest range.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[0, 7]\n</pre>\n</div>',
    hints: [
      '<p>\nHow can you use a hash table to solve this problem with an algorithm that runs in linear time?\n</p>\n',
      '\n<p>\nIterate through the input array once, storing every unique number in a hash table and mapping every number to a falsy value. This hash table will not only provide for fast access of the numbers in the input array, but it will also allow you to keep track of "visited" and "unvisited" numbers, so as not to unnecessarily repeat work.\n</p>\n',
      '\n<p>\nIterate through the input array once more, this time stopping at every number to check if the number is marked as "visited" in the hash table. If it is, skip it; if it isn\'t, start expanding outwards from that number with a left number and a right number, continuously checking if those left and right numbers are in the hash table (and thus in the input array), and marking them as "visited" in the hash table if they are. This should allow you to quickly find the largest range in which the current number is contained, all the while setting you up not to perform unnecessary work later.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function largestRange(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.largestRange = largestRange;\n',
      solutions: [
        '// O(n) time | O(n) space\nfunction largestRange(array) {\n  let bestRange = [];\n  let longestLength = 0;\n  const nums = {};\n  for (const num of array) {\n    nums[num] = true;\n  }\n  for (const num of array) {\n    if (!nums[num]) continue;\n    nums[num] = false;\n    let currentLength = 1;\n    let left = num - 1;\n    let right = num + 1;\n    while (left in nums) {\n      nums[left] = false;\n      currentLength++;\n      left--;\n    }\n    while (right in nums) {\n      nums[right] = false;\n      currentLength++;\n      right++;\n    }\n    if (currentLength > longestLength) {\n      longestLength = currentLength;\n      bestRange = [left + 1, right - 1];\n    }\n  }\n  return bestRange;\n}\n\nexports.largestRange = largestRange;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.largestRange([1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6])).to.deep.equal([0, 7]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.largestRange([1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6])).to.deep.equal([0, 7]);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input array',
    tests: [
      { array: [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6] },
      { array: [1] },
      { array: [1, 2] },
      { array: [4, 2, 1, 3] },
      { array: [4, 2, 1, 3, 6] },
      { array: [8, 4, 2, 10, 3, 6, 7, 9, 1] },
      {
        array: [
          19, -1, 18, 17, 2, 10, 3, 12, 5, 16, 4, 11, 8, 7, 6, 15, 12, 12, 2, 1,
          6, 13, 14,
        ],
      },
      {
        array: [
          0, 9, 19, -1, 18, 17, 2, 10, 3, 12, 5, 16, 4, 11, 8, 7, 6, 15, 12, 12,
          2, 1, 6, 13, 14,
        ],
      },
      {
        array: [
          0, -5, 9, 19, -1, 18, 17, 2, -4, -3, 10, 3, 12, 5, 16, 4, 11, 7, -6,
          -7, 6, 15, 12, 12, 2, 1, 6, 13, 14, -2,
        ],
      },
      {
        array: [
          -7, -7, -7, -7, 8, -8, 0, 9, 19, -1, -3, 18, 17, 2, 10, 3, 12, 5, 16,
          4, 11, -6, 8, 7, 6, 15, 12, 12, -5, 2, 1, 6, 13, 14, -4, -2,
        ],
      },
      { array: [1, 1, 1, 3, 4] },
      { array: [-1, 0, 1] },
      { array: [10, 0, 1] },
    ],
  },
  {
    id: 'min-rewards',
    name: 'Min Rewards',
    category: 'Arrays',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Imagine that you\'re a teacher who\'s just graded the final exam in a class. You\n  have a list of student scores on the final exam in a particular order (not\n  necessarily sorted), and you want to reward your students. You decide to do so\n  fairly by giving them arbitrary rewards following two rules:\n</p>\n<ol>\n  <li>All students must receive at least one reward.</li>\n  <li>\n    Any given student must receive strictly more rewards than an adjacent\n    student (a student immediately to the left or to the right) with a lower\n    score and must receive strictly fewer rewards than an adjacent student with\n    a higher score.\n  </li>\n</ol>\n<p>\n  Write a function that takes in a list of scores and returns the minimum number\n  of rewards that you must give out to students to satisfy the two rules.\n</p>\n<p>\n  You can assume that all students have different scores; in other words, the\n  scores are all unique.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">scores</span> = [8, 4, 2, 1, 3, 6, 7, 9, 5]\n</pre>\n<h3>Sample Output</h3>\n<pre>25 <span class="CodeEditor-promptComment">// you would give out the following rewards: [4, 3, 2, 1, 2, 3, 4, 5, 1]</span></pre>\n</div>',
    hints: [
      "<p>\nYou could try iterating through the input list of scores and incrementing the number of rewards you give to each student if they have a greater score than the previous student's score. However, if you reach a student with a smaller score than the previous student's score, you'll have to backtrack through the array to fix previous reward assignments. During this backtrack, is it correct to simply increment the reward of a student whose score is greater than the next student's score?\n</p>\n",
      '\n<p>\nNotice that there are local mins and local maxes in the input list of scores: scores that are smaller than both scores next to them and scores that are greater than both scores next to them. Find the local mins, and try expanding away from them until you reach local maxes, assigning (and incrementing) rewards as you go.\n</p>\n',
      '\n<p>\nDo you actually need to find the local mins mentioned in Hint #2? Can you simply do two sweeps of the input list of scores, one from left to right, and one from right to left?\n</p>',
    ],
    customInputVars: [
      {
        name: 'scores',
        example: [8, 4, 2, 1, 3, 6, 7, 9, 5],
        schema: {
          items: { type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function minRewards(scores) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.minRewards = minRewards;\n',
      solutions: [
        '// O(n^2) time | O(n) space - where n is the length of the input array\nfunction minRewards(scores) {\n  const rewards = scores.map(_ => 1);\n  for (let i = 1; i < scores.length; i++) {\n    let j = i - 1;\n    if (scores[i] > scores[j]) {\n      rewards[i] = rewards[j] + 1;\n    } else {\n      while (j >= 0 && scores[j] > scores[j + 1]) {\n        rewards[j] = Math.max(rewards[j], rewards[j + 1] + 1);\n        j--;\n      }\n    }\n  }\n  return rewards.reduce((a, b) => a + b);\n}\n\nexports.minRewards = minRewards;\n',
        '// O(n) time | O(n) space - where n is the length of the input array\nfunction minRewards(scores) {\n  const rewards = scores.map(_ => 1);\n  const localMinIdxs = getLocalMinIdxs(scores);\n  for (const localMinIdx of localMinIdxs) {\n    expandFromLocalMinIdx(localMinIdx, scores, rewards);\n  }\n  return rewards.reduce((a, b) => a + b);\n}\n\nfunction getLocalMinIdxs(array) {\n  if (array.length === 1) return [0];\n  const localMinIdxs = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i === 0 && array[i] < array[i + 1]) localMinIdxs.push(i);\n    if (i === array.length - 1 && array[i] < array[i - 1]) localMinIdxs.push(i);\n    if (i === 0 || i === array.length - 1) continue;\n    if (array[i] < array[i + 1] && array[i] < array[i - 1]) localMinIdxs.push(i);\n  }\n  return localMinIdxs;\n}\n\nfunction expandFromLocalMinIdx(localMinIdx, scores, rewards) {\n  let leftIdx = localMinIdx - 1;\n  while (leftIdx >= 0 && scores[leftIdx] > scores[leftIdx + 1]) {\n    rewards[leftIdx] = Math.max(rewards[leftIdx], rewards[leftIdx + 1] + 1);\n    leftIdx--;\n  }\n  let rightIdx = localMinIdx + 1;\n  while (rightIdx < scores.length && scores[rightIdx] > scores[rightIdx - 1]) {\n    rewards[rightIdx] = rewards[rightIdx - 1] + 1;\n    rightIdx++;\n  }\n}\n\nexports.minRewards = minRewards;\n',
        '// O(n) time | O(n) space - where n is the length of the input array\nfunction minRewards(scores) {\n  const rewards = scores.map(_ => 1);\n  for (let i = 1; i < scores.length; i++) {\n    if (scores[i] > scores[i - 1]) rewards[i] = rewards[i - 1] + 1;\n  }\n  for (let i = scores.length - 2; i >= 0; i--) {\n    if (scores[i] > scores[i + 1]) rewards[i] = Math.max(rewards[i], rewards[i + 1] + 1);\n  }\n  return rewards.reduce((a, b) => a + b);\n}\n\nexports.minRewards = minRewards;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.minRewards([8, 4, 2, 1, 3, 6, 7, 9, 5])).to.deep.equal(25);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.minRewards([8, 4, 2, 1, 3, 6, 7, 9, 5])).to.deep.equal(25);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input array',
    tests: [
      { scores: [8, 4, 2, 1, 3, 6, 7, 9, 5] },
      { scores: [1] },
      { scores: [5, 10] },
      { scores: [10, 5] },
      { scores: [4, 2, 1, 3] },
      { scores: [0, 4, 2, 1, 3] },
      { scores: [2, 20, 13, 12, 11, 8, 4, 3, 1, 5, 6, 7, 9, 0] },
      { scores: [2, 1, 4, 3, 6, 5, 8, 7, 10, 9] },
      {
        scores: [
          800, 400, 20, 10, 30, 61, 70, 90, 17, 21, 22, 13, 12, 11, 8, 4, 2, 1,
          3, 6, 7, 9, 0, 68, 55, 67, 57, 60, 51, 661, 50, 65, 53,
        ],
      },
    ],
  },
  {
    id: 'zigzag-traverse',
    name: 'Zigzag Traverse',
    category: 'Arrays',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an n x m two-dimensional array (that can be\n  square-shaped when n == m) and returns a one-dimensional array of all the\n  array\'s elements in zigzag order.\n</p>\n<p>\n  Zigzag order starts at the top left corner of the two-dimensional array, goes\n  down by one element, and proceeds in a zigzag pattern all the way to the\n  bottom right corner.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [\n  [1,  3,  4, 10],\n  [2,  5,  9, 11],\n  [6,  8, 12, 15],\n  [7, 13, 14, 16],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n</pre>\n</div>',
    hints: [
      "<p>\nDon't overthink this question by trying to come up with a clever way of getting the zigzag order. Think about the simplest checks that need to be made to decide when and how to change direction throughout the zigzag traversal.\n</p>\n",
      "\n<p>\nStarting at the top left corner, iterate through the two-dimensional array by keeping track of the direction that you're moving in (up or down). If you're moving up, you know that you need to move in an up-right pattern and that you need to handle the case where you hit the top or the right borders of the array. If you're moving down, you know that you need to move in a down-left pattern and that you need to handle the case where you hit the left or the bottom borders of the array.\n</p>\n",
      "\n<p>\nWhen going up, if you hit the right border, you'll have to go down one element; if you hit the top border, you'll have to go right one element. Similarly, when going down, if you hit the left border, you'll have to go down one element; if you hit the bottom border, you'll have to go right one element.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [
          [1, 3, 4, 10],
          [2, 5, 9, 11],
          [6, 8, 12, 15],
          [7, 13, 14, 16],
        ],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function zigzagTraverse(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.zigzagTraverse = zigzagTraverse;\n',
      solutions: [
        '// O(n) time | O(n) space - where n is the total number of elements in the two-dimensional array\nfunction zigzagTraverse(array) {\n  const height = array.length - 1;\n  const width = array[0].length - 1;\n  const result = [];\n  let row = 0;\n  let col = 0;\n  let goingDown = true;\n  while (!isOutOfBounds(row, col, height, width)) {\n    result.push(array[row][col]);\n    if (goingDown) {\n      if (col === 0 || row === height) {\n        goingDown = false;\n        if (row === height) {\n          col++;\n        } else {\n          row++;\n        }\n      } else {\n        row++;\n        col--;\n      }\n    } else {\n      if (row === 0 || col === width) {\n        goingDown = true;\n        if (col === width) {\n          row++;\n        } else {\n          col++;\n        }\n      } else {\n        row--;\n        col++;\n      }\n    }\n  }\n  return result;\n}\n\nfunction isOutOfBounds(row, col, height, width) {\n  return row < 0 || row > height || col < 0 || col > width;\n}\n\nexports.zigzagTraverse = zigzagTraverse;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const test = [\n    [1, 3, 4, 10],\n    [2, 5, 9, 11],\n    [6, 8, 12, 15],\n    [7, 13, 14, 16],\n  ];\n  chai\n    .expect(program.zigzagTraverse(test))\n    .to.deep.equal([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const test = [\n    [1, 3, 4, 10],\n    [2, 5, 9, 11],\n    [6, 8, 12, 15],\n    [7, 13, 14, 16],\n  ];\n  chai\n    .expect(program.zigzagTraverse(test))\n    .to.deep.equal([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the total number of elements in the two-dimensional array',
    tests: [
      {
        array: [
          [1, 3, 4, 10],
          [2, 5, 9, 11],
          [6, 8, 12, 15],
          [7, 13, 14, 16],
        ],
      },
      { array: [[1]] },
      { array: [[1, 2, 3, 4, 5]] },
      { array: [[1], [2], [3], [4], [5]] },
      {
        array: [
          [1, 3],
          [2, 4],
          [5, 7],
          [6, 8],
          [9, 10],
        ],
      },
      {
        array: [
          [1, 3, 4, 7, 8],
          [2, 5, 6, 9, 10],
        ],
      },
      {
        array: [
          [1, 3, 4, 10, 11],
          [2, 5, 9, 12, 19],
          [6, 8, 13, 18, 20],
          [7, 14, 17, 21, 24],
          [15, 16, 22, 23, 25],
        ],
      },
      {
        array: [
          [1, 3, 4, 10, 11, 20],
          [2, 5, 9, 12, 19, 21],
          [6, 8, 13, 18, 22, 27],
          [7, 14, 17, 23, 26, 28],
          [15, 16, 24, 25, 29, 30],
        ],
      },
      {
        array: [
          [1, 3, 4, 10, 11],
          [2, 5, 9, 12, 20],
          [6, 8, 13, 19, 21],
          [7, 14, 18, 22, 27],
          [15, 17, 23, 26, 28],
          [16, 24, 25, 29, 30],
        ],
      },
      {
        array: [
          [1, 21, -3, 4, 15, 6, -7, 88, 9],
          [10, 11, 112, 12, 20, -1, -2, -3, -4],
          [6, 8, 113, 19, 21, 0, 0, 0, 0],
          [7, 2, 18, 22, -27, 12, 32, -111, 66],
          [15, 17, 23, 226, 28, -28, -226, -23, -17],
          [16, 24, 27, 299, 30, 29, 32, 31, 88],
        ],
      },
    ],
  },
  {
    id: 'apartment-hunting',
    name: 'Apartment Hunting',
    category: 'Arrays',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  You\'re looking to move into a new apartment on specific street, and you\'re\n  given a list of contiguous blocks on that street where each block contains an\n  apartment that you could move into.\n</p>\n<p>\n  You also have a list of requirements: a list of buildings that are important\n  to you. For instance, you might value having a school and a gym near your\n  apartment. The list of blocks that you have contains information at every\n  block about all of the buildings that are present and absent at the block in\n  question. For instance, for every block, you might know whether a school, a\n  pool, an office, and a gym are present.\n</p>\n<p>\n  In order to optimize your life, you want to pick an apartment block such that\n  you minimize the farthest distance you\'d have to walk from your apartment to\n  reach any of your required buildings.\n</p>\n<p>\n  Write a function that takes in a list of contiguous blocks on a specific\n  street and a list of your required buildings and that returns the location\n  (the index) of the block that\'s most optimal for you.\n</p>\n<p>\n  If there are multiple most optimal blocks, your function can return the index\n  of any one of them.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">blocks</span> = [\n  {\n    "gym": false,\n    "school": true,\n    "store": false,\n  },\n  {\n    "gym": true,\n    "school": false,\n    "store": false,\n  },\n  {\n    "gym": true,\n    "school": true,\n    "store": false,\n  },\n  {\n    "gym": false,\n    "school": true,\n    "store": false,\n  },\n  {\n    "gym": false,\n    "school": true,\n    "store": true,\n  },\n]\n<span class="CodeEditor-promptParameter">reqs</span> = ["gym", "school", "store"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// at index 3, the farthest you\'d have to walk to reach a gym, a school, or a store is 1 block; at any other index, you\'d have to walk farther</span>\n</pre>\n</div>',
    hints: [
      '<p>\nFor every block, you want to go through every requirement, and for every requirement, you want to find the closest other block with that requirement (or rather, the smallest distance to another block with that requirement). Once you\'ve done that for every requirement and for every block, you want to pick, for every block, the distance of the farthest requirement. You can do this with three nested "for" loops.\n</p>\n',
      '\n<p>\nIs there a way to optimize on the solution mentioned in Hint #1 (that uses three nested "for" loops) by precomputing the smallest distances of every requirement from every block?\n</p>\n',
      '\n<p>\nFor every requirement, you should be able to precompute its smallest distances from every block by doing two simple passes though the array of blocks: one pass from left to right and one pass from right to left. Once you have these precomputed values, you can iterate through all of the blocks and pick the biggest of all the precomputed distances at that block.\n</p>',
    ],
    customInputVars: [
      {
        name: 'blocks',
        example: [
          { gym: false, school: true, store: false },
          { gym: true, school: false, store: false },
          { gym: true, school: true, store: false },
          { gym: false, school: true, store: false },
          { gym: false, school: true, store: true },
        ],
        schema: {
          items: { additionalProperties: { type: 'boolean' }, type: 'object' },
          type: 'array',
        },
      },
      {
        name: 'reqs',
        example: ['gym', 'school', 'store'],
        schema: { items: { type: 'string' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function apartmentHunting(blocks, reqs) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.apartmentHunting = apartmentHunting;\n',
      solutions: [
        '// O(b^2*r) time | O(b) space - where b is the number of blocks and r is the number of requirements\nfunction apartmentHunting(blocks, reqs) {\n  const maxDistancesAtBlocks = new Array(blocks.length).fill(-Infinity);\n  for (let i = 0; i < blocks.length; i++) {\n    for (const req of reqs) {\n      let closestReqDistance = Infinity;\n      for (let j = 0; j < blocks.length; j++) {\n        if (blocks[j][req]) {\n          closestReqDistance = Math.min(closestReqDistance, distanceBetween(i, j));\n        }\n      }\n      maxDistancesAtBlocks[i] = Math.max(maxDistancesAtBlocks[i], closestReqDistance);\n    }\n  }\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getIdxAtMinValue(array) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a, b) {\n  return Math.abs(a - b);\n}\n\nexports.apartmentHunting = apartmentHunting;\n',
        '// O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements\nfunction apartmentHunting(blocks, reqs) {\n  const minDistancesFromBlocks = reqs.map(req => getMinDistances(blocks, req));\n  const maxDistancesAtBlocks = getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks);\n  return getIdxAtMinValue(maxDistancesAtBlocks);\n}\n\nfunction getMinDistances(blocks, req) {\n  const minDistances = new Array(blocks.length);\n  let closestReqIdx = Infinity;\n  for (let i = 0; i < blocks.length; i++) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = distanceBetween(i, closestReqIdx);\n  }\n  for (let i = blocks.length - 1; i >= 0; i--) {\n    if (blocks[i][req]) closestReqIdx = i;\n    minDistances[i] = Math.min(minDistances[i], distanceBetween(i, closestReqIdx));\n  }\n  return minDistances;\n}\n\nfunction getMaxDistancesAtBlocks(blocks, minDistancesFromBlocks) {\n  const maxDistancesAtBlocks = new Array(blocks.length);\n  for (let i = 0; i < blocks.length; i++) {\n    const minDistancesAtBlock = minDistancesFromBlocks.map(distances => distances[i]);\n    maxDistancesAtBlocks[i] = Math.max(...minDistancesAtBlock);\n  }\n  return maxDistancesAtBlocks;\n}\n\nfunction getIdxAtMinValue(array) {\n  let idxAtMinValue = 0;\n  let minValue = Infinity;\n  for (let i = 0; i < array.length; i++) {\n    const currentValue = array[i];\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      idxAtMinValue = i;\n    }\n  }\n  return idxAtMinValue;\n}\n\nfunction distanceBetween(a, b) {\n  return Math.abs(a - b);\n}\n\nexports.apartmentHunting = apartmentHunting;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const blocks = [\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: true,\n      school: false,\n      store: false,\n    },\n    {\n      gym: true,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: false,\n    },\n    {\n      gym: false,\n      school: true,\n      store: true,\n    },\n  ];\n  const reqs = ['gym', 'school', 'store'];\n  chai.expect(program.apartmentHunting(blocks, reqs)).to.deep.equal(3);\n});\n",
    },
    bigO: 'O(br) time | O(br) space - where b is the number of blocks and r is the number of requirements',
    tests: [
      {
        blocks: [
          { gym: false, school: true, store: false },
          { gym: true, school: false, store: false },
          { gym: true, school: true, store: false },
          { gym: false, school: true, store: false },
          { gym: false, school: true, store: true },
        ],
        reqs: ['gym', 'school', 'store'],
      },
      {
        blocks: [
          { gym: false, office: true, school: true, store: false },
          { gym: true, office: false, school: false, store: false },
          { gym: true, office: false, school: true, store: false },
          { gym: false, office: false, school: true, store: false },
          { gym: false, office: false, school: true, store: true },
        ],
        reqs: ['gym', 'office', 'school', 'store'],
      },
      {
        blocks: [
          { gym: false, office: true, school: true, store: false },
          { gym: true, office: false, school: false, store: false },
          { gym: true, office: false, school: true, store: false },
          { gym: false, office: false, school: true, store: false },
          { gym: false, office: false, school: true, store: false },
          { gym: false, office: false, school: true, store: true },
        ],
        reqs: ['gym', 'office', 'school', 'store'],
      },
      {
        blocks: [
          {
            foo: true,
            gym: false,
            kappa: false,
            office: true,
            school: true,
            store: false,
          },
          {
            foo: true,
            gym: true,
            kappa: false,
            office: false,
            school: false,
            store: false,
          },
          {
            foo: true,
            gym: true,
            kappa: false,
            office: false,
            school: true,
            store: false,
          },
          {
            foo: true,
            gym: false,
            kappa: false,
            office: false,
            school: true,
            store: false,
          },
          {
            foo: true,
            gym: true,
            kappa: false,
            office: false,
            school: true,
            store: false,
          },
          {
            foo: true,
            gym: false,
            kappa: false,
            office: false,
            school: true,
            store: true,
          },
        ],
        reqs: ['gym', 'school', 'store'],
      },
      {
        blocks: [
          { gym: true, school: true, store: false },
          { gym: false, school: false, store: false },
          { gym: false, school: true, store: false },
          { gym: false, school: false, store: false },
          { gym: false, school: false, store: true },
          { gym: true, school: false, store: false },
          { gym: false, school: false, store: false },
          { gym: false, school: false, store: false },
          { gym: false, school: false, store: false },
          { gym: false, school: true, store: false },
        ],
        reqs: ['gym', 'school', 'store'],
      },
      {
        blocks: [
          { gym: true, pool: false, school: true, store: false },
          { gym: false, pool: false, school: false, store: false },
          { gym: false, pool: false, school: true, store: false },
          { gym: false, pool: false, school: false, store: false },
          { gym: false, pool: false, school: false, store: true },
          { gym: true, pool: false, school: false, store: false },
          { gym: false, pool: false, school: false, store: false },
          { gym: false, pool: false, school: false, store: false },
          { gym: false, pool: false, school: false, store: false },
          { gym: false, pool: false, school: true, store: false },
          { gym: false, pool: true, school: false, store: false },
        ],
        reqs: ['gym', 'pool', 'school', 'store'],
      },
      {
        blocks: [
          { gym: true, office: false, pool: false, school: true, store: false },
          {
            gym: false,
            office: false,
            pool: false,
            school: false,
            store: false,
          },
          { gym: false, office: true, pool: false, school: true, store: false },
          {
            gym: false,
            office: true,
            pool: false,
            school: false,
            store: false,
          },
          {
            gym: false,
            office: false,
            pool: false,
            school: false,
            store: true,
          },
          { gym: true, office: true, pool: false, school: false, store: false },
          {
            gym: false,
            office: false,
            pool: true,
            school: false,
            store: false,
          },
          {
            gym: false,
            office: false,
            pool: false,
            school: false,
            store: false,
          },
          {
            gym: false,
            office: false,
            pool: false,
            school: false,
            store: false,
          },
          {
            gym: false,
            office: false,
            pool: false,
            school: true,
            store: false,
          },
          {
            gym: false,
            office: false,
            pool: true,
            school: false,
            store: false,
          },
        ],
        reqs: ['gym', 'pool', 'school', 'store'],
      },
    ],
  },
  {
    id: 'calendar-matching',
    name: 'Calendar Matching',
    category: 'Arrays',
    complexity: 3,
    prompt:
      "<div class=\"html\">\n<p>\n  Imagine that you want to schedule a meeting of a certain duration with a\n  co-worker. You have access to your calendar and your co-worker's calendar\n  (both of which contain your respective meetings for the day, in the form of\n  <span>[startTime, endTime]</span>), as well as both of your daily bounds\n  (i.e., the earliest and latest times at which you're available for meetings\n  every day, in the form of <span>[earliestTime, latestTime]</span>).\n</p>\n<p>\n  Write a function that takes in your calendar, your daily bounds, your\n  co-worker's calendar, your co-worker's daily bounds, and the duration of the\n  meeting that you want to schedule, and that returns a list of all the time\n  blocks (in the form of <span>[startTime, endTime]</span>) during which you\n  could schedule the meeting, ordered from earliest time block to latest.\n</p>\n<p>\n  Note that times will be given and should be returned in military time. For\n  example: <span>8:30</span>, <span>9:01</span>, and <span>23:56</span>.\n</p>\n<p>\n  Also note that the given calendar times will be sorted by start time in\n  ascending order, as you would expect them to appear in a calendar application\n  like Google Calendar.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">calendar1</span> = [['9:00', '10:30'], ['12:00', '13:00'], ['16:00', '18:00']]\n<span class=\"CodeEditor-promptParameter\">dailyBounds1</span> = ['9:00', '20:00']\n<span class=\"CodeEditor-promptParameter\">calendar2</span> = [['10:00', '11:30'], ['12:30', '14:30'], ['14:30', '15:00'], ['16:00', '17:00']]\n<span class=\"CodeEditor-promptParameter\">dailyBounds2</span> = ['10:00', '18:30']\n<span class=\"CodeEditor-promptParameter\">meetingDuration</span> = 30\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[['11:30', '12:00'], ['15:00', '16:00'], ['18:00', '18:30']]\n</pre>\n</div>",
    hints: [
      '<p>\nIn order to find blocks of time during which you and your coworker can have a meeting, you have to first find all of the unavailabilities between the two of you. An unavailability is any block of time during which at least one of you is busy.\n</p>\n',
      "\n<p>\nYou'll have to start by taking into account the daily bounds; the daily bounds can be represented by two additional meetings in each of your calendars.\n</p>\n",
      "\n<p>\nOnce you've taken the daily bounds into account, you'll want to merge the two calendars into a single calendar of meetings and then flatten that calendar in order to eliminate overlapping and back-to-back meetings. This will give you a calendar of unavailabilities, from which you can pretty easily find the list of matching availabilities.\n</p>",
    ],
    customInputVars: [
      {
        name: 'calendar1',
        example: [
          ['9:00', '10:30'],
          ['12:00', '13:00'],
          ['16:00', '18:00'],
        ],
        schema: {
          items: {
            items: { type: 'string' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
      {
        name: 'dailyBounds1',
        example: ['9:00', '20:00'],
        schema: {
          items: { type: 'string' },
          maxItems: 2,
          minItems: 2,
          type: 'array',
        },
      },
      {
        name: 'calendar2',
        example: [
          ['10:00', '11:30'],
          ['12:30', '14:30'],
          ['14:30', '15:00'],
          ['16:00', '17:00'],
        ],
        schema: {
          items: {
            items: { type: 'string' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
      {
        name: 'dailyBounds2',
        example: ['10:00', '18:30'],
        schema: {
          items: { type: 'string' },
          maxItems: 2,
          minItems: 2,
          type: 'array',
        },
      },
      {
        name: 'meetingDuration',
        example: 30,
        schema: { minimum: 1, type: 'integer' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function calendarMatching(calendar1, dailyBounds1, calendar2, dailyBounds2, meetingDuration) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.calendarMatching = calendarMatching;\n',
      solutions: [
        "// O(c1 + c2) time | O(c1 + c2) space - where c1 and c2 are the respective numbers of meetings in calendar1 and calendar2\nfunction calendarMatching(calendar1, dailyBounds1, calendar2, dailyBounds2, meetingDuration) {\n  const updatedCalendar1 = updateCalendar(calendar1, dailyBounds1);\n  const updatedCalendar2 = updateCalendar(calendar2, dailyBounds2);\n  const mergedCalendar = mergeCalendars(updatedCalendar1, updatedCalendar2);\n  const flattenedCalendar = flattenCalendar(mergedCalendar);\n  return getMatchingAvailabilities(flattenedCalendar, meetingDuration);\n}\n\nfunction updateCalendar(calendar, dailyBounds) {\n  const updatedCalendar = [['0:00', dailyBounds[0]], ...calendar, [dailyBounds[1], '23:59']];\n  return updatedCalendar.map(meeting => meeting.map(timeToMinutes));\n}\n\nfunction mergeCalendars(calendar1, calendar2) {\n  const merged = [];\n  let i = 0;\n  let j = 0;\n  while (i < calendar1.length && j < calendar2.length) {\n    const meeting1 = calendar1[i];\n    const meeting2 = calendar2[j];\n    if (meeting1[0] < meeting2[0]) {\n      merged.push(meeting1);\n      i++;\n    } else {\n      merged.push(meeting2);\n      j++;\n    }\n  }\n  while (i < calendar1.length) merged.push(calendar1[i++]);\n  while (j < calendar2.length) merged.push(calendar2[j++]);\n  return merged;\n}\n\nfunction flattenCalendar(calendar) {\n  const flattened = [calendar[0].slice()];\n  for (let i = 1; i < calendar.length; i++) {\n    const currentMeeting = calendar[i];\n    const previousMeeting = flattened[flattened.length - 1];\n    const [currentStart, currentEnd] = currentMeeting;\n    const [previousStart, previousEnd] = previousMeeting;\n    if (previousEnd >= currentStart) {\n      const newPreviousMeeting = [previousStart, Math.max(previousEnd, currentEnd)];\n      flattened[flattened.length - 1] = newPreviousMeeting;\n    } else {\n      flattened.push(currentMeeting.slice());\n    }\n  }\n  return flattened;\n}\n\nfunction getMatchingAvailabilities(calendar, meetingDuration) {\n  const matchingAvailabilities = [];\n  for (let i = 1; i < calendar.length; i++) {\n    const start = calendar[i - 1][1];\n    const end = calendar[i][0];\n    const availabilityDuration = end - start;\n    if (availabilityDuration >= meetingDuration) {\n      matchingAvailabilities.push([start, end]);\n    }\n  }\n  return matchingAvailabilities.map(meeting => meeting.map(minutesToTime));\n}\n\nfunction timeToMinutes(time) {\n  const [hours, minutes] = time.split(':').map(str => parseInt(str));\n  return hours * 60 + minutes;\n}\n\nfunction minutesToTime(minutes) {\n  const hours = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n  const hoursString = hours.toString();\n  const minutesString = mins < 10 ? '0' + mins.toString() : mins.toString();\n  return hoursString + ':' + minutesString;\n}\n\nexports.calendarMatching = calendarMatching;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const calendar1 = [\n    ['9:00', '10:30'],\n    ['12:00', '13:00'],\n    ['16:00', '18:00'],\n  ];\n  const dailyBounds1 = ['9:00', '20:00'];\n  const calendar2 = [\n    ['10:00', '11:30'],\n    ['12:30', '14:30'],\n    ['14:30', '15:00'],\n    ['16:00', '17:00'],\n  ];\n  const dailyBounds2 = ['10:00', '18:30'];\n  const meetingDuration = 30;\n  const expected = [\n    ['11:30', '12:00'],\n    ['15:00', '16:00'],\n    ['18:00', '18:30'],\n  ];\n  const result = program.calendarMatching(\n    calendar1,\n    dailyBounds1,\n    calendar2,\n    dailyBounds2,\n    meetingDuration,\n  );\n  chai.expect(result).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const calendar1 = [\n    ['9:00', '10:30'],\n    ['12:00', '13:00'],\n    ['16:00', '18:00'],\n  ];\n  const dailyBounds1 = ['9:00', '20:00'];\n  const calendar2 = [\n    ['10:00', '11:30'],\n    ['12:30', '14:30'],\n    ['14:30', '15:00'],\n    ['16:00', '17:00'],\n  ];\n  const dailyBounds2 = ['10:00', '18:30'];\n  const meetingDuration = 30;\n  const expected = [\n    ['11:30', '12:00'],\n    ['15:00', '16:00'],\n    ['18:00', '18:30'],\n  ];\n  const result = program.calendarMatching(\n    calendar1,\n    dailyBounds1,\n    calendar2,\n    dailyBounds2,\n    meetingDuration,\n  );\n  chai.expect(result).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(c1 + c2) time | O(c1 + c2) space - where c1 and c2 are the respective numbers of meetings in calendar1 and calendar2',
    tests: [
      {
        calendar1: [
          ['9:00', '10:30'],
          ['12:00', '13:00'],
          ['16:00', '18:00'],
        ],
        calendar2: [
          ['10:00', '11:30'],
          ['12:30', '14:30'],
          ['14:30', '15:00'],
          ['16:00', '17:00'],
        ],
        dailyBounds1: ['9:00', '20:00'],
        dailyBounds2: ['10:00', '18:30'],
        meetingDuration: 30,
      },
      {
        calendar1: [
          ['9:00', '10:30'],
          ['12:00', '13:00'],
          ['16:00', '18:00'],
        ],
        calendar2: [
          ['10:00', '11:30'],
          ['12:30', '14:30'],
          ['14:30', '15:00'],
          ['16:00', '17:00'],
        ],
        dailyBounds1: ['9:00', '20:00'],
        dailyBounds2: ['10:00', '18:30'],
        meetingDuration: 30,
      },
      {
        calendar1: [
          ['9:00', '10:30'],
          ['12:00', '13:00'],
          ['16:00', '18:00'],
        ],
        calendar2: [
          ['10:00', '11:30'],
          ['12:30', '14:30'],
          ['14:30', '15:00'],
          ['16:00', '17:00'],
        ],
        dailyBounds1: ['9:00', '20:00'],
        dailyBounds2: ['10:00', '18:30'],
        meetingDuration: 45,
      },
      {
        calendar1: [
          ['9:00', '10:30'],
          ['12:00', '13:00'],
          ['16:00', '18:00'],
        ],
        calendar2: [
          ['10:00', '11:30'],
          ['12:30', '14:30'],
          ['14:30', '15:00'],
          ['16:00', '17:00'],
        ],
        dailyBounds1: ['8:00', '20:00'],
        dailyBounds2: ['7:00', '18:30'],
        meetingDuration: 45,
      },
      {
        calendar1: [
          ['8:00', '10:30'],
          ['11:30', '13:00'],
          ['14:00', '16:00'],
          ['16:00', '18:00'],
        ],
        calendar2: [
          ['10:00', '11:30'],
          ['12:30', '14:30'],
          ['14:30', '15:00'],
          ['16:00', '17:00'],
        ],
        dailyBounds1: ['8:00', '18:00'],
        dailyBounds2: ['7:00', '18:30'],
        meetingDuration: 15,
      },
      {
        calendar1: [
          ['10:00', '10:30'],
          ['10:45', '11:15'],
          ['11:30', '13:00'],
          ['14:15', '16:00'],
          ['16:00', '18:00'],
        ],
        calendar2: [
          ['10:00', '11:00'],
          ['12:30', '13:30'],
          ['14:30', '15:00'],
          ['16:00', '17:00'],
        ],
        dailyBounds1: ['9:30', '20:00'],
        dailyBounds2: ['9:00', '18:30'],
        meetingDuration: 15,
      },
      {
        calendar1: [
          ['10:00', '10:30'],
          ['10:45', '11:15'],
          ['11:30', '13:00'],
          ['14:15', '16:00'],
          ['16:00', '18:00'],
        ],
        calendar2: [
          ['10:00', '11:00'],
          ['10:30', '20:30'],
        ],
        dailyBounds1: ['9:30', '20:00'],
        dailyBounds2: ['9:00', '22:30'],
        meetingDuration: 60,
      },
      {
        calendar1: [
          ['10:00', '10:30'],
          ['10:45', '11:15'],
          ['11:30', '13:00'],
          ['14:15', '16:00'],
          ['16:00', '18:00'],
        ],
        calendar2: [
          ['10:00', '11:00'],
          ['10:30', '16:30'],
        ],
        dailyBounds1: ['9:30', '20:00'],
        dailyBounds2: ['9:00', '22:30'],
        meetingDuration: 60,
      },
      {
        calendar1: [],
        calendar2: [],
        dailyBounds1: ['9:30', '20:00'],
        dailyBounds2: ['9:00', '16:30'],
        meetingDuration: 60,
      },
      {
        calendar1: [],
        calendar2: [],
        dailyBounds1: ['9:00', '16:30'],
        dailyBounds2: ['9:30', '20:00'],
        meetingDuration: 60,
      },
      {
        calendar1: [],
        calendar2: [],
        dailyBounds1: ['9:30', '16:30'],
        dailyBounds2: ['9:30', '16:30'],
        meetingDuration: 60,
      },
      {
        calendar1: [
          ['7:00', '7:45'],
          ['8:15', '8:30'],
          ['9:00', '10:30'],
          ['12:00', '14:00'],
          ['14:00', '15:00'],
          ['15:15', '15:30'],
          ['16:30', '18:30'],
          ['20:00', '21:00'],
        ],
        calendar2: [
          ['9:00', '10:00'],
          ['11:15', '11:30'],
          ['11:45', '17:00'],
          ['17:30', '19:00'],
          ['20:00', '22:15'],
        ],
        dailyBounds1: ['6:30', '22:00'],
        dailyBounds2: ['8:00', '22:30'],
        meetingDuration: 30,
      },
    ],
  },
  {
    id: 'move-element-to-end',
    name: 'Move Element To End',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an array of integers and an integer. Write a function that moves\n  all instances of that integer in the array to the end of the array and returns\n  the array.\n</p>\n<p>\n  The function should perform this in place (i.e., it should mutate the input\n  array) and doesn\'t need to maintain the order of the other integers.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 1, 2, 2, 2, 3, 4, 2]\n<span class="CodeEditor-promptParameter">toMove</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 3, 4, 2, 2, 2, 2, 2] <span class="CodeEditor-promptComment">// the numbers 1, 3, and 4 could be ordered differently</span>\n</pre>\n</div>',
    hints: [
      '<p>\nYou can solve this problem in linear time.\n</p>\n',
      '\n<p>\nIn view of Hint #1, you can solve this problem without sorting the input array. Try setting two pointers at the start and end of the array, respectively, and progressively moving them inwards.\n</p>\n',
      "\n<p>\nFollowing Hint #2, set two pointers at the start and end of the array, respectively. Move the right pointer inwards so long as it points to the integer to move, and move the left pointer inwards so long as it doesn't point to the integer to move. When both pointers aren't moving, swap their values in place. Repeat this process until the pointers pass each other.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [2, 1, 2, 2, 2, 3, 4, 2],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      { name: 'toMove', example: 2, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function moveElementToEnd(array, toMove) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.moveElementToEnd = moveElementToEnd;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the length of the array\nfunction moveElementToEnd(array, toMove) {\n  let i = 0;\n  let j = array.length - 1;\n  while (i < j) {\n    while (i < j && array[j] === toMove) j--;\n    if (array[i] === toMove) swap(i, j, array);\n    i++;\n  }\n  return array;\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.moveElementToEnd = moveElementToEnd;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [2, 1, 2, 2, 2, 3, 4, 2];\n  const toMove = 2;\n  const expectedStart = [1, 3, 4];\n  const expectedEnd = [2, 2, 2, 2, 2];\n  const output = program.moveElementToEnd(array, toMove);\n  const outputStart = sorted(output.slice(0, 3));\n  const outputEnd = output.slice(3);\n  chai.expect(outputStart).to.deep.equal(expectedStart);\n  chai.expect(outputEnd).to.deep.equal(expectedEnd);\n});\n\nconst sorted = array => array.sort((a, b) => a - b);\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [2, 1, 2, 2, 2, 3, 4, 2];\n  const toMove = 2;\n  const expectedStart = [1, 3, 4];\n  const expectedEnd = [2, 2, 2, 2, 2];\n  const output = program.moveElementToEnd(array, toMove);\n  const outputStart = sorted(output.slice(0, 3));\n  const outputEnd = output.slice(3);\n  chai.expect(outputStart).to.deep.equal(expectedStart);\n  chai.expect(outputEnd).to.deep.equal(expectedEnd);\n});\n\nconst sorted = array => array.sort((a, b) => a - b);\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the array',
    tests: [
      { array: [2, 1, 2, 2, 2, 3, 4, 2], toMove: 2 },
      { array: [], toMove: 3 },
      { array: [1, 2, 4, 5, 6], toMove: 3 },
      { array: [3, 3, 3, 3, 3], toMove: 3 },
      { array: [3, 1, 2, 4, 5], toMove: 3 },
      { array: [1, 2, 4, 5, 3], toMove: 3 },
      { array: [1, 2, 3, 4, 5], toMove: 3 },
      { array: [2, 4, 2, 5, 6, 2, 2], toMove: 2 },
      {
        array: [5, 5, 5, 5, 5, 5, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12],
        toMove: 5,
      },
      {
        array: [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 5, 5, 5, 5, 5, 5],
        toMove: 5,
      },
      {
        array: [5, 1, 2, 5, 5, 3, 4, 6, 7, 5, 8, 9, 10, 11, 5, 5, 12],
        toMove: 5,
      },
    ],
  },
  {
    id: 'monotonic-array',
    name: 'Monotonic Array',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns a boolean\n  representing whether the array is monotonic.\n</p>\n<p>\n  An array is said to be monotonic if its elements, from left to right, are\n  entirely non-increasing or entirely non-decreasing.\n</p>\n<p>\n  Non-increasing elements aren\'t necessarily exclusively decreasing; they simply\n  don\'t increase. Similarly, non-decreasing elements aren\'t necessarily\n  exclusively increasing; they simply don\'t decrease.\n</p>\n<p>Note that empty arrays and arrays of one element are monotonic.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [-1, -5, -10, -1100, -1100, -1101, -1102, -9001]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      '<p>\nYou can solve this question by iterating through the input array from left to right once.\n</p>\n',
      "\n<p>\nTry iterating through the input array from left to right, in search of two adjacent integers that can indicate whether the array is trending upward or downward. Once you've found the tentative trend of the array, at each element thereafter, compare the element to the previous one; if this comparison breaks the previously identified trend, the array isn't monotonic.\n</p>\n",
      '\n<p>\nAlternatively, you can start by assuming that the array is both entirely non-decreasing and entirely non-increasing. As you iterate through each element, perform a check to see if you can invalidate one or both of your assumptions.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [-1, -5, -10, -1100, -1100, -1101, -1102, -9001],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function isMonotonic(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.isMonotonic = isMonotonic;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the length of the array\nfunction isMonotonic(array) {\n  if (array.length <= 2) return true;\n\n  let direction = array[1] - array[0];\n  for (let i = 2; i < array.length; i++) {\n    if (direction === 0) {\n      direction = array[i] - array[i - 1];\n      continue;\n    }\n    if (breaksDirection(direction, array[i - 1], array[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction breaksDirection(direction, previousInt, currentInt) {\n  const difference = currentInt - previousInt;\n  if (direction > 0) return difference < 0;\n  return difference > 0;\n}\n\nexports.isMonotonic = isMonotonic;\n',
        '// O(n) time | O(1) space - where n is the length of the array\nfunction isMonotonic(array) {\n  let isNonDecreasing = true;\n  let isNonIncreasing = true;\n  for (let i = 1; i < array.length; i++) {\n    if (array[i] < array[i - 1]) isNonDecreasing = false;\n    if (array[i] > array[i - 1]) isNonIncreasing = false;\n  }\n\n  return isNonDecreasing || isNonIncreasing;\n}\n\nexports.isMonotonic = isMonotonic;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [-1, -5, -10, -1100, -1100, -1101, -1102, -9001];\n  const expected = true;\n  const actual = program.isMonotonic(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [-1, -5, -10, -1100, -1100, -1101, -1102, -9001];\n  const expected = true;\n  const actual = program.isMonotonic(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the array',
    tests: [
      { array: [-1, -5, -10, -1100, -1100, -1101, -1102, -9001] },
      { array: [] },
      { array: [1] },
      { array: [1, 2] },
      { array: [2, 1] },
      { array: [1, 5, 10, 1100, 1101, 1102, 9001] },
      { array: [-1, -5, -10, -1100, -1101, -1102, -9001] },
      { array: [-1, -5, -10, -1100, -900, -1101, -1102, -9001] },
      { array: [1, 2, 0] },
      { array: [1, 1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 7, 9, 10, 11] },
      { array: [1, 1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 8, 9, 10, 11] },
      { array: [-1, -1, -2, -3, -4, -5, -5, -5, -6, -7, -8, -7, -9, -10, -11] },
      { array: [-1, -1, -2, -3, -4, -5, -5, -5, -6, -7, -8, -8, -9, -10, -11] },
      { array: [-1, -1, -1, -1, -1, -1, -1, -1] },
      { array: [1, 2, -1, -2, -5] },
      { array: [-1, -5, 10] },
      { array: [2, 2, 2, 1, 4, 5] },
      { array: [1, 1, 1, 2, 3, 4, 1] },
      { array: [1, 2, 3, 3, 2, 1] },
    ],
  },
  {
    id: 'spiral-traverse',
    name: 'Spiral Traverse',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an n x m two-dimensional array (that can be\n  square-shaped when n == m) and returns a one-dimensional array of all the\n  array\'s elements in spiral order.\n</p>\n<p>\n  Spiral order starts at the top left corner of the two-dimensional array, goes\n  to the right, and proceeds in a spiral pattern all the way until every element\n  has been visited.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [\n  [1,   2,  3, 4],\n  [12, 13, 14, 5],\n  [11, 16, 15, 6],\n  [10,  9,  8, 7],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n</pre>\n</div>',
    hints: [
      '<p>\nYou can think of the spiral that you have to traverse as a set of rectangle perimeters that progressively get smaller (i.e., that progressively move inwards in the two-dimensional array).\n</p>\n',
      '\n<p>\nGoing off of Hint #1, declare four variables: a starting row, a starting column, an ending row, and an ending column. These four variables represent the bounds of the first rectangle perimeter in the spiral that you have to traverse. Traverse that perimeter using those bounds, and then move the bounds inwards. End your algorithm once the starting row passes the ending row or the starting column passes the ending column.\n</p>\n',
      '\n<p>\nYou can solve this problem both iteratively and recursively following very similar logic.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [
          [1, 2, 3, 4],
          [12, 13, 14, 5],
          [11, 16, 15, 6],
          [10, 9, 8, 7],
        ],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function spiralTraverse(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.spiralTraverse = spiralTraverse;\n',
      solutions: [
        "// O(n) time | O(n) space - where n is the total number of elements in the array\nfunction spiralTraverse(array) {\n  const result = [];\n  let startRow = 0,\n    endRow = array.length - 1;\n  let startCol = 0,\n    endCol = array[0].length - 1;\n\n  while (startRow <= endRow && startCol <= endCol) {\n    for (let col = startCol; col <= endCol; col++) {\n      result.push(array[startRow][col]);\n    }\n\n    for (let row = startRow + 1; row <= endRow; row++) {\n      result.push(array[row][endCol]);\n    }\n\n    for (let col = endCol - 1; col >= startCol; col--) {\n      // Handle the edge case when there's a single row\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this row, which\n      // we've already counted in the first for loop above.\n      // See Test Case 8 for an example of this edge case.\n      if (startRow === endRow) break;\n      result.push(array[endRow][col]);\n    }\n\n    for (let row = endRow - 1; row > startRow; row--) {\n      // Handle the edge case when there's a single column\n      // in the middle of the matrix. In this case, we don't\n      // want to double-count the values in this column, which\n      // we've already counted in the second for loop above.\n      // See Test Case 9 for an example of this edge case.\n      if (startCol === endCol) break;\n      result.push(array[row][startCol]);\n    }\n\n    startRow++;\n    endRow--;\n    startCol++;\n    endCol--;\n  }\n\n  return result;\n}\n\nexports.spiralTraverse = spiralTraverse;\n",
        "// O(n) time | O(n) space - where n is the total number of elements in the array\nfunction spiralTraverse(array) {\n  const result = [];\n  spiralFill(array, 0, array.length - 1, 0, array[0].length - 1, result);\n  return result;\n}\n\nfunction spiralFill(array, startRow, endRow, startCol, endCol, result) {\n  if (startRow > endRow || startCol > endCol) return;\n\n  for (let col = startCol; col <= endCol; col++) {\n    result.push(array[startRow][col]);\n  }\n\n  for (let row = startRow + 1; row <= endRow; row++) {\n    result.push(array[row][endCol]);\n  }\n\n  for (let col = endCol - 1; col >= startCol; col--) {\n    // Handle the edge case when there's a single row\n    // in the middle of the matrix. In this case, we don't\n    // want to double-count the values in this row, which\n    // we've already counted in the first for loop above.\n    // See Test Case 8 for an example of this edge case.\n    if (startRow === endRow) break;\n    result.push(array[endRow][col]);\n  }\n\n  for (let row = endRow - 1; row >= startRow + 1; row--) {\n    // Handle the edge case when there's a single column\n    // in the middle of the matrix. In this case, we don't\n    // want to double-count the values in this column, which\n    // we've already counted in the second for loop above.\n    // See Test Case 9 for an example of this edge case.\n    if (startCol === endCol) break;\n    result.push(array[row][startCol]);\n  }\n\n  spiralFill(array, startRow + 1, endRow - 1, startCol + 1, endCol - 1, result);\n}\n\nexports.spiralTraverse = spiralTraverse;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 2, 3, 4],\n    [12, 13, 14, 5],\n    [11, 16, 15, 6],\n    [10, 9, 8, 7],\n  ];\n  const expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n  chai.expect(program.spiralTraverse(matrix)).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 2, 3, 4],\n    [12, 13, 14, 5],\n    [11, 16, 15, 6],\n    [10, 9, 8, 7],\n  ];\n  const expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n  chai.expect(program.spiralTraverse(matrix)).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the total number of elements in the array',
    tests: [
      {
        array: [
          [1, 2, 3, 4],
          [12, 13, 14, 5],
          [11, 16, 15, 6],
          [10, 9, 8, 7],
        ],
      },
      { array: [[1]] },
      {
        array: [
          [1, 2],
          [4, 3],
        ],
      },
      {
        array: [
          [1, 2, 3],
          [8, 9, 4],
          [7, 6, 5],
        ],
      },
      {
        array: [
          [19, 32, 33, 34, 25, 8],
          [16, 15, 14, 13, 12, 11],
          [18, 31, 36, 35, 26, 9],
          [1, 2, 3, 4, 5, 6],
          [20, 21, 22, 23, 24, 7],
          [17, 30, 29, 28, 27, 10],
        ],
      },
      {
        array: [
          [4, 2, 3, 6, 7, 8, 1, 9, 5, 10],
          [12, 19, 15, 16, 20, 18, 13, 17, 11, 14],
        ],
      },
      {
        array: [
          [27, 12, 35, 26],
          [25, 21, 94, 11],
          [19, 96, 43, 56],
          [55, 36, 10, 18],
          [96, 83, 31, 94],
          [93, 11, 90, 16],
        ],
      },
      {
        array: [
          [1, 2, 3, 4],
          [10, 11, 12, 5],
          [9, 8, 7, 6],
        ],
      },
      {
        array: [
          [1, 2, 3],
          [12, 13, 4],
          [11, 14, 5],
          [10, 15, 6],
          [9, 8, 7],
        ],
      },
      {
        array: [
          [1, 11],
          [2, 12],
          [3, 13],
          [4, 14],
          [5, 15],
          [6, 16],
          [7, 17],
          [8, 18],
          [9, 19],
          [10, 20],
        ],
      },
      { array: [[1, 3, 2, 5, 4, 7, 6]] },
      { array: [[1], [3], [2], [5], [4], [7], [6]] },
    ],
  },
  {
    id: 'longest-peak',
    name: 'Longest Peak',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns the length of\n  the longest peak in the array.\n</p>\n<p>\n  A peak is defined as adjacent integers in the array that are <b>strictly</b>\n  increasing until they reach a tip (the highest value in the peak), at which\n  point they become <b>strictly</b> decreasing. At least three integers are required to\n  form a peak.\n</p>\n<p>\n  For example, the integers <span>1, 4, 10, 2</span> form a peak, but the\n  integers <span>4, 0, 10</span> don\'t and neither do the integers\n  <span>1, 2, 2, 0</span>. Similarly, the integers <span>1, 2, 3</span> don\'t\n  form a peak because there aren\'t any strictly decreasing integers after the\n  <span>3</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 2, 3, 3, 4, 0, 10, 6, 5, -1, -3, 2, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n6 <span class="CodeEditor-promptComment">// 0, 10, 6, 5, -1, -3</span>\n</pre>\n</div>',
    hints: [
      '<p>\nYou can solve this question by iterating through the array from left to right once.\n</p>\n',
      '\n<p>\nIterate through the array from left to right, and treat every integer as the potential tip of a peak. To be the tip of a peak, an integer has to be strictly greater than its adjacent integers. What can you do when you find an actual tip?\n</p>\n',
      '\n<p>\nAs you iterate through the array from left to right, whenever you find a tip of a peak, expand outwards from the tip until you no longer have a peak. Given what peaks look like and how many peaks can therefore fit in an array, realize that this process results in a linear-time algorithm. Make sure to keep track of the longest peak you find as you iterate through the array.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 2, 3, 3, 4, 0, 10, 6, 5, -1, -3, 2, 3],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function longestPeak(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestPeak = longestPeak;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction longestPeak(array) {\n  let longestPeakLength = 0;\n  let i = 1;\n  while (i < array.length - 1) {\n    const isPeak = array[i - 1] < array[i] && array[i + 1] < array[i];\n    if (!isPeak) {\n      i++;\n      continue;\n    }\n\n    let leftIdx = i - 2;\n    while (leftIdx >= 0 && array[leftIdx] < array[leftIdx + 1]) {\n      leftIdx--;\n    }\n    let rightIdx = i + 2;\n    while (rightIdx < array.length && array[rightIdx] < array[rightIdx - 1]) {\n      rightIdx++;\n    }\n\n    const currentPeakLength = rightIdx - leftIdx - 1;\n    longestPeakLength = Math.max(longestPeakLength, currentPeakLength);\n    i = rightIdx;\n  }\n  return longestPeakLength;\n}\n\nexports.longestPeak = longestPeak;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [1, 2, 3, 3, 4, 0, 10, 6, 5, -1, -3, 2, 3];\n  const expected = 6;\n  chai.expect(program.longestPeak(array)).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [1, 2, 3, 3, 4, 0, 10, 6, 5, -1, -3, 2, 3];\n  const expected = 6;\n  chai.expect(program.longestPeak(array)).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [1, 2, 3, 3, 4, 0, 10, 6, 5, -1, -3, 2, 3] },
      { array: [] },
      { array: [1, 3, 2] },
      { array: [1, 2, 3, 4, 5, 1] },
      { array: [5, 4, 3, 2, 1, 2, 1] },
      { array: [5, 4, 3, 2, 1, 2, 10, 12, -3, 5, 6, 7, 10] },
      { array: [5, 4, 3, 2, 1, 2, 10, 12] },
      { array: [1, 2, 3, 4, 5, 6, 10, 100, 1000] },
      { array: [1, 2, 3, 3, 2, 1] },
      { array: [1, 1, 3, 2, 1] },
      { array: [1, 2, 3, 2, 1, 1] },
      {
        array: [
          1, 1, 1, 2, 3, 10, 12, -3, -3, 2, 3, 45, 800, 99, 98, 0, -1, -1, 2, 3,
          4, 5, 0, -1, -1,
        ],
      },
      { array: [1, 2, 3, 3, 4, 0, 10] },
    ],
  },
  {
    id: 'validate-subsequence',
    name: 'Validate Subsequence',
    category: 'Arrays',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Given two non-empty arrays of integers, write a function that determines\n  whether the second array is a subsequence of the first one.\n</p>\n<p>\n  A subsequence of an array is a set of numbers that aren\'t necessarily adjacent\n  in the array but that are in the same order as they appear in the array. For\n  instance, the numbers <span>[1, 3, 4]</span> form a subsequence of the array\n  <span>[1, 2, 3, 4]</span>, and so do the numbers <span>[2, 4]</span>. Note\n  that a single number in an array and the array itself are both valid\n  subsequences of the array.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [5, 1, 22, 25, 6, -1, 8, 10]\n<span class="CodeEditor-promptParameter">sequence</span> = [1, 6, -1, 10]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      '<p>\nYou can solve this question by iterating through the main input array once.\n</p>\n',
      '\n<p>\nIterate through the main array, and look for the first integer in the potential subsequence. If you find that integer, keep on iterating through the main array, but now look for the second integer in the potential subsequence. Continue this process until you either find every integer in the potential subsequence or you reach the end of the main array.\n</p>\n',
      "\n<p>\nTo actually implement what Hint #2 describes, you'll have to declare a variable holding your position in the potential subsequence. At first, this position will be the 0th index in the sequence; as you find the sequence's integers in the main array, you'll increment the position variable until you reach the end of the sequence.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [5, 1, 22, 25, 6, -1, 8, 10],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
      {
        name: 'sequence',
        example: [1, 6, -1, 10],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: true,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function isValidSubsequence(array, sequence) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.isValidSubsequence = isValidSubsequence;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the length of the array\nfunction isValidSubsequence(array, sequence) {\n  let arrIdx = 0;\n  let seqIdx = 0;\n  while (arrIdx < array.length && seqIdx < sequence.length) {\n    if (array[arrIdx] === sequence[seqIdx]) seqIdx++;\n    arrIdx++;\n  }\n  return seqIdx === sequence.length;\n}\n\nexports.isValidSubsequence = isValidSubsequence;\n',
        '// O(n) time | O(1) space - where n is the length of the array\nfunction isValidSubsequence(array, sequence) {\n  let seqIdx = 0;\n  for (const value of array) {\n    if (seqIdx === sequence.length) break;\n    if (sequence[seqIdx] === value) seqIdx++;\n  }\n  return seqIdx === sequence.length;\n}\n\nexports.isValidSubsequence = isValidSubsequence;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [5, 1, 22, 25, 6, -1, 8, 10];\n  const sequence = [1, 6, -1, 10];\n  chai.expect(program.isValidSubsequence(array, sequence)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [5, 1, 22, 25, 6, -1, 8, 10];\n  const sequence = [1, 6, -1, 10];\n  chai.expect(program.isValidSubsequence(array, sequence)).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the array',
    tests: [
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [1, 6, -1, 10] },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [5, 1, 22, 25, 6, -1, 8, 10],
      },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [5, 1, 22, 6, -1, 8, 10],
      },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [22, 25, 6] },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [1, 6, 10] },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [5, 1, 22, 10] },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [5, -1, 8, 10] },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [25] },
      { array: [1, 1, 1, 1, 1], sequence: [1, 1, 1] },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [5, 1, 22, 25, 6, -1, 8, 10, 12],
      },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [4, 5, 1, 22, 25, 6, -1, 8, 10],
      },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [5, 1, 22, 23, 6, -1, 8, 10],
      },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [5, 1, 22, 22, 25, 6, -1, 8, 10],
      },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [5, 1, 22, 22, 6, -1, 8, 10],
      },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [1, 6, -1, -1] },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [1, 6, -1, -1, 10] },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [1, 6, -1, -2] },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [26] },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [5, 1, 25, 22, 6, -1, 8, 10],
      },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [5, 26, 22, 8] },
      { array: [1, 1, 6, 1], sequence: [1, 1, 1, 6] },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [1, 6, -1, 10, 11, 11, 11, 11],
      },
      {
        array: [5, 1, 22, 25, 6, -1, 8, 10],
        sequence: [5, 1, 22, 25, 6, -1, 8, 10, 10],
      },
      { array: [5, 1, 22, 25, 6, -1, 8, 10], sequence: [1, 6, -1, 5] },
    ],
  },
  {
    id: 'array-of-products',
    name: 'Array Of Products',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of integers and returns an\n  array of the same length, where each element in the output array is equal to\n  the product of every other number in the input array.\n</p>\n<p>\n  In other words, the value at <span>output[i]</span> is equal to the product of\n  every number in the input array other than <span>input[i]</span>.\n</p>\n<p>Note that you\'re expected to solve this problem without using division.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [5, 1, 4, 2]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[8, 40, 10, 20]\n<span class="CodeEditor-promptComment">// 8 is equal to 1 x 4 x 2</span>\n<span class="CodeEditor-promptComment">// 40 is equal to 5 x 4 x 2</span>\n<span class="CodeEditor-promptComment">// 10 is equal to 5 x 1 x 2</span>\n<span class="CodeEditor-promptComment">// 20 is equal to 5 x 1 x 4</span>\n</pre>\n</div>',
    hints: [
      '<p>\nThink about the most naive approach to solving this problem. How can we do exactly what the problem wants us to do without focusing at all on time and space complexity?\n</p>\n',
      '\n<p>\nUnderstand how output[i] is being calculated. How can we calculate the product of every element other than the one at the current index? Can we do this with just one loop through the input array, or do we have to do multiple loops?\n</p>\n',
      '\n<p>\nFor each index in the input array, try calculating the product of every element to the left and the product of every element to the right. You can do this with two loops through the array: one from left to right and one from right to left. How can these products help us?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [5, 1, 4, 2],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function arrayOfProducts(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.arrayOfProducts = arrayOfProducts;\n',
      solutions: [
        '// O(n^2) time | O(n) space - where n is the length of the input array\nfunction arrayOfProducts(array) {\n  const products = [];\n\n  for (let i = 0; i < array.length; i++) {\n    let runningProduct = 1;\n    for (let j = 0; j < array.length; j++) {\n      if (i !== j) {\n        runningProduct *= array[j];\n      }\n      products[i] = runningProduct;\n    }\n  }\n\n  return products;\n}\n\nexports.arrayOfProducts = arrayOfProducts;\n',
        '// O(n) time | O(n) space - where n is the length of the input array\nfunction arrayOfProducts(array) {\n  const products = new Array(array.length).fill(1);\n  const leftProducts = new Array(array.length).fill(1);\n  const rightProducts = new Array(array.length).fill(1);\n\n  let leftRunningProduct = 1;\n  for (let i = 0; i < array.length; i++) {\n    leftProducts[i] = leftRunningProduct;\n    leftRunningProduct *= array[i];\n  }\n\n  let rightRunningProduct = 1;\n  for (let i = array.length - 1; i > -1; i--) {\n    rightProducts[i] = rightRunningProduct;\n    rightRunningProduct *= array[i];\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    products[i] = leftProducts[i] * rightProducts[i];\n  }\n\n  return products;\n}\n\nexports.arrayOfProducts = arrayOfProducts;\n',
        '// O(n) time | O(n) space - where n is the length of the input array\nfunction arrayOfProducts(array) {\n  const products = new Array(array.length).fill(1);\n\n  let leftRunningProduct = 1;\n  for (let i = 0; i < array.length; i++) {\n    products[i] = leftRunningProduct;\n    leftRunningProduct *= array[i];\n  }\n\n  let rightRunningProduct = 1;\n  for (let i = array.length - 1; i > -1; i--) {\n    products[i] *= rightRunningProduct;\n    rightRunningProduct *= array[i];\n  }\n\n  return products;\n}\n\nexports.arrayOfProducts = arrayOfProducts;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [5, 1, 4, 2];\n  const expected = [8, 40, 10, 20];\n  const actual = program.arrayOfProducts(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [5, 1, 4, 2];\n  const expected = [8, 40, 10, 20];\n  const actual = program.arrayOfProducts(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input array',
    tests: [
      { array: [5, 1, 4, 2] },
      { array: [1, 8, 6, 2, 4] },
      { array: [-5, 2, -4, 14, -6] },
      { array: [9, 3, 2, 1, 9, 5, 3, 2] },
      { array: [4, 4] },
      { array: [0, 0, 0, 0] },
      { array: [1, 1, 1, 1] },
      { array: [-1, -1, -1] },
      { array: [-1, -1, -1, -1] },
      { array: [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] },
      { array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] },
    ],
  },
  {
    id: 'waterfall-streams',
    name: 'Waterfall Streams',
    category: 'Arrays',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array that represents the structure of an\n  indoor waterfall and a positive integer that represents the column that the\n  waterfall\'s water source will start at. More specifically, the water source\n  will start directly above the structure and will flow downwards.\n</p>\n<p>\n  Each row in the array contains <span>0</span>s and <span>1</span>s, where a\n  <span>0</span> represents a free space and a <span>1</span> represents a block\n  that water can\'t pass through. You can imagine that the last row of the array\n  contains buckets that the water will eventually flow into; thus, the last row\n  of the array will always contain only <span>0</span>s. You can also imagine\n  that there are walls on both sides of the structure, meaning that water will\n  never leave the structure; it will either be trapped against a wall or flow\n  into one of the buckets in the last row.\n</p>\n<p>\n  As water flows downwards, if it hits a block, it splits evenly to the left and\n  right-hand side of that block. In other words, 50% of the water flows left and\n  50% of it flows right. If a water stream is unable to flow to the left or to\n  the right (because of a block or a wall), the water stream in question becomes\n  trapped and can no longer continue to flow in that direction; it effectively\n  gets stuck in the structure and can no longer flow downwards, meaning that 50%\n  of the previous water stream is forever lost.\n</p>\n<p>\n  Lastly, the input array will always contain at least two rows and one column,\n  and the space directly below the water source (in the first row of the array)\n  will always be empty, allowing the water to start flowing downwards.\n</p>\n<p>\n  Write a function that returns the percentage of water inside each of the\n  bottom buckets after the water has flowed through the entire structure.\n</p>\n<p>\n  You can refer to the first 4.5 minutes of this question\'s video explanation\n  for a visual example.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [\n  [0, 0, 0, 0, 0, 0, 0],\n  [1, 0, 0, 0, 0, 0, 0],\n  [0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0],\n  [1, 1, 1, 0, 0, 1, 0],\n  [0, 0, 0, 0, 0, 0, 1],\n  [0, 0, 0, 0, 0, 0, 0],\n]\n<span class="CodeEditor-promptParameter">source</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[0, 0, 0, 25, 25, 0, 0]\n\n<span class="CodeEditor-promptComment">// The water will flow as follows:</span>\n<span class="CodeEditor-promptComment">// [</span>\n<span class="CodeEditor-promptComment">//   [0, 0, 0, ., 0, 0, 0],</span>\n<span class="CodeEditor-promptComment">//   [1, ., ., ., ., ., 0],</span>\n<span class="CodeEditor-promptComment">//   [0, ., 1, 1, 1, ., 0],</span>\n<span class="CodeEditor-promptComment">//   [., ., ., ., ., ., .],</span>\n<span class="CodeEditor-promptComment">//   [1, 1, 1, ., ., 1, 0],</span>\n<span class="CodeEditor-promptComment">//   [0, 0, 0, ., ., 0, 1],</span>\n<span class="CodeEditor-promptComment">//   [0, 0, 0, ., ., 0, 0],</span>\n<span class="CodeEditor-promptComment">// ]</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry not to overthink the solution to this problem. If you were to manually go through an example of water flowing downwards through the waterfall structure, what steps would you follow exactly? Can you simply transcribe these steps into code?\n</p>\n',
      '\n<p>\nTo start simple, consider how you would solve this problem if there were only two rows. How would you make water flow from the first row to the second row with your code? Can you make a slight modification to this approach in order to solve this problem for any number of rows?\n</p>\n',
      "\n<p>\nYou'll want to traverse through the input array, all the while keeping track of where and how much water flows. To do this, you'll need to represent water with some value (-1, for example, to distinguish it from the other values in the array). Iterate through the input array, row by row, column by column, specifically looking at each current row and the row above it. When you see water in the row above, you'll have to reiterate through both the row above and the current row to see where the water will flow to next (i.e., whether there are open spaces allowing the water to flow sideways and / or downwards), mutating these rows along the way whenever water does flow. You'll have the make sure to keep track of the percentage of water that's flowing whenever water gets split in half.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [
          [0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 0, 0, 1, 0],
          [0, 0, 0, 0, 0, 0, 1],
          [0, 0, 0, 0, 0, 0, 0],
        ],
        schema: {
          items: {
            items: { maximum: 1, minimum: 0, type: 'integer' },
            type: 'array',
          },
          type: 'array',
        },
      },
      { name: 'source', example: 3, schema: { minimum: 0, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function waterfallStreams(array, source) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.waterfallStreams = waterfallStreams;\n',
      solutions: [
        "// O(w^2 * h) time | O(w) space - where w and h\n// are the width and height of the input array\nfunction waterfallStreams(array, source) {\n  let rowAbove = [...array[0]];\n  // We'll use -1 to represent water, since 1 is used for a block.\n  rowAbove[source] = -1;\n\n  for (let row = 1; row < array.length; row++) {\n    const currentRow = [...array[row]];\n\n    for (let idx = 0; idx < rowAbove.length; idx++) {\n      const valueAbove = rowAbove[idx];\n\n      const hasWaterAbove = valueAbove < 0;\n      const hasBlock = currentRow[idx] === 1;\n\n      if (!hasWaterAbove) {\n        continue;\n      }\n\n      if (!hasBlock) {\n        // If there is no block in the current column, move the water down.\n        currentRow[idx] += valueAbove;\n        continue;\n      }\n\n      const splitWater = valueAbove / 2;\n\n      // Move water right\n      let rightIdx = idx;\n      while (rightIdx + 1 < rowAbove.length) {\n        rightIdx++;\n        if (rowAbove[rightIdx] === 1) {\n          // if there is a block in the way\n          break;\n        }\n        if (currentRow[rightIdx] !== 1) {\n          //if there is no block below us\n          currentRow[rightIdx] += splitWater;\n          break;\n        }\n      }\n\n      // Move water left\n      let leftIdx = idx;\n      while (leftIdx - 1 >= 0) {\n        leftIdx--;\n        if (rowAbove[leftIdx] === 1) {\n          // if there is a block in the way\n          break;\n        }\n        if (currentRow[leftIdx] !== 1) {\n          // if there is no block below us\n          currentRow[leftIdx] += splitWater;\n          break;\n        }\n      }\n    }\n    rowAbove = currentRow;\n  }\n\n  // Convert our negative values to positive percentages.\n  const finalPercentages = rowAbove.map(num => (num < 0 ? num * -100 : num));\n\n  return finalPercentages;\n}\n\nexports.waterfallStreams = waterfallStreams;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0],\n  ];\n  const source = 3;\n  const expected = [0, 0, 0, 25, 25, 0, 0];\n  const actual = program.waterfallStreams(array, source);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0],\n  ];\n  const source = 3;\n  const expected = [0, 0, 0, 25, 25, 0, 0];\n  const actual = program.waterfallStreams(array, source);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(w^2 * h) time | O(w) space - where w and h are the width and height of the input array',
    tests: [
      {
        array: [
          [0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 0, 0, 1, 0],
          [0, 0, 0, 0, 0, 0, 1],
          [0, 0, 0, 0, 0, 0, 0],
        ],
        source: 3,
      },
      { array: [[0], [0], [0], [0], [0], [0], [0]], source: 0 },
      { array: [[0], [0], [0], [0], [0], [1], [0]], source: 0 },
      {
        array: [
          [0, 0, 0, 0, 0, 0, 0],
          [1, 0, 1, 0, 1, 0, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 0, 0, 1, 0],
          [0, 0, 0, 0, 0, 0, 1],
          [0, 0, 0, 0, 0, 0, 0],
        ],
        source: 3,
      },
      {
        array: [
          [0, 0, 0, 0, 0, 0, 0],
          [1, 0, 1, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [1, 1, 1, 0, 0, 1, 0],
          [0, 0, 0, 0, 0, 0, 1],
          [0, 0, 0, 0, 0, 0, 0],
        ],
        source: 3,
      },
      {
        array: [
          [0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 1, 0, 0, 0, 1],
          [0, 0, 1, 0, 1, 1, 0],
          [0, 1, 0, 0, 0, 0, 0],
          [0, 0, 0, 1, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
        ],
        source: 3,
      },
      {
        array: [
          [0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 1, 0, 0, 0, 1],
          [0, 0, 1, 0, 1, 1, 0],
          [0, 1, 0, 0, 0, 0, 0],
          [0, 0, 0, 1, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 1],
          [0, 0, 0, 0, 0, 0, 0],
        ],
        source: 6,
      },
      {
        array: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ],
        source: 8,
      },
      {
        array: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ],
        source: 8,
      },
    ],
  },
  {
    id: 'first-duplicate-value',
    name: 'First Duplicate Value',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Given an array of integers between <span>1</span> and <span>n</span>,\n  inclusive, where <span>n</span> is the length of the array, write a function\n  that returns the first integer that appears more than once (when the array is\n  read from left to right).\n</p>\n<p>\n  In other words, out of all the integers that might occur more than once in the\n  input array, your function should return the one whose first duplicate value\n  has the minimum index.\n</p>\n<p>\n  If no integer appears more than once, your function should return\n  <span>-1</span>.\n</p>\n<p>Note that you\'re allowed to mutate the input array.</p>\n<h3>Sample Input #1</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 1, 5, 2, 3, 3, 4]\n</pre>\n<h3>Sample Output #1</h3>\n<pre>\n2 <span class="CodeEditor-promptComment">// 2 is the first integer that appears more than once.</span>\n<span class="CodeEditor-promptComment">// 3 also appears more than once, but the second 3 appears after the second 2.</span>\n</pre>\n<h3>Sample Input #2</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [2, 1, 5, 3, 3, 2, 4]\n</pre>\n<h3>Sample Output #2</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// 3 is the first integer that appears more than once.</span>\n<span class="CodeEditor-promptComment">// 2 also appears more than once, but the second 2 appears after the second 3.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nThe brute-force solution can be done in O(n^2) time. Think about how you can determine if a value appears twice in an array.\n</p>\n',
      "\n<p>\nYou can use a data structure that has constant-time lookups to keep track of integers that you've seen already. This leads the way to a linear-time solution.\n</p>\n",
      "\n<p>\nYou should always pay close attention to the details of a question's prompt. In this question, the integers in the array are between 1 and n, inclusive, where n is the length of the input array. The prompt also explicitly allows us to mutate the array. How can these details help us find a better solution, either time-complexity-wise or space-complexity-wise? \n</p>\n",
      "\n<p>\nSince the integers are between 1 and the length of the input array, you can map them to indices in the array itself by subtracting 1 from them. Once you've mapped an integer to an index in the array, you can mutate the value in the array at that index and make it negative (by multiplying it by -1). Since the integers normally aren't negative, the first time that you encounter a negative value at the index that an integer maps to, you'll know that you'll have already seen that integer.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [2, 1, 5, 2, 3, 3, 4],
        schema: { items: { minimum: 1, type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function firstDuplicateValue(array) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.firstDuplicateValue = firstDuplicateValue;\n',
      solutions: [
        '// O(n^2) time | O(1) space - where n is the length of the input array\nfunction firstDuplicateValue(array) {\n  let minimumSecondIndex = array.length;\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    for (let j = i + 1; j < array.length; j++) {\n      const valueToCompare = array[j];\n      if (value === valueToCompare) {\n        minimumSecondIndex = Math.min(minimumSecondIndex, j);\n      }\n    }\n  }\n\n  if (minimumSecondIndex === array.length) return -1;\n\n  return array[minimumSecondIndex];\n}\n\n// Do not edit the line below.\nexports.firstDuplicateValue = firstDuplicateValue;\n',
        '// O(n) time | O(n) space - where n is the length of the input array\nfunction firstDuplicateValue(array) {\n  const seen = new Set();\n  for (const value of array) {\n    if (seen.has(value)) return value;\n    seen.add(value);\n  }\n  return -1;\n}\n\n// Do not edit the line below.\nexports.firstDuplicateValue = firstDuplicateValue;\n',
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction firstDuplicateValue(array) {\n  for (const value of array) {\n    const absValue = Math.abs(value);\n    if (array[absValue - 1] < 0) return absValue;\n    array[absValue - 1] *= -1;\n  }\n  return -1;\n}\n\n// Do not edit the line below.\nexports.firstDuplicateValue = firstDuplicateValue;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 1, 5, 2, 3, 3, 4];\n  const expected = 2;\n  const actual = program.firstDuplicateValue(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [2, 1, 5, 2, 3, 3, 4];\n  const expected = 2;\n  const actual = program.firstDuplicateValue(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [2, 1, 5, 2, 3, 3, 4] },
      { array: [2, 1, 5, 3, 3, 2, 4] },
      { array: [1, 1, 2, 3, 3, 2, 2] },
      { array: [3, 1, 3, 1, 1, 4, 4] },
      { array: [] },
      { array: [1] },
      { array: [1, 1] },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10] },
      { array: [2, 1, 1] },
      { array: [2, 2, 2, 2, 2, 2, 2, 2, 2] },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] },
      { array: [7, 6, 5, 3, 6, 4, 3, 5, 2] },
      { array: [9, 13, 6, 2, 3, 5, 5, 5, 3, 2, 2, 2, 2, 4, 3] },
      {
        array: [
          23, 21, 22, 5, 3, 13, 11, 16, 5, 11, 9, 14, 23, 3, 2, 2, 5, 11, 6, 11,
          23, 8, 1,
        ],
      },
      {
        array: [
          8, 20, 4, 12, 14, 9, 19, 17, 14, 20, 22, 9, 6, 15, 1, 15, 10, 9, 17,
          7, 22, 17,
        ],
      },
      { array: [3, 3, 2] },
      { array: [6, 6, 5, 1, 3, 7, 7, 8] },
      {
        array: [
          23, 25, 9, 26, 2, 19, 24, 18, 25, 17, 13, 3, 14, 17, 9, 20, 26, 15,
          21, 2, 6, 11, 2, 12, 23, 5, 4, 20,
        ],
      },
      {
        array: [
          12, 22, 6, 18, 5, 17, 18, 22, 22, 4, 6, 14, 12, 8, 5, 6, 10, 7, 13,
          22, 17, 18,
        ],
      },
      {
        array: [
          16, 6, 6, 18, 6, 13, 28, 9, 3, 26, 10, 2, 23, 5, 20, 21, 11, 20, 6,
          11, 26, 20, 26, 25, 13, 3, 12, 4,
        ],
      },
      {
        array: [
          15, 2, 6, 3, 3, 22, 14, 16, 6, 21, 4, 16, 2, 17, 9, 13, 1, 3, 5, 6, 1,
          2, 23, 16, 16,
        ],
      },
      { array: [4, 7, 9, 7, 1, 3, 2, 3, 1, 12, 12, 5] },
      {
        array: [
          9, 21, 9, 22, 3, 23, 4, 26, 7, 11, 25, 25, 19, 13, 23, 28, 5, 23, 19,
          13, 10, 26, 28, 9, 28, 16, 7, 13, 22,
        ],
      },
      {
        array: [
          29, 3, 23, 16, 1, 22, 21, 14, 15, 21, 12, 27, 9, 12, 11, 3, 22, 5, 21,
          24, 14, 26, 11, 5, 21, 25, 15, 19, 13, 4,
        ],
      },
      { array: [13, 2, 8, 8, 10, 11, 13, 11, 9, 13, 4, 5, 7] },
      {
        array: [
          4, 7, 7, 14, 14, 10, 15, 14, 14, 16, 14, 11, 5, 12, 17, 7, 1, 6, 13,
        ],
      },
      { array: [2, 5, 1, 4, 1] },
      { array: [11, 10, 5, 3, 1, 7, 10, 6, 10, 11, 7] },
      { array: [2, 13, 3, 9, 1, 9, 1, 11, 11, 5, 3, 1, 9, 12] },
      { array: [3, 3, 1, 1] },
      {
        array: [
          26, 18, 21, 26, 26, 16, 16, 3, 19, 9, 10, 24, 21, 9, 8, 11, 17, 21,
          18, 22, 17, 27, 6, 7, 6, 10, 4,
        ],
      },
      {
        array: [
          27, 16, 15, 21, 10, 21, 3, 21, 5, 12, 27, 24, 20, 26, 5, 13, 26, 22,
          26, 8, 23, 10, 14, 17, 7, 5, 3,
        ],
      },
      {
        array: [
          11, 6, 1, 1, 4, 19, 10, 12, 19, 8, 12, 15, 26, 9, 6, 20, 17, 12, 26,
          15, 25, 18, 26, 5, 3, 5, 16, 5,
        ],
      },
      {
        array: [
          16, 22, 20, 22, 26, 19, 8, 17, 18, 24, 17, 19, 19, 11, 18, 13, 10, 20,
          6, 23, 20, 19, 21, 6, 17, 7,
        ],
      },
      { array: [11, 13, 6, 12, 4, 15, 4, 9, 3, 10, 5, 8, 15, 5, 8] },
      { array: [7, 9, 5, 6, 4, 11, 2, 8, 2, 5, 1] },
      { array: [8, 1, 5, 2, 9, 12, 9, 6, 9, 9, 5, 13, 5, 9] },
      { array: [11, 5, 2, 7, 11, 11, 3, 11, 4, 2, 9] },
      {
        array: [
          2, 22, 3, 20, 18, 8, 29, 25, 7, 12, 12, 17, 1, 28, 3, 6, 11, 2, 28,
          16, 23, 27, 8, 28, 4, 29, 24, 12, 29,
        ],
      },
      { array: [5, 1, 3, 5, 1] },
      {
        array: [
          20, 12, 3, 18, 9, 16, 4, 18, 6, 19, 14, 23, 10, 13, 6, 1, 22, 11, 11,
          16, 13, 15, 17, 19, 14, 12, 20,
        ],
      },
      {
        array: [
          23, 15, 11, 5, 13, 11, 9, 9, 13, 8, 22, 12, 2, 24, 6, 2, 15, 24, 12,
          9, 13, 13, 22, 18,
        ],
      },
      { array: [4, 1, 5, 1, 4] },
      {
        array: [
          7, 14, 4, 6, 17, 17, 3, 14, 1, 16, 18, 4, 12, 13, 8, 19, 1, 2, 4, 14,
        ],
      },
      { array: [5, 6, 6, 4, 3, 5] },
      { array: [3, 2, 3, 1] },
      { array: [9, 12, 14, 6, 14, 2, 4, 9, 13, 2, 10, 5, 7, 1] },
      {
        array: [
          9, 2, 11, 5, 6, 8, 10, 15, 5, 7, 11, 6, 19, 19, 14, 15, 3, 9, 16,
        ],
      },
      { array: [2, 6, 1, 7, 1, 6, 6] },
      { array: [6, 3, 1, 8, 2, 2, 1, 7, 10, 8, 6, 4] },
      {
        array: [
          21, 17, 1, 8, 22, 8, 22, 8, 23, 3, 21, 5, 18, 2, 8, 21, 21, 22, 10,
          24, 13, 4, 20, 24,
        ],
      },
      {
        array: [
          16, 9, 13, 10, 18, 17, 11, 5, 11, 4, 2, 16, 15, 6, 3, 7, 15, 10, 1,
        ],
      },
      { array: [5, 5, 5, 4, 6, 6, 2] },
      { array: [5, 3, 8, 2, 9, 6, 8, 1, 6] },
      { array: [5, 5, 1, 5, 3, 7, 4, 4] },
      {
        array: [
          19, 4, 1, 6, 2, 5, 20, 13, 8, 6, 11, 12, 12, 12, 11, 18, 7, 13, 6, 10,
        ],
      },
      { array: [3, 11, 11, 10, 11, 8, 8, 11, 10, 11, 10, 8, 10] },
      { array: [15, 3, 15, 6, 13, 3, 12, 10, 17, 8, 13, 1, 12, 9, 14, 7, 16] },
      { array: [2, 2, 2] },
      { array: [11, 6, 8, 8, 8, 9, 10, 6, 4, 1, 10, 1, 6] },
      { array: [2, 3, 16, 9, 11, 14, 13, 1, 10, 12, 5, 17, 4, 16, 10, 5, 4] },
      { array: [13, 4, 10, 10, 8, 13, 13, 7, 11, 6, 3, 2, 11] },
      { array: [6, 15, 7, 10, 9, 14, 10, 1, 10, 1, 2, 11, 1, 6, 8] },
    ],
  },
  {
    id: 'sorted-squared-array',
    name: 'Sorted Squared Array',
    category: 'Arrays',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of integers that are sorted\n  in ascending order and returns a new array of the same length with the squares\n  of the original integers also sorted in ascending order.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 2, 3, 5, 6, 8, 9]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 4, 9, 25, 36, 64, 81]\n</pre>\n</div>',
    hints: [
      "<p>\n  While the integers in the input array are sorted in increasing order, their\n  squares won't necessarily be as well, because of the possible presence of\n  negative numbers.\n</p>\n",
      '\n<p>\n  Traverse the array value by value, square each value, and insert the squares\n  into an output array. Then, sort the output array before returning it. Is this\n  the optimal solution?\n</p>\n',
      '\n<p>\n  To reduce the time complexity of the algorithm mentioned in Hint #2, you need\n  to avoid sorting the ouput array. To do this, as you square the values of the\n  input array, try to directly insert them into their correct position in the\n  output array.\n</p>\n',
      '\n<p>\n  Use two pointers to keep track of the smallest and largest values in the input\n  array. Compare the absolute values of these smallest and largest values,\n  square the larger absolute value, and place the square at the end of the\n  output array, filling it up from right to left. Move the pointers accordingly,\n  and repeat this process until the output array is filled.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 2, 3, 5, 6, 8, 9],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function sortedSquaredArray(array) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.sortedSquaredArray = sortedSquaredArray;\n',
      solutions: [
        '// O(nlogn) time | O(n) space - where n is the length of the input array\nfunction sortedSquaredArray(array) {\n  const sortedSquares = new Array(array.length).fill(0);\n\n  for (let idx = 0; idx < array.length; idx++) {\n    const value = array[idx];\n    sortedSquares[idx] = value * value;\n  }\n\n  sortedSquares.sort((a, b) => a - b);\n  return sortedSquares;\n}\n\n// Do not edit the line below.\nexports.sortedSquaredArray = sortedSquaredArray;\n',
        '// O(n) time | O(n) space - where n is the length of the input array\nfunction sortedSquaredArray(array) {\n  const sortedSquares = new Array(array.length).fill(0);\n  let smallerValueIdx = 0;\n  let largerValueIdx = array.length - 1;\n\n  for (let idx = array.length - 1; idx >= 0; idx--) {\n    const smallerValue = array[smallerValueIdx];\n    const largerValue = array[largerValueIdx];\n\n    if (Math.abs(smallerValue) > Math.abs(largerValue)) {\n      sortedSquares[idx] = smallerValue * smallerValue;\n      smallerValueIdx++;\n    } else {\n      sortedSquares[idx] = largerValue * largerValue;\n      largerValueIdx--;\n    }\n  }\n\n  return sortedSquares;\n}\n\n// Do not edit the line below.\nexports.sortedSquaredArray = sortedSquaredArray;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [1, 2, 3, 5, 6, 8, 9];\n  const expected = [1, 4, 9, 25, 36, 64, 81];\n  const actual = program.sortedSquaredArray(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [1, 2, 3, 5, 6, 8, 9];\n  const expected = [1, 4, 9, 25, 36, 64, 81];\n  const actual = program.sortedSquaredArray(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the input array',
    tests: [
      { array: [1, 2, 3, 5, 6, 8, 9] },
      { array: [1] },
      { array: [1, 2] },
      { array: [1, 2, 3, 4, 5] },
      { array: [0] },
      { array: [10] },
      { array: [-1] },
      { array: [-2, -1] },
      { array: [-5, -4, -3, -2, -1] },
      { array: [-10] },
      { array: [-10, -5, 0, 5, 10] },
      { array: [-7, -3, 1, 9, 22, 30] },
      { array: [-50, -13, -2, -1, 0, 0, 1, 1, 2, 3, 19, 20] },
      { array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] },
      { array: [-1, -1, 2, 3, 3, 3, 4] },
      { array: [-3, -2, -1] },
      { array: [-3, -2, -1] },
    ],
  },
  {
    id: 'minimum-area-rectangle',
    name: 'Minimum Area Rectangle',
    category: 'Arrays',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an array of points plotted on a 2D graph (the xy-plane). Write a\n  function that returns the minimum area of any rectangle that can be formed\n  using any 4 of these points such that the rectangle\'s sides are parallel to\n  the x and y axes (i.e., only rectangles with horizontal and vertical sides\n  should be considered--no rectangles with diagonal sides). If no rectangle can\n  be formed, your function should return <span>0</span>.\n</p>\n<p>\n  The input array will contain points represented by arrays of two integers\n  <span>[x, y]</span>. The input array will never contain duplicate points.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">points</span> = \n[\n  [1, 5],\n  [5, 1],\n  [4, 2],\n  [2, 4],\n  [2, 2],\n  [1, 2],\n  [4, 5],\n  [2, 5],\n  [-1, -2],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3\n<span class="CodeEditor-promptComment">// The rectangle with corners [1, 5], [2, 5], [1, 2], and [2, 2]</span>\n<span class="CodeEditor-promptComment">// has the minimum area: 3.</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  The brute-force approach to this problem is to simply generate all possible\n  combinations of 4 points and to see if they form a rectangle. You can\n  calculate the area of all of these rectangles and then return the minimum area\n  that you find. Is there a better approach than this?\n</p>\n',
      '\n<p>\n  A more optimal approach is to find vertical or horizontal edges that are\n  parallel to the y or x axes, respectively. If you find two parallel edges (two\n  vertical edges, for example) that share a vertical or horizontal coordinate (y\n  values in the case of vertical edges), then those edges form a rectangle.\n</p>\n',
      "\n<p>\n  Another approach is to pick any two points that don't have the same x or y\n  values (i.e., points that could be at opposite ends of a rectangle diagonal)\n  and to see if you can create a rectangle with them and two other points. Given\n  two points where <span>p1 = (x1, y1)</span> and <span>p2 = (x2, y2)</span>, if\n  points <span>p3 = (x1, y2)</span> and <span>p4 = (x2, y1)</span> exist, then\n  these 4 points form a rectangle.\n</p>",
    ],
    customInputVars: [
      {
        name: 'points',
        example: [
          [1, 5],
          [5, 1],
          [4, 2],
          [2, 4],
          [2, 2],
          [1, 2],
          [4, 5],
          [2, 5],
          [-1, -2],
        ],
        schema: {
          items: {
            items: { type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function minimumAreaRectangle(points) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.minimumAreaRectangle = minimumAreaRectangle;\n',
      solutions: [
        "// O(n^2) time | O(n) space - where n is the number of points\nfunction minimumAreaRectangle(points) {\n  const columns = initializeColumns(points);\n  let minimumAreaFound = Infinity;\n  const edgesParallelToYAxis = {};\n\n  const sortedColumns = Object.keys(columns)\n    .map(col => parseInt(col))\n    .sort((a, b) => a - b);\n  for (const x of sortedColumns) {\n    const yValuesInCurrentColumn = columns[x].sort((a, b) => a - b);\n\n    for (let currentIdx = 0; currentIdx < yValuesInCurrentColumn.length; currentIdx++) {\n      const y2 = yValuesInCurrentColumn[currentIdx];\n      for (let previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n        const y1 = yValuesInCurrentColumn[previousIdx];\n        const pointString = y1.toString() + ':' + y2.toString();\n\n        if (pointString in edgesParallelToYAxis) {\n          const currentArea = (x - edgesParallelToYAxis[pointString]) * (y2 - y1);\n          minimumAreaFound = Math.min(minimumAreaFound, currentArea);\n        }\n\n        edgesParallelToYAxis[pointString] = x;\n      }\n    }\n  }\n\n  return minimumAreaFound !== Infinity ? minimumAreaFound : 0;\n}\n\nfunction initializeColumns(points) {\n  const columns = {};\n\n  for (const point of points) {\n    const [x, y] = point;\n    if (!columns[x]) {\n      columns[x] = [];\n    }\n    columns[x].push(y);\n  }\n\n  return columns;\n}\n\n// Do not edit the line below.\nexports.minimumAreaRectangle = minimumAreaRectangle;\n",
        "// O(n^2) time | O(n) space - where n is the number of points\nfunction minimumAreaRectangle(points) {\n  const pointSet = createPointSet(points);\n  let minimumAreaFound = Infinity;\n\n  for (let currentIdx = 0; currentIdx < points.length; currentIdx++) {\n    const [p2x, p2y] = points[currentIdx];\n    for (let previousIdx = 0; previousIdx < currentIdx; previousIdx++) {\n      const [p1x, p1y] = points[previousIdx];\n      const pointsShareValue = p1x === p2x || p1y === p2y;\n\n      if (pointsShareValue) continue;\n\n      // If (p1x, p2y) and (p2x, p1y), exist we've found a rectangle.\n      const point1OnOppositeDiagonalExists = pointSet.has(convertPointToString(p1x, p2y));\n      const point2OnOppositeDiagonalExists = pointSet.has(convertPointToString(p2x, p1y));\n      const oppositeDiagonalExists =\n        point1OnOppositeDiagonalExists && point2OnOppositeDiagonalExists;\n\n      if (oppositeDiagonalExists) {\n        const currentArea = Math.abs(p2x - p1x) * Math.abs(p2y - p1y);\n        minimumAreaFound = Math.min(minimumAreaFound, currentArea);\n      }\n    }\n  }\n\n  return minimumAreaFound !== Infinity ? minimumAreaFound : 0;\n}\n\nfunction createPointSet(points) {\n  const pointSet = new Set();\n\n  for (const point of points) {\n    const [x, y] = point;\n    const pointString = convertPointToString(x, y);\n    pointSet.add(pointString);\n  }\n\n  return pointSet;\n}\n\nfunction convertPointToString(x, y) {\n  return x.toString() + ':' + y.toString();\n}\n\n// Do not edit the line below.\nexports.minimumAreaRectangle = minimumAreaRectangle;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 5],\n    [5, 1],\n    [4, 2],\n    [2, 4],\n    [2, 2],\n    [1, 2],\n    [4, 5],\n    [2, 5],\n    [-1, -2],\n  ];\n  const expected = 3;\n  const actual = program.minimumAreaRectangle(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 5],\n    [5, 1],\n    [4, 2],\n    [2, 4],\n    [2, 2],\n    [1, 2],\n    [4, 5],\n    [2, 5],\n    [-1, -2],\n  ];\n  const expected = 3;\n  const actual = program.minimumAreaRectangle(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the number of points',
    tests: [
      {
        points: [
          [1, 5],
          [5, 1],
          [4, 2],
          [2, 4],
          [2, 2],
          [1, 2],
          [4, 5],
          [2, 5],
          [-1, -2],
        ],
      },
      {
        points: [
          [-4, 4],
          [4, 4],
          [4, -2],
          [-4, -2],
          [0, -2],
          [4, 2],
          [0, 2],
        ],
      },
      {
        points: [
          [-4, 4],
          [4, 4],
          [4, -2],
          [-4, -2],
          [0, -2],
          [4, 2],
          [0, 2],
          [0, 4],
          [2, 3],
          [0, 3],
          [2, 4],
        ],
      },
      {
        points: [
          [0, 0],
          [4, 4],
          [8, 8],
          [0, 8],
        ],
      },
      {
        points: [
          [0, 0],
          [4, 4],
          [8, 8],
          [0, 8],
          [0, 4],
          [6, 0],
          [6, 4],
        ],
      },
      {
        points: [
          [0, 0],
          [4, 4],
          [8, 8],
          [0, 8],
          [0, 4],
          [6, 0],
          [6, 4],
          [8, 0],
          [8, 4],
          [6, 2],
          [2, 4],
          [2, 0],
        ],
      },
      {
        points: [
          [0, 0],
          [1, 1],
          [2, 2],
          [-1, -1],
          [-2, -2],
          [-1, 1],
          [-2, 2],
          [1, -1],
          [2, -2],
        ],
      },
      {
        points: [
          [0, 1],
          [0, 0],
          [2, 1],
          [2, 0],
          [4, 0],
          [4, 1],
          [0, 2],
          [2, 2],
          [4, 2],
          [6, 0],
          [6, 1],
          [6, 2],
          [7, 1],
          [7, 0],
        ],
      },
      {
        points: [
          [0, 1],
          [0, 0],
          [2, 1],
          [2, 0],
          [4, 0],
          [4, 1],
          [0, 2],
          [2, 2],
          [4, 2],
          [6, 0],
          [6, 1],
          [6, 2],
          [7, 1],
        ],
      },
      {
        points: [
          [100, 100],
          [76, 67],
          [-100, 100],
          [65, 76],
          [100, -100],
          [3, 4],
          [-100, -100],
          [5, 6],
          [78, 54],
          [-87, 7],
          [1, 4],
          [4, 1],
          [-1, 5],
        ],
      },
      { points: [] },
      {
        points: [
          [1, 2],
          [4, 2],
        ],
      },
      {
        points: [
          [2, 2],
          [3, 2],
          [4, 2],
        ],
      },
    ],
  },
  {
    id: 'merge-overlapping-intervals',
    name: 'Merge Overlapping Intervals',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of arbitrary intervals,\n  merges any overlapping intervals, and returns the new intervals in no\n  particular order.\n</p>\n<p>\n  Each interval <span>interval</span> is an array of two integers, with\n  <span>interval[0]</span> as the start of the interval and\n  <span>interval[1]</span> as the end of the interval.\n</p>\n<p>\n  Note that back-to-back intervals aren\'t considered to be overlapping. For\n  example, <span>[1, 5]</span> and <span>[6, 7]</span> aren\'t overlapping;\n  however, <span>[1, 6]</span> and <span>[6, 7]</span> <i>are</i> indeed\n  overlapping.\n</p>\n<p>\n  Also note that the start of any particular interval will always be less than\n  or equal to the end of that interval.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">intervals</span> = [[1, 2], [3, 5], [4, 7], [6, 8], [9, 10]]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[1, 2], [3, 8], [9, 10]]\n<span class="CodeEditor-promptComment">// Merge the intervals [3, 5], [4, 7], and [6, 8].</span>\n<span class="CodeEditor-promptComment">// The intervals could be ordered differently.</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  The problem asks you to merge overlapping intervals. How can you determine if\n  two intervals are overlapping?\n</p>\n',
      '\n<p>\n  Sort the intervals with respect to their starting values. This will allow you\n  to merge all overlapping intervals in a single traversal through the sorted\n  intervals.\n</p>\n',
      '\n<p>\n  After sorting the intervals with respect to their starting values, traverse\n  them, and at each iteration, compare the start of the next interval to the end\n  of the current interval to look for an overlap. If you find an overlap, mutate\n  the current interval so as to merge the next interval into it.\n</p>',
    ],
    customInputVars: [
      {
        name: 'intervals',
        example: [
          [1, 2],
          [3, 5],
          [4, 7],
          [6, 8],
          [9, 10],
        ],
        schema: {
          items: {
            items: { type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function mergeOverlappingIntervals(array) {\n  // Write your code here.\n  return [[]];\n}\n\n// Do not edit the line below.\nexports.mergeOverlappingIntervals = mergeOverlappingIntervals;\n',
      solutions: [
        '// O(nlog(n)) time | O(n) space - where n is the length of the input array\nfunction mergeOverlappingIntervals(intervals) {\n  const sortedIntervals = intervals.sort((a, b) => a[0] - b[0]);\n\n  const mergedIntervals = [];\n  let currentInterval = sortedIntervals[0];\n  mergedIntervals.push(currentInterval);\n\n  for (const nextInterval of sortedIntervals) {\n    const [_, currentIntervalEnd] = currentInterval;\n    const [nextIntervalStart, nextIntervalEnd] = nextInterval;\n\n    if (currentIntervalEnd >= nextIntervalStart)\n      currentInterval[1] = Math.max(currentIntervalEnd, nextIntervalEnd);\n    else {\n      currentInterval = nextInterval;\n      mergedIntervals.push(currentInterval);\n    }\n  }\n\n  return mergedIntervals;\n}\n\n// Do not edit the line below.\nexports.mergeOverlappingIntervals = mergeOverlappingIntervals;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const intervals = [\n    [1, 2],\n    [3, 5],\n    [4, 7],\n    [6, 8],\n    [9, 10],\n  ];\n  const expected = [\n    [1, 2],\n    [3, 8],\n    [9, 10],\n  ];\n  const actual = program.mergeOverlappingIntervals(intervals);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const intervals = [\n    [1, 2],\n    [3, 5],\n    [4, 7],\n    [6, 8],\n    [9, 10],\n  ];\n  const expected = [\n    [1, 2],\n    [3, 8],\n    [9, 10],\n  ];\n  const actual = program.mergeOverlappingIntervals(intervals);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlog(n)) time | O(n) space - where n is the length of the input array',
    tests: [
      {
        intervals: [
          [1, 2],
          [3, 5],
          [4, 7],
          [6, 8],
          [9, 10],
        ],
      },
      {
        intervals: [
          [1, 3],
          [2, 8],
          [9, 10],
        ],
      },
      {
        intervals: [
          [1, 10],
          [10, 20],
          [20, 30],
          [30, 40],
          [40, 50],
          [50, 60],
          [60, 70],
          [70, 80],
          [80, 90],
          [90, 100],
        ],
      },
      {
        intervals: [
          [1, 10],
          [11, 20],
          [21, 30],
          [31, 40],
          [41, 50],
          [51, 60],
          [61, 70],
          [71, 80],
          [81, 90],
          [91, 100],
        ],
      },
      {
        intervals: [
          [100, 105],
          [1, 104],
        ],
      },
      {
        intervals: [
          [89, 90],
          [-10, 20],
          [-50, 0],
          [70, 90],
          [90, 91],
          [90, 95],
        ],
      },
      {
        intervals: [
          [-5, -4],
          [-4, -3],
          [-3, -2],
          [-2, -1],
          [-1, 0],
        ],
      },
      {
        intervals: [
          [43, 49],
          [9, 12],
          [12, 54],
          [45, 90],
          [91, 93],
        ],
      },
      {
        intervals: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0],
        ],
      },
      {
        intervals: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 1],
        ],
      },
      {
        intervals: [
          [1, 22],
          [-20, 30],
        ],
      },
      {
        intervals: [
          [20, 21],
          [22, 23],
          [0, 1],
          [3, 4],
          [23, 24],
          [25, 27],
          [5, 6],
          [7, 19],
        ],
      },
      {
        intervals: [
          [2, 3],
          [4, 5],
          [6, 7],
          [8, 9],
          [1, 10],
        ],
      },
    ],
  },
  {
    id: 'tournament-winner',
    name: 'Tournament Winner',
    category: 'Arrays',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  There\'s an algorithms tournament taking place in which teams of programmers\n  compete against each other to solve algorithmic problems as fast as possible.\n  Teams compete in a round robin, where each team faces off against all other\n  teams. Only two teams compete against each other at a time, and for each\n  competition, one team is designated the home team, while the other team is the\n  away team. In each competition there\'s always one winner and one loser; there\n  are no ties. A team receives 3 points if it wins and 0 points if it loses. The\n  winner of the tournament is the team that receives the most amount of points.\n</p>\n<p>\n  Given an array of pairs representing the teams that have competed against each\n  other and an array containing the results of each competition, write a\n  function that returns the winner of the tournament. The input arrays are named\n  <span>competitions</span> and <span>results</span>, respectively. The\n  <span>competitions</span> array has elements in the form of\n  <span>[homeTeam, awayTeam]</span>, where each team is a string of at most 30\n  characters representing the name of the team. The <span>results</span> array\n  contains information about the winner of each corresponding competition in the\n  <span>competitions</span> array. Specifically, <span>results[i]</span> denotes\n  the winner of <span>competitions[i]</span>, where a <span>1</span> in the\n  <span>results</span> array means that the home team in the corresponding\n  competition won and a <span>0</span> means that the away team won.\n</p>\n<p>\n  It\'s guaranteed that exactly one team will win the tournament and that each\n  team will compete against all other teams exactly once. It\'s also guaranteed\n  that the tournament will always have at least two teams.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">competitions</span> = [\n  ["HTML", "C#"],\n  ["C#", "Python"],\n  ["Python", "HTML"],\n]\n<span class="CodeEditor-promptParameter">results</span> = [0, 0, 1]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n"Python"\n<span class="CodeEditor-promptComment">// C# beats HTML, Python Beats C#, and Python Beats HTML.</span>\n<span class="CodeEditor-promptComment">// HTML - 0 points </span>\n<span class="CodeEditor-promptComment">// C# -  3 points</span>\n<span class="CodeEditor-promptComment">// Python -  6 points</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  Don't overcomplicate this problem. How would you solve it by hand? Consider\n  that approach, and try to translate it into code.\n</p>\n",
      '\n<p>\n  Use a hash table to store the total points collected by each team, with the\n  team names as keys in the hash table. Once you know how many points each team\n  has, how can you determine which one is the winner?\n</p>\n',
      "\n<p>\n  Loop through all of the competitions, and update the hash table at every\n  iteration. For each competition, consider the name of the winning team; if the\n  name already exists in the hash table, update that entry by adding 3 points to\n  it. If the team name doesn't exist in the hash table, add a new entry in the\n  hash table with the key as the team name and the value as 3 (since the team\n  won its first competition). While looping through all of the competitions,\n  keep track of the team with the highest score, and at the end of the\n  algorithm, return the team with the highest score.\n</p>",
    ],
    customInputVars: [
      {
        name: 'competitions',
        example: [
          ['HTML', 'C#'],
          ['C#', 'Python'],
          ['Python', 'HTML'],
        ],
        schema: {
          items: {
            items: { type: 'string' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          minItems: 1,
          type: 'array',
        },
      },
      {
        name: 'results',
        example: [0, 0, 1],
        schema: {
          items: { maximum: 1, minimum: 0, type: 'integer' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        "function tournamentWinner(competitions, results) {\n  // Write your code here.\n  return '';\n}\n\n// Do not edit the line below.\nexports.tournamentWinner = tournamentWinner;\n",
      solutions: [
        "const HOME_TEAM_WON = 1;\n\n// O(n) time | O(k) space - where n is the number\n// of competitions and k is the number of teams\nfunction tournamentWinner(competitions, results) {\n  let currentBestTeam = '';\n  const scores = {[currentBestTeam]: 0};\n\n  for (let idx = 0; idx < competitions.length; idx++) {\n    const result = results[idx];\n    const [homeTeam, awayTeam] = competitions[idx];\n\n    const winningTeam = result === HOME_TEAM_WON ? homeTeam : awayTeam;\n\n    updateScores(winningTeam, 3, scores);\n\n    if (scores[winningTeam] > scores[currentBestTeam]) {\n      currentBestTeam = winningTeam;\n    }\n  }\n\n  return currentBestTeam;\n}\n\nfunction updateScores(team, points, scores) {\n  if (!(team in scores)) scores[team] = 0;\n\n  scores[team] += points;\n}\n\n// Do not edit the line below.\nexports.tournamentWinner = tournamentWinner;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const competitions = [\n    ['HTML', 'C#'],\n    ['C#', 'Python'],\n    ['Python', 'HTML'],\n  ];\n  const results = [0, 0, 1];\n  const expected = 'Python';\n  const actual = program.tournamentWinner(competitions, results);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const competitions = [\n    ['HTML', 'C#'],\n    ['C#', 'Python'],\n    ['Python', 'HTML'],\n  ];\n  const results = [0, 0, 1];\n  const expected = 'Python';\n  const actual = program.tournamentWinner(competitions, results);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(k) space - where n is the number of competitions and k is the number of teams',
    tests: [
      {
        competitions: [
          ['HTML', 'C#'],
          ['C#', 'Python'],
          ['Python', 'HTML'],
        ],
        results: [0, 0, 1],
      },
      {
        competitions: [
          ['HTML', 'Java'],
          ['Java', 'Python'],
          ['Python', 'HTML'],
        ],
        results: [0, 1, 1],
      },
      {
        competitions: [
          ['HTML', 'Java'],
          ['Java', 'Python'],
          ['Python', 'HTML'],
          ['C#', 'Python'],
          ['Java', 'C#'],
          ['C#', 'HTML'],
        ],
        results: [0, 1, 1, 1, 0, 1],
      },
      {
        competitions: [
          ['HTML', 'Java'],
          ['Java', 'Python'],
          ['Python', 'HTML'],
          ['C#', 'Python'],
          ['Java', 'C#'],
          ['C#', 'HTML'],
          ['SQL', 'C#'],
          ['HTML', 'SQL'],
          ['SQL', 'Python'],
          ['SQL', 'Java'],
        ],
        results: [0, 1, 1, 1, 0, 1, 0, 1, 1, 0],
      },
      { competitions: [['Bulls', 'Eagles']], results: [1] },
      {
        competitions: [
          ['Bulls', 'Eagles'],
          ['Bulls', 'Bears'],
          ['Bears', 'Eagles'],
        ],
        results: [0, 0, 0],
      },
      {
        competitions: [
          ['Bulls', 'Eagles'],
          ['Bulls', 'Bears'],
          ['Bulls', 'Monkeys'],
          ['Eagles', 'Bears'],
          ['Eagles', 'Monkeys'],
          ['Bears', 'Monkeys'],
        ],
        results: [1, 1, 1, 1, 1, 1],
      },
      {
        competitions: [
          ['AlgoMasters', 'FrontPage Freebirds'],
          ['Runtime Terror', 'Static Startup'],
          ['WeC#', 'Hypertext Assassins'],
          ['AlgoMasters', 'WeC#'],
          ['Static Startup', 'Hypertext Assassins'],
          ['Runtime Terror', 'FrontPage Freebirds'],
          ['AlgoMasters', 'Runtime Terror'],
          ['Hypertext Assassins', 'FrontPage Freebirds'],
          ['Static Startup', 'WeC#'],
          ['AlgoMasters', 'Static Startup'],
          ['FrontPage Freebirds', 'WeC#'],
          ['Hypertext Assassins', 'Runtime Terror'],
          ['AlgoMasters', 'Hypertext Assassins'],
          ['WeC#', 'Runtime Terror'],
          ['FrontPage Freebirds', 'Static Startup'],
        ],
        results: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0],
      },
      {
        competitions: [
          ['HTML', 'Java'],
          ['Java', 'Python'],
          ['Python', 'HTML'],
          ['C#', 'Python'],
          ['Java', 'C#'],
          ['C#', 'HTML'],
          ['SQL', 'C#'],
          ['HTML', 'SQL'],
          ['SQL', 'Python'],
          ['SQL', 'Java'],
        ],
        results: [0, 0, 0, 0, 0, 0, 1, 0, 1, 1],
      },
      { competitions: [['A', 'B']], results: [0] },
    ],
  },
  {
    id: 'non-constructible-change',
    name: 'Non-Constructible Change',
    category: 'Arrays',
    complexity: 0,
    prompt:
      "<div class=\"html\">\n<p>\n  Given an array of positive integers representing the values of coins in your\n  possession, write a function that returns the minimum amount of change (the\n  minimum sum of money) that you <b>cannot</b> create. The given coins can have\n  any positive integer value and aren't necessarily unique (i.e., you can have\n  multiple coins of the same value).\n</p>\n<p>\n  For example, if you're given <span>coins = [1, 2, 5]</span>, the minimum\n  amount of change that you can't create is <span>4</span>. If you're given no\n  coins, the minimum amount of change that you can't create is <span>1</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">coins</span> = [5, 7, 1, 1, 2, 3, 22]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n20\n</pre>\n</div>",
    hints: [
      "<p>\n  One approach to solve this problem is to attempt to create every single amount\n  of change, starting at 1 and going up until you eventually can't create an\n  amount. While this approach works, there <i>is</i> a better one.\n</p>\n",
      "\n<p>\n  Start by sorting the input array. Since you're trying to find the\n  <b>minimum</b> amount of change that you can't create, it makes sense to\n  consider the smallest coins first.\n</p>\n",
      '\n<p>\n  To understand the trick to this problem, consider the following example:\n  <span>coins = [1, 2, 4]</span>. With this set of coins, we can create\n  <span>1, 2, 3, 4, 5, 6, 7</span> cents worth of change. Now, if we were to add\n  a coin of value <span>9</span> to this set, we <b>would not</b> be able to\n  create <span>8</span> cents. However, if we were to add a coin of value\n  <span>7</span>, we <b>would</b> be able to create <span>8</span> cents, and we\n  would also be able to create all values of change from <span>1</span> to\n  <span>15</span>. Why is this the case?\n</p>\n',
      "\n<p>\n  Create a variable to store the amount of change that you can currently create\n  up to. Sort all of your coins, and loop through them in ascending order. At\n  every iteration, compare the current coin to the amount of change that you can\n  currently create up to. Here are the two scenarios that you'll encounter:\n</p>\n<ul>\n  <li>\n    The coin value is <b>greater</b> than the amount of change that you can\n    currently create plus 1.\n  </li>\n  <li>\n    The coin value is <b>smaller than or equal to</b> the amount of change that\n    you can currently create plus 1.\n  </li>\n</ul>\n<p>\n  In the first scenario, you simply return the current amount of change that you\n  can create plus 1, because you can't create that amount of change. In the\n  second scenario, you add the value of the coin to the amount of change that\n  you can currently create up to, and you continue iterating through the coins.\n</p>\n<p>\n  The reason for this is that, if you're in the second scenario, you can create\n  all of the values of change that you can currently create plus the value of\n  the coin that you just considered. If you're given coins <span>[1, 2]</span>,\n  then you can make <span>1, 2, 3</span> cents. So if you add a coin of value\n  <span>4</span>, then you can make <span>4 + 1</span> cents,\n  <span>4 + 2</span> cents, and <span>4 + 3</span> cents. Thus, you can make up\n  to <span>7</span> cents.\n</p>",
    ],
    customInputVars: [
      {
        name: 'coins',
        example: [5, 7, 1, 1, 2, 3, 22],
        schema: { items: { minimum: 1, type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function nonConstructibleChange(coins) {\n  // Write your code here.\n  return 1;\n}\n\n// Do not edit the line below.\nexports.nonConstructibleChange = nonConstructibleChange;\n',
      solutions: [
        '// O(nlogn) time | O(1) space - where n is the number of coins\nfunction nonConstructibleChange(coins) {\n  coins.sort((a, b) => a - b);\n\n  let currentChangeCreated = 0;\n  for (const coin of coins) {\n    if (coin > currentChangeCreated + 1) return currentChangeCreated + 1;\n\n    currentChangeCreated += coin;\n  }\n\n  return currentChangeCreated + 1;\n}\n\n// Do not edit the line below.\nexports.nonConstructibleChange = nonConstructibleChange;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [5, 7, 1, 1, 2, 3, 22];\n  const expected = 20;\n  const actual = program.nonConstructibleChange(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [5, 7, 1, 1, 2, 3, 22];\n  const expected = 20;\n  const actual = program.nonConstructibleChange(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlogn) time | O(1) space - where n is the number of coins',
    tests: [
      { coins: [5, 7, 1, 1, 2, 3, 22] },
      { coins: [1, 1, 1, 1, 1] },
      { coins: [1, 5, 1, 1, 1, 10, 15, 20, 100] },
      { coins: [6, 4, 5, 1, 1, 8, 9] },
      { coins: [] },
      { coins: [87] },
      { coins: [5, 6, 1, 1, 2, 3, 4, 9] },
      { coins: [5, 6, 1, 1, 2, 3, 43] },
      { coins: [1, 1] },
      { coins: [2] },
      { coins: [1] },
      { coins: [109, 2000, 8765, 19, 18, 17, 16, 8, 1, 1, 2, 4] },
      { coins: [1, 2, 3, 4, 5, 6, 7] },
    ],
  },
  {
    id: 'best-seat',
    name: 'Best Seat',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You walk into a theatre you\'re about to see a show in. The usher within the\n  theatre walks you to your row and mentions you\'re allowed to sit anywhere\n  within the given row. Naturally you\'d like to sit in the seat that gives you\n  the most space. You also would prefer this space to be evenly distributed on\n  either side of you (e.g. if there are three empty seats in a row, you would\n  prefer to sit in the middle of those three seats).\n</p>\n<p>\n  Given the theatre row represented as an integer array, return\n  the seat index of where you should sit. Ones represent occupied seats and zeroes\n  represent empty seats.\n</p>\n<p>\n  You may assume that someone is always sitting in the\n  first and last seat of the row. Whenever there are two equally good seats,\n  you should sit in the seat with the lower index. If there is no seat to sit\n  in, return -1. The given array will always have a length of at least one\n  and contain only ones and zeroes.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">seats</span> = [1, 0, 1, 0, 0, 0, 1]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4\n</pre>\n</div>',
    hints: [
      '<p>\n  Try thinking about this problem in real life. How would you determine what\n  seat has the most space?\n</p>\n',
      '\n<p>\n  The best seat will always be within the longest contiguous subarray of all\n  zeros.\n</p>\n',
      '\n<p>Once you find the longest contiguous subarray of empty seats, how can\nyou choose where to sit within that subarray?</p>\n',
      '\n<p>How can you find the midpoint between two people?</p>',
    ],
    customInputVars: [
      {
        name: 'seats',
        example: [1],
        schema: {
          items: { maximum: 1, minimum: 0, type: 'integer' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function bestSeat(seats) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.bestSeat = bestSeat;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the number of seats\nfunction bestSeat(seats) {\n  let bestSeat = -1;\n  let maxSpace = 0;\n\n  let left = 0;\n  while (left < seats.length) {\n    let right = left + 1;\n    while (right < seats.length && seats[right] === 0) {\n      right += 1;\n    }\n\n    const availableSpace = right - left - 1;\n    if (availableSpace > maxSpace) {\n      bestSeat = Math.floor((left + right) / 2);\n      maxSpace = availableSpace;\n    }\n    left = right;\n  }\n\n  return bestSeat;\n}\n\n// Do not edit the line below.\nexports.bestSeat = bestSeat;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [1, 0, 1, 0, 0, 0, 1];\n  const expected = 4;\n  const actual = program.bestSeat(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [1, 0, 1, 0, 0, 0, 1];\n  const expected = 4;\n  const actual = program.bestSeat(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of seats',
    tests: [
      { seats: [1] },
      { seats: [1, 0, 1, 0, 0, 0, 1] },
      { seats: [1, 0, 1] },
      { seats: [1, 0, 0, 1] },
      { seats: [1, 1, 1] },
      { seats: [1, 0, 0, 1, 0, 0, 1] },
      { seats: [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1] },
      { seats: [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1] },
      { seats: [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1] },
      { seats: [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] },
      {
        seats: [
          1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
          0, 0, 0, 1,
        ],
      },
      { seats: [1, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
      { seats: [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1] },
      { seats: [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1] },
    ],
  },
  {
    id: 'longest-subarray-with-sum',
    name: 'Longest Subarray With Sum',
    category: 'Arrays',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of non-negative integers and a non-negative integer\n  representing a target sum. The function should find the longest subarray where the values collectively\n  sum up to equal the target sum. Return an array containing the starting index and ending index of this subarray,\n  both inclusive.\n</p>\n<p>\n  If there is no subarray that sums up to the target sum, the function should return an\n  empty array. You can assume that the given inputs will only ever have one answer.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 2, 3, 4, 3, 3, 1, 2, 1, 2]\n<span class="CodeEditor-promptParameter">targetSum</span> = 10\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[4, 8] <span class="CodeEditor-promptComment"> // The longest subarray that sums to 10 starts at index 4 and ends at index 8\n</span>\n</pre>\n</div>',
    hints: [
      '<p>\nUsing intuition you can develop a brute force approach. If you are trying to find the longest\nsubarray that sums to equal the target sum, then look at every possible subarray. Calculate\nthe sum of each subarray, and when the sum is equal to the target sum, check the length against\nthe current maximum.\n</p>\n',
      '\n<p>\nSince the array contains only non-negative numbers, once a subarray sum is\ngreater than the target sum, there is no possible way adding more numbers to\nthat subarray will get its sum to equal the target sum. Can you use this\ninformation to optimize the solution?\n</p>\n',
      '\n<p>\nLooking at every possible subarray is very time consuming. However, you can use\na sliding window approach to improve the time complexity. Think about how a sliding window might\nwork in this case. You should look at different subarrays while you traverse the array. How might\nyou update a sliding window if you are looking for subarrays with a sum that is equal to the\ntarget sum?\n</p>\n',
      '\n<p>\nAdd elements to the sliding window when the current subarray sum is less than the target sum,\nand remove elements when the current subarray sum is greater than the target sum. When you find\na current subarray sum in the sliding window that is equal to the target sum, then you can check and see\nif you found a new longest subarray. If that is the case then update the result, otherwise\ncontinue traversing.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 2, 3, 4, 3, 3, 1, 2, 1],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
      {
        name: 'targetSum',
        example: 10,
        schema: { minimum: 0, type: 'integer' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function longestSubarrayWithSum(array, targetSum) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.longestSubarrayWithSum = longestSubarrayWithSum;\n',
      solutions: [
        '// O(n^2) time | O(1) space - where n is the length of the input array\nfunction longestSubarrayWithSum(array, targetSum) {\n  let indices = [];\n\n  for (let startingIndex = 0; startingIndex < array.length; startingIndex++) {\n    let currentSubarraySum = 0;\n\n    for (let endingIndex = startingIndex; endingIndex < array.length; endingIndex++) {\n      currentSubarraySum += array[endingIndex];\n\n      if (currentSubarraySum === targetSum) {\n        if (indices.length === 0 || indices[1] - indices[0] < endingIndex - startingIndex) {\n          indices = [startingIndex, endingIndex];\n        }\n      }\n    }\n  }\n\n  return indices;\n}\n\n// Do not edit the line below.\nexports.longestSubarrayWithSum = longestSubarrayWithSum;\n',
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction longestSubarrayWithSum(array, targetSum) {\n  let indices = [];\n\n  let currentSubarraySum = 0;\n  let startingIndex = 0;\n  let endingIndex = 0;\n\n  while (endingIndex < array.length) {\n    currentSubarraySum += array[endingIndex];\n    while (startingIndex < endingIndex && currentSubarraySum > targetSum) {\n      currentSubarraySum -= array[startingIndex];\n      startingIndex += 1;\n    }\n\n    if (currentSubarraySum === targetSum) {\n      if (indices.length === 0 || indices[1] - indices[0] < endingIndex - startingIndex) {\n        indices = [startingIndex, endingIndex];\n      }\n    }\n\n    endingIndex += 1;\n  }\n\n  return indices;\n}\n\n// Do not edit the line below.\nexports.longestSubarrayWithSum = longestSubarrayWithSum;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [1, 2, 3, 4, 3, 3, 1, 2, 1];\n  const targetSum = 10;\n  const expected = [4, 8];\n  const actual = program.longestSubarrayWithSum(array, targetSum);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [1, 2, 3, 4, 3, 3, 1, 2, 1];\n  const targetSum = 10;\n  const expected = [4, 8];\n  const actual = program.longestSubarrayWithSum(array, targetSum);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [1, 2, 3, 4, 3, 3, 1, 2, 1], targetSum: 10 },
      { array: [1, 2, 3, 4, 0, 0, 0, 0, 0, 3, 3, 1, 2, 1], targetSum: 10 },
      { array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], targetSum: 1 },
      { array: [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], targetSum: 1 },
      { array: [25, 25, 25, 25, 100, 0, 0, 0, 0, 0, 0, 0], targetSum: 100 },
      { array: [1, 2, 3, 4, 5, 5, 5, 5], targetSum: 15 },
      {
        array: [
          0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 1, 1, 0, 1, 0, 1, 0, 0, 0,
          1,
        ],
        targetSum: 20,
      },
      { array: [1, 2, 3, 4, 5, 0, 0, 0, 6, 7, 8, 9, 10], targetSum: 15 },
      { array: [61, 54, 1, 499, 2212, 4059, 1, 2, 3, 1, 3], targetSum: 19 },
      { array: [0], targetSum: 0 },
      { array: [10], targetSum: 10 },
      { array: [5], targetSum: 0 },
      { array: [5], targetSum: 10 },
      { array: [0, 1, 0, 1], targetSum: 3 },
      { array: [0, 0, 0, 0, 39, 0, 0, 0, 0, 0, 28, 10], targetSum: 39 },
      {
        array: [1, 4, 10, 15, 31, 7, 1, 40, 0, 20, 1, 1, 1, 1, 2, 1],
        targetSum: 68,
      },
      {
        array: [1, 4, 10, 15, 31, 7, 1, 40, 0, 20, 1, 1, 1, 1, 2, 1],
        targetSum: 0,
      },
      {
        array: [1, 4, 10, 15, 31, 7, 1, 40, 5, 20, 1, 1, 1, 1, 2, 1],
        targetSum: 0,
      },
      { array: [1, 2, 3, 4, 5], targetSum: 0 },
    ],
  },
  {
    id: 'line-through-points',
    name: 'Line Through Points',
    category: 'Arrays',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an array of points plotted on a 2D graph (the xy-plane). Write a\n  function that returns the maximum number of points that a single line (or\n  potentially multiple lines) on the graph passes through.\n</p>\n<p>\n  The input array will contain points represented by an array of two integers\n  <span>[x, y]</span>. The input array will never contain duplicate points and\n  will always contain at least one point.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">points</span> = [\n  [1, 1],\n  [2, 2],\n  [3, 3],\n  [0, 4],\n  [-2, 6],\n  [4, 0],\n  [2, 1],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 <span class="CodeEditor-promptComment">// A line passes through points: [-2, 6], [0, 4], [2, 2], [4, 0].</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  The brute-force approach to solve this problem is to consider every single\n  pair of points and to form a line using them. Then, for each line, you\n  determine how many points lie on that line by using the equation of the line\n  you formed and checking if each point's coordinates solve the equation. This\n  solution runs in <span>O(n^3)</span> time; can you come up with a better\n  approach?\n</p>\n",
      '\n<p>What does it mean if two lines have the same slope and share a point?</p>\n',
      "\n<p>\n  If two lines have the same slope and share a point, they're the same line. Try\n  using a hash table to store the slopes of lines that pass through certain\n  points. How does this help you write an algorithm that runs in\n  <span>O(n^2)</span> time?\n</p>\n",
      "\n<p>\n  Loop through every single pair of points, picking a <span>p2</span> for every\n  <span>p1</span> in order to form a line. For every pair <span>(p1, p2)</span>,\n  store the slope of the formed line in a hash table, and map it to the number\n  of points on that line. If you ever find two identical slopes for lines that\n  both use the same point <span>p1</span>, you can consider these lines to be\n  one and the same, meaning that points <span>p1, p2a, and p2b</span> are all on\n  the same line; in those cases, update the number of points on the slope (the\n  line) in the hash table accordingly. You'll need to reset the hash table at\n  each change of <span>p1</span>. See the Conceptual Overview section of this\n  question's video explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'points',
        example: [
          [1, 1],
          [2, 2],
          [3, 3],
          [0, 4],
          [-2, 6],
          [4, 0],
          [2, 1],
        ],
        schema: {
          items: {
            items: { type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function lineThroughPoints(points) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.lineThroughPoints = lineThroughPoints;\n',
      solutions: [
        "// O(n^2) time | O(n) space - where n is the number of points\nfunction lineThroughPoints(points) {\n  let maxNumberOfPointsOnLine = 1;\n\n  for (let idx1 = 0; idx1 < points.length; idx1++) {\n    const p1 = points[idx1];\n    const slopes = {};\n    for (let idx2 = idx1 + 1; idx2 < points.length; idx2++) {\n      const p2 = points[idx2];\n      const [rise, run] = getSlopeOfLineBetweenPoints(p1, p2);\n      const slopeKey = createHashableKeyForRational(rise, run);\n      if (!(slopeKey in slopes)) slopes[slopeKey] = 1;\n\n      slopes[slopeKey]++;\n    }\n\n    const currentMaxNumberOfPointsOnLine = Object.values(slopes).reduce(\n      (a, b) => Math.max(a, b),\n      0,\n    );\n    maxNumberOfPointsOnLine = Math.max(maxNumberOfPointsOnLine, currentMaxNumberOfPointsOnLine);\n  }\n\n  return maxNumberOfPointsOnLine;\n}\n\nfunction getSlopeOfLineBetweenPoints(p1, p2) {\n  const [p1x, p1y] = p1;\n  const [p2x, p2y] = p2;\n  let slope = [1, 0]; // slope of a vertical lines\n\n  if (p1x !== p2x) {\n    // if line is not vertical\n    let xDiff = p1x - p2x;\n    let yDiff = p1y - p2y;\n    let gcd = getGreatestCommonDivisor(Math.abs(xDiff), Math.abs(yDiff));\n    xDiff = Math.floor(xDiff / gcd);\n    yDiff = Math.floor(yDiff / gcd);\n    if (xDiff < 0) {\n      xDiff *= -1;\n      yDiff *= -1;\n    }\n\n    slope = [yDiff, xDiff];\n  }\n\n  return slope;\n}\n\nfunction createHashableKeyForRational(numerator, denominator) {\n  return numerator.toString() + ':' + denominator.toString();\n}\n\nfunction getGreatestCommonDivisor(num1, num2) {\n  let a = num1;\n  let b = num2;\n  while (true) {\n    if (a === 0) return b;\n    if (b === 0) return a;\n\n    const tempA = a;\n    a = b;\n    b = tempA % b;\n  }\n}\n\n// Do not edit the line below.\nexports.lineThroughPoints = lineThroughPoints;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [2, 2],\n    [3, 3],\n    [0, 4],\n    [-2, 6],\n    [4, 0],\n    [2, 1],\n  ];\n  const expected = 4;\n  const actual = program.lineThroughPoints(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [2, 2],\n    [3, 3],\n    [0, 4],\n    [-2, 6],\n    [4, 0],\n    [2, 1],\n  ];\n  const expected = 4;\n  const actual = program.lineThroughPoints(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the number of points',
    tests: [
      {
        points: [
          [1, 1],
          [2, 2],
          [3, 3],
          [0, 4],
          [-2, 6],
          [4, 0],
          [2, 1],
        ],
      },
      {
        points: [
          [3, 3],
          [0, 4],
          [-2, 6],
          [4, 0],
          [2, 1],
          [3, 4],
          [5, 6],
          [0, 0],
        ],
      },
      {
        points: [
          [1, 4],
          [3, 5],
          [7, 1],
          [5, 4],
          [4, 5],
          [9, 2],
          [1, 3],
          [2, 8],
        ],
      },
      {
        points: [
          [1, 4],
          [4, 1],
          [3, 3],
        ],
      },
      { points: [[0, 0]] },
      {
        points: [
          [1, 4],
          [4, 1],
          [1, 1],
          [4, 4],
          [2, 3],
          [3, 2],
          [3, 3],
          [2, 2],
          [0, 3],
        ],
      },
      {
        points: [
          [1, 4],
          [4, 1],
          [1, 1],
          [4, 4],
          [2, 3],
          [3, 2],
          [3, 3],
          [2, 2],
          [0, 3],
          [5, 3],
          [3, -1],
          [2, -3],
          [1, -5],
        ],
      },
      {
        points: [
          [-1, -1],
          [-3, -1],
          [-4, -1],
          [1, 1],
          [4, 1],
        ],
      },
      {
        points: [
          [1, 1],
          [1, 2],
          [1, 3],
          [1, 4],
          [1, 5],
          [2, 1],
          [2, 2],
          [2, 3],
          [2, 4],
          [2, 5],
          [3, 1],
          [3, 2],
          [3, 4],
          [3, 5],
          [4, 1],
          [4, 2],
          [4, 3],
          [4, 4],
          [4, 5],
          [5, 1],
          [5, 2],
          [5, 3],
          [5, 4],
          [5, 5],
          [6, 6],
          [2, 6],
        ],
      },
      {
        points: [
          [1, 1],
          [1, 2],
          [1, 3],
          [1, 4],
          [1, 5],
          [2, 1],
          [2, 2],
          [2, 4],
          [2, 5],
          [4, 1],
          [4, 2],
          [4, 4],
          [4, 5],
          [5, 1],
          [5, 2],
          [5, 4],
          [5, 5],
          [6, 6],
          [2, 6],
          [-1, -1],
          [0, 0],
          [-2, -2],
        ],
      },
      {
        points: [
          [-78, -9],
          [67, 87],
          [46, 87],
          [4, 5],
          [9, 83],
          [34, 47],
        ],
      },
      {
        points: [
          [1000000001, 1],
          [1, 1],
          [0, 0],
        ],
      },
    ],
  },
  {
    id: "kadane's-algorithm",
    name: "Kadane's Algorithm",
    category: 'Famous Algorithms',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of integers and returns the\n  maximum sum that can be obtained by summing up all of the integers in a\n  non-empty subarray of the input array. A subarray must only contain adjacent\n  numbers (numbers next to each other in the input array).\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n19 <span class="CodeEditor-promptComment">// [1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1]</span>\n</pre>\n</div>',
    hints: [
      "<p>\nThis problem seems fairly simple until you run into negative numbers, some of which are so big in absolute value that they essentially break an otherwise good subarray into two subarrays, and some of which are small enough that there exists a subarray containing them whose numbers sum to maximum sum that you're looking for. How can you determine which group a negative number belongs to?\n</p>\n",
      '\n<p>\nRealize that at any given index in the input array, the maximum sum for a subarray ending at that index is either the maximum sum for a subarray ending at the previous index plus the number at that index, or just the number at that index. Thus, for each index in the array, you can calculate the maximum sum of a subarray ending at that index, and this can be done in one simple pass through the input array.\n</p>\n',
      '\n<p>\nHow can you alter the pass through the input array mentioned in Hint #2 so as to obtain the actual answer to the problem, that is the maximum sum of any subarray in the input array? You should be able to accomplish everything in one loop through the input array.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function kadanesAlgorithm(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.kadanesAlgorithm = kadanesAlgorithm;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction kadanesAlgorithm(array) {\n  let maxEndingHere = array[0];\n  let maxSoFar = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const num = array[i];\n    maxEndingHere = Math.max(num, maxEndingHere + num);\n    maxSoFar = Math.max(maxSoFar, maxEndingHere);\n  }\n  return maxSoFar;\n}\n\nexports.kadanesAlgorithm = kadanesAlgorithm;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.kadanesAlgorithm([3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4]))\n    .to.deep.equal(19);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.kadanesAlgorithm([3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4]))\n    .to.deep.equal(19);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [3, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4] },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] },
      { array: [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10] },
      { array: [-10, -2, -9, -4, -8, -6, -7, -1, -3, -5] },
      { array: [1, 2, 3, 4, 5, 6, -20, 7, 8, 9, 10] },
      { array: [1, 2, 3, 4, 5, 6, -22, 7, 8, 9, 10] },
      { array: [1, 2, -4, 3, 5, -9, 8, 1, 2] },
      { array: [3, 4, -6, 7, 8] },
      { array: [3, 4, -6, 7, 8, -18, 100] },
      { array: [3, 4, -6, 7, 8, -15, 100] },
      { array: [8, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 4] },
      { array: [8, 5, -9, 1, 3, -2, 3, 4, 7, 2, -9, 6, 3, 1, -5, 6] },
      { array: [8, 5, -9, 1, 3, -2, 3, 4, 7, 2, -18, 6, 3, 1, -5, 6] },
      {
        array: [
          8, 5, -9, 1, 3, -2, 3, 4, 7, 2, -18, 6, 3, 1, -5, 6, 20, -23, 15, 1,
          -3, 4,
        ],
      },
      {
        array: [
          100, 8, 5, -9, 1, 3, -2, 3, 4, 7, 2, -18, 6, 3, 1, -5, 6, 20, -23, 15,
          1, -3, 4,
        ],
      },
      { array: [-1000, -1000, 2, 4, -5, -6, -7, -8, -2, -100] },
      { array: [-2, -1] },
      { array: [-2, 1] },
      { array: [-10] },
    ],
  },
  {
    id: 'knuth-morris-pratt-algorithm',
    name: 'KnuthMorrisPratt Algorithm',
    category: 'Famous Algorithms',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in two strings and checks if the first string\n  contains the second one using the KnuthMorrisPratt algorithm. The function\n  should return a boolean.\n</p>\n<p>\n  If you\'re unfamiliar with the KnuthMorrisPratt Algorithm, we recommend\n  watching the Conceptual Overview section of this question\'s video explanation\n  before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "aefoaefcdaefcdaed"\n<span class="CodeEditor-promptParameter">substring</span> = "aefcdaed"\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      '<p>\nThe KnuthMorrisPratt algorithm works by identifying patterns in the potential substring and exploiting them to avoid doing needless character comparisons when searching for the substring in the main string. For instance, take the string "ababac" and the substring "abac"; comparing these strings will fail at the fourth character, where "b" is not equal to "c". Instead of having to restart our comparisons at the second character of the main string, however, we notice that the substring "ab", which is at the beginning of our potential substring, just appeared near our point of failure in the main string. How can we use this to our advantage?\n</p>\n',
      '\n<p>\nStart by traversing the potential substring and building out a pattern table. This 1-dimensional array should store, for every position in the substring, the last index at which a matching pattern has been seen; more specifically, this index should be the ending index of a prefix in the substring that is also a suffix at the given position. For example, the string "abcababcd" should yield the following pattern table: [-1, -1, -1, 0, 1, 0, 1, 2, -1].\n</p>\n',
      "\n<p>\nAfter the pattern table mentioned in Hint #2 has been built, traverse the main string and the potential substring with two separate pointers. When characters match, move the pointers forward. When characters don't match, check if the pointer in the substring is at the very beginning of the substring; if it is, then there is no match and you can move the pointer of the main string forward until there is a match; if it isn't, then move it to the position that comes right after the last seen pattern stored at the previous index in the pattern table.\n</p>",
    ],
    customInputVars: [
      {
        name: 'string',
        example: 'aefoaefcdaefcdaed',
        schema: { type: 'string' },
      },
      { name: 'substring', example: 'aefcdaed', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function knuthMorrisPrattAlgorithm(string, substring) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.knuthMorrisPrattAlgorithm = knuthMorrisPrattAlgorithm;\n',
      solutions: [
        '// O(n + m) time | O(m) space\nfunction knuthMorrisPrattAlgorithm(string, substring) {\n  let pattern = buildPattern(substring);\n  return doesMatch(string, substring, pattern);\n}\n\nfunction buildPattern(substring) {\n  let pattern = new Array(substring.length).fill(-1);\n  let j = 0;\n  let i = 1;\n  while (i < substring.length) {\n    if (substring[i] === substring[j]) {\n      pattern[i] = j;\n      i++;\n      j++;\n    } else if (j > 0) {\n      j = pattern[j - 1] + 1;\n    } else {\n      i++;\n    }\n  }\n  return pattern;\n}\n\nfunction doesMatch(string, substring, pattern) {\n  let i = 0;\n  let j = 0;\n  while (i + substring.length - j <= string.length) {\n    if (string[i] === substring[j]) {\n      if (j === substring.length - 1) return true;\n      i++;\n      j++;\n    } else if (j > 0) {\n      j = pattern[j - 1] + 1;\n    } else {\n      i++;\n    }\n  }\n  return false;\n}\n\nexports.knuthMorrisPrattAlgorithm = knuthMorrisPrattAlgorithm;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.knuthMorrisPrattAlgorithm('aefoaefcdaefcdaed', 'aefcdaed'))\n    .to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.knuthMorrisPrattAlgorithm('aefoaefcdaefcdaed', 'aefcdaed'))\n    .to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n + m) time | O(m) space - where n is the length of the main string and m is the length of the potential substring',
    tests: [
      { string: 'aefoaefcdaefcdaed', substring: 'aefcdaed' },
      {
        string: 'testwafwafawfawfawfawfawfawfawfa',
        substring: 'fawfawfawfawfa',
      },
      {
        string: 'tesseatesgawatewtesaffawgfawtteafawtesftawfawfawfwfawftest',
        substring: 'test',
      },
      { string: 'aaabaabacdedfaabaabaaa', substring: 'aabaabaaa' },
      { string: 'abxabcabcaby', substring: 'abcaby' },
      { string: 'decadaafcdf', substring: 'daf' },
      { string: 'aefoaefcdaefcdaed', substring: 'aefcaefaeiaefcd' },
      {
        string: 'aefcdfaecdaefaefcdaefeaefcdcdeae',
        substring: 'aefcdaefeaefcd',
      },
      { string: 'bccbefbcdabbbcabfdcfe', substring: 'abc' },
      { string: 'adafccfefbbbfeeccbcfd', substring: 'ecb' },
      {
        string: 'testwherethefullstringmatches',
        substring: 'testwherethefullstringmatches',
      },
      { string: 'aabc', substring: 'abc' },
    ],
  },
  {
    id: "dijkstra's-algorithm",
    name: "Dijkstra's Algorithm",
    category: 'Famous Algorithms',
    complexity: 2,
    prompt:
      "<div class=\"html\">\n<p>\n  You're given an integer <span>start</span> and a list <span>edges</span> of\n  pairs of integers.\n</p>\n<p>\n  The list is what's called an adjacency list, and it represents a graph. The\n  number of vertices in the graph is equal to the length of <span>edges</span>,\n  where each index <span>i</span> in <span>edges</span> contains vertex\n  <span>i</span>'s outbound edges, in no particular order. Each individual edge\n  is represented by an pair of two numbers,\n  <span>[destination, distance]</span>, where the destination is a positive\n  integer denoting the destination vertex and the distance is a positive integer\n  representing the length of the edge (the distance from vertex\n  <span>i</span> to vertex <span>destination</span>). Note that these edges are\n  directed, meaning that you can only travel from a particular vertex to its\n  destinationnot the other way around (unless the destination vertex itself has\n  an outbound edge to the original vertex).\n</p>\n<p>\n  Write a function that computes the lengths of the shortest paths between\n  <span>start</span> and all of the other vertices in the graph using Dijkstra's\n  algorithm and returns them in an array. Each index <span>i</span> in the\n  output array should represent the length of the shortest path between\n  <span>start</span> and vertex <span>i</span>. If no path is found from\n  <span>start</span> to vertex <span>i</span>, then\n  <span>output[i]</span> should be <span>-1</span>.\n</p>\n<p>\n  Note that the graph represented by <span>edges</span> won't contain any\n  self-loops (vertices that have an outbound edge to themselves) and will only\n  have positively weighted edges (i.e., no negative distances).\n</p>\n<p>\n  If you're unfamiliar with Dijkstra's algorithm, we recommend watching the\n  Conceptual Overview section of this question's video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">start</span> = 0\n<span class=\"CodeEditor-promptParameter\">edges</span> = [\n  [[1, 7]],\n  [[2, 6], [3, 20], [4, 3]],\n  [[3, 14]],\n  [[4, 2]],\n  [],\n  [],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[0, 7, 13, 27, 10, -1]\n</pre>\n</div>",
    hints: [
      "<p>\nDijkstra's algorithm works by visiting vertices in the graph, one by one, all the while keeping track of the current shortest distances from the start vertex to all other vertices and continuously updating these shortest distances. More specifically, the algorithm keeps track of unvisited vertices and visits the unvisited vertex with the shortest distance at any point in time, naturally starting with the start vertex. Whenever the algorithm visits an unvisited vertex, it looks at all of its outbound edges and tries to update the shortest distances from the start to the destinations in the edges, using the current shortest distance to the current vertex as a base. Once the algorithm has visited all of the vertices and considered all of their edges, it is guaranteed to have found the shortest path to each vertex. How can you implement this algorithm?\n</p>\n",
      "\n<p>\nThe most challenging part of Dijkstra's algorithm is determining how to efficiently find the vertex with the current shortest distance. Can you think of a data structure that could be used to keep track of the distances and to efficiently retrieve the vertex with the current shortest distance at each step?\n</p>\n",
      "\n<p>\nCreate an array that can store the final shortest distances between the start vertex and all other vertices, as well as a min-heap that will hold all of the unvisited vertices and their current shortest distances. For both the final distances array and the min-heap, initialize all vertices except for the start node as having a distance of infinity; the start node will have a distance 0. Next, write a while loop that will run until the min-heap is empty. At every iteration in the loop, remove the vertex from the top of the heap (the vertex with the shortest distance), loop through all of its edges, and for each edge, update the shortest distance of the destination vertex to be the minimum of the destination's current shortest distance and the currently visited vertex's distance plus the current edge's weight. Once the heap is empty, all of the vertices will have been visited, and you'll have the shortest distances to all vertices stored in your distances array.\n</p>",
    ],
    customInputVars: [
      { name: 'start', example: 0, schema: { type: 'integer' } },
      {
        name: 'edges',
        example: [
          [[1, 7]],
          [
            [2, 6],
            [3, 20],
            [4, 3],
          ],
          [[3, 14]],
          [[4, 2]],
          [],
          [],
        ],
        schema: {
          items: {
            items: {
              items: { items: { maxItems: 2, minItems: 2 }, type: 'integer' },
              type: 'array',
            },
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function dijkstrasAlgorithm(start, edges) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.dijkstrasAlgorithm = dijkstrasAlgorithm;\n',
      solutions: [
        '// O(v^2 + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the input graph\nfunction dijkstrasAlgorithm(start, edges) {\n  const numberOfVertices = edges.length;\n\n  const minDistances = [];\n  for (let i = 0; i < numberOfVertices; i++) {\n    minDistances.push(Infinity);\n  }\n  minDistances[start] = 0;\n\n  const visited = new Set();\n\n  while (visited.size != numberOfVertices) {\n    const [vertex, currentMinDistance] = getVertexWithMinDistance(minDistances, visited);\n\n    if (currentMinDistance === Infinity) {\n      break;\n    }\n\n    visited.add(vertex);\n\n    for (const edge of edges[vertex]) {\n      const [destination, distanceToDestination] = edge;\n\n      if (visited.has(destination)) {\n        continue;\n      }\n\n      const newPathDistance = currentMinDistance + distanceToDestination;\n      const currentDestinationDistance = minDistances[destination];\n      if (newPathDistance < currentDestinationDistance) {\n        minDistances[destination] = newPathDistance;\n      }\n    }\n  }\n\n  return minDistances.map(x => x === Infinity ? -1 : x);\n}\n\nfunction getVertexWithMinDistance(distances, visited) {\n  let currentMinDistance = Infinity;\n  let vertex = -1;\n\n  for (const [vertexIdx, distance] of distances.entries()) {\n    if (visited.has(vertexIdx)) {\n      continue;\n    }\n    if (distance <= currentMinDistance) {\n      vertex = vertexIdx;\n      currentMinDistance = distance;\n    }\n  }\n\n  return [vertex, currentMinDistance];\n}\n\n// Do not edit the line below.\nexports.dijkstrasAlgorithm = dijkstrasAlgorithm;\n',
        '// O((v + e) * log(v)) time | O(v) space - where v is the number\n// of vertices and e is the number of edges in the input graph\nfunction dijkstrasAlgorithm(start, edges) {\n  const numberOfVertices = edges.length;\n\n  const minDistances = [];\n  const initialDistances = [];\n  for (let i = 0; i < numberOfVertices; i++) {\n    minDistances.push(Infinity);\n    initialDistances.push([i, Infinity]);\n  }\n  minDistances[start] = 0;\n\n  const minDistancesHeap = new MinHeap(initialDistances);\n  minDistancesHeap.update(start, 0);\n\n  while (!minDistancesHeap.isEmpty()) {\n    const [vertex, currentMinDistance] = minDistancesHeap.remove();\n\n    if (currentMinDistance === Infinity) {\n      break;\n    }\n\n    for (const edge of edges[vertex]) {\n      const [destination, distanceToDestination] = edge;\n\n      const newPathDistance = currentMinDistance + distanceToDestination;\n      const currentDestinationDistance = minDistances[destination];\n      if (newPathDistance < currentDestinationDistance) {\n        minDistances[destination] = newPathDistance;\n        minDistancesHeap.update(destination, newPathDistance);\n      }\n    }\n  }\n\n  return minDistances.map(x => x === Infinity ? -1 : x);\n}\n\nclass MinHeap {\n  constructor(array) {\n    // Holds the position in the heap that each vertex is at\n    this.vertexMap = array.reduce((obj, _, i) => {\n      obj[i] = i;\n      return obj;\n    }, {});\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx][1] < heap[childOneIdx][1]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap][1] < heap[currentIdx][1]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx][1] < heap[parentIdx][1]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    if (this.isEmpty()) return;\n\n    this.swap(0, this.heap.length - 1, this.heap);\n    const [vertex, distance] = this.heap.pop();\n    delete this.vertexMap[vertex];\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return [vertex, distance];\n  }\n\n  swap(i, j, heap) {\n    this.vertexMap[heap[i][0]] = j;\n    this.vertexMap[heap[j][0]] = i;\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n\n  update(vertex, value) {\n    this.heap[this.vertexMap[vertex]] = [vertex, value];\n    this.siftUp(this.vertexMap[vertex], this.heap);\n  }\n}\n\n// Do not edit the line below.\nexports.dijkstrasAlgorithm = dijkstrasAlgorithm;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const start = 0;\n  const edges = [\n    [[1, 7]],\n    [\n      [2, 6],\n      [3, 20],\n      [4, 3],\n    ],\n    [[3, 14]],\n    [[4, 2]],\n    [],\n    [],\n  ];\n  const expected = [0, 7, 13, 27, 10, -1];\n  const actual = program.dijkstrasAlgorithm(start, edges);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const start = 0;\n  const edges = [\n    [[1, 7]],\n    [\n      [2, 6],\n      [3, 20],\n      [4, 3],\n    ],\n    [[3, 14]],\n    [[4, 2]],\n    [],\n    [],\n  ];\n  const expected = [0, 7, 13, 27, 10, -1];\n  const actual = program.dijkstrasAlgorithm(start, edges);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O((v + e) * log(v)) time | O(v) space - where v is the number of vertices and e is the number of edges in the input graph',
    tests: [
      {
        edges: [
          [[1, 7]],
          [
            [2, 6],
            [3, 20],
            [4, 3],
          ],
          [[3, 14]],
          [[4, 2]],
          [],
          [],
        ],
        start: 0,
      },
      { edges: [[], [], [], []], start: 1 },
      {
        edges: [
          [
            [1, 1],
            [3, 1],
          ],
          [[2, 1]],
          [[6, 1]],
          [
            [1, 3],
            [2, 4],
            [4, 2],
            [5, 3],
            [6, 5],
          ],
          [[5, 1]],
          [[4, 1]],
          [[5, 2]],
          [[0, 7]],
        ],
        start: 7,
      },
      {
        edges: [
          [
            [1, 3],
            [2, 2],
          ],
          [[3, 7]],
          [
            [1, 2],
            [3, 4],
            [4, 1],
          ],
          [],
          [
            [0, 2],
            [1, 8],
            [3, 1],
          ],
        ],
        start: 4,
      },
      { edges: [[[1, 2]], [[0, 1]], [[3, 1]], [[2, 2]]], start: 1 },
      {
        edges: [
          [
            [1, 1],
            [7, 8],
          ],
          [[2, 1]],
          [[3, 1]],
          [[4, 1]],
          [[5, 1]],
          [[6, 1]],
          [[7, 1]],
          [],
        ],
        start: 0,
      },
      {
        edges: [
          [
            [1, 2],
            [3, 3],
            [4, 2],
          ],
          [
            [0, 1],
            [6, 3],
          ],
          [[3, 9]],
          [
            [0, 3],
            [1, 4],
            [4, 4],
            [8, 7],
          ],
          [
            [0, 1],
            [10, 3],
          ],
          [
            [7, 1],
            [8, 4],
          ],
          [[8, 1]],
          [],
          [[7, 1]],
          [[10, 2]],
          [],
        ],
        start: 3,
      },
      {
        edges: [
          [
            [1, 4],
            [7, 11],
          ],
          [
            [0, 4],
            [2, 11],
            [7, 14],
          ],
          [
            [1, 11],
            [3, 10],
            [5, 7],
            [8, 5],
          ],
          [
            [2, 10],
            [4, 12],
            [5, 17],
          ],
          [
            [3, 12],
            [5, 13],
            [6, 3],
          ],
          [
            [2, 7],
            [3, 17],
            [4, 13],
            [6, 5],
          ],
          [
            [4, 3],
            [5, 6],
            [7, 4],
            [9, 8],
          ],
          [
            [0, 11],
            [1, 14],
            [6, 4],
            [8, 10],
          ],
          [
            [2, 5],
            [6, 9],
            [7, 10],
          ],
          [],
        ],
        start: 8,
      },
      {
        edges: [
          [[2, 4]],
          [[0, 2]],
          [
            [1, 1],
            [3, 2],
          ],
          [[0, 3]],
        ],
        start: 3,
      },
    ],
  },
  {
    id: 'a*-algorithm',
    name: 'A* Algorithm',
    category: 'Famous Algorithms',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array containing <span>0</span>s and\n  <span>1</span>s, where each <span>0</span> represents a free space and each\n  <span>1</span> represents an obstacle (a space that cannot be passed through).\n  You can think of this array as a grid-shaped graph. You\'re also given four\n  integers <span>startRow</span>, <span>startCol</span>, <span>endRow</span>,\n  and <span>endCol</span>, representing the positions of a start node and an end\n  node in the graph.\n</p>\n<p>\n  Write a function that finds the shortest path between the start node and the\n  end node using the A* search algorithm and returns it.\n</p>\n<p>\n  The shortest path should be returned as an array of node positions, where each\n  node position is an array of two elements: the <span>[row, col]</span> of the\n  respective node in the graph. The output array should contain the start node\'s\n  position, the end node\'s position, and all of the positions of the remaining\n  nodes in the shortest path, and these node positions should be ordered from\n  start node to end node.\n</p>\n<p>\n  If there is no path from the start node to the end node, your function should\n  return an empty array.\n</p>\n<p>Note that:</p>\n<ul>\n  <li>\n    From each node in the graph, you can only travel in four directions: up,\n    left, down and right; you can\'t travel diagonally.\n  </li>\n  <li>\n    The distance between all neighboring nodes in the graph is the same; you\n    can treat it as a distance of 1.\n  </li>\n  <li>\n    The start node and end node are guaranteed to be located in empty spaces\n    (cells containing <span>0</span>).\n  </li>\n  <li>\n    The start node and end node will never be out of bounds and will never\n    overlap.\n  </li>\n  <li>\n    There will be at most one shortest path from the start node to the end\n    node.\n  </li>\n</ul>\n<p>\n  If you\'re unfamiliar with A*, we recommend watching the Conceptual Overview\n  section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">startRow</span> = 0\n<span class="CodeEditor-promptParameter">startCol</span> = 1\n<span class="CodeEditor-promptParameter">endRow</span> = 4\n<span class="CodeEditor-promptParameter">endCol</span> = 3\n<span class="CodeEditor-promptParameter">graph</span> = [\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [1, 0, 1, 1, 1],\n  [0, 0, 0, 0, 0],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[0, 1], [0, 0], [1, 0], [2, 0], [2, 1], [3, 1], [4, 1], [4, 2], [4, 3]]\n\n<span class="CodeEditor-promptComment">// The shortest path can be clearly seen here:</span>\n<span class="CodeEditor-promptComment">// [</span>\n<span class="CodeEditor-promptComment">//   [., ., 0, 0, 0],</span>\n<span class="CodeEditor-promptComment">//   [., 1, 1, 1, 0],</span>\n<span class="CodeEditor-promptComment">//   [., ., 0, 0, 0],</span>\n<span class="CodeEditor-promptComment">//   [1, ., 1, 1, 1],</span>\n<span class="CodeEditor-promptComment">//   [0, ., ., ., 0],</span>\n<span class="CodeEditor-promptComment">// ]</span>\n</pre>\n</div>',
    hints: [
      '<p>\nA* works by visiting nodes in the graph, one by one, all the while keeping track of their shortest estimated distance to the end node and continuously updating these distances. More specifically, the algorithm keeps track of unvisited nodes and visits the unvisited node with the shortest estimated distance to the end node at any point in time, naturally starting with the start node. Whenever the algorithm visits an unvisited node, it looks at all of its neighboring nodes and tries to update their shortest estimated distance to the end node, using the current shortest distance to the current node as a base and using a special heuristic to estimate the remaining distance to the end node. In a grid-shaped graph, the heuristic used is often the Manhattan Distance (i.e., the number of naive vertical and horizontal steps between the current node and the end node). Once the algorithm has reached the end node, it is guaranteed to have found the shortest path to it. How can you implement this algorithm?\n</p>\n',
      '\n<p>\nThe most challenging part of A* is determining how to efficiently find the node with the current shortest estimated distance to the end. Can you think of a data structure that could be used to keep track of the distances and to efficiently retrieve the node with the current shortest estimated distance to the end at each step?\n</p>\n',
      "\n<p>\nCreate a min-heap that will hold all of the unvisited nodes and their current shortest estimated distance to the end node. Initialize all nodes except for the start node as having a shortest estimated distance to the end node of infinity and also a shortest distance from the start node to themselves of infinity; the start node will have a distance to itself of 0 and an estimated distance to the end node of its Manhattan Distance to the end node. Next, write a while loop that will run until the min-heap is empty or until the end node is reached. At every iteration in the loop, remove the node from the top of the heap (the node with the shortest estimated distance to the end node), loop through all of its neighboring nodes, and for each neighbor, update its two distances if reaching the neighbor from the current node yields a shorter distance than whatever's already stored on the neighbor. Once you reach the end node, you'll have found the shortest path to it from the start node. Note that you'll have to keep track of which node each node came from whenever you update node distances; this is so that you can reconstruct the shortest path once you reach the end node.\n</p>",
    ],
    customInputVars: [
      { name: 'startRow', example: 0, schema: { type: 'integer' } },
      { name: 'startCol', example: 1, schema: { type: 'integer' } },
      { name: 'endRow', example: 4, schema: { type: 'integer' } },
      { name: 'endCol', example: 3, schema: { type: 'integer' } },
      {
        name: 'graph',
        example: [
          [0, 0, 0, 0, 0],
          [0, 1, 1, 1, 0],
          [0, 0, 0, 0, 0],
          [1, 0, 1, 1, 1],
          [0, 0, 0, 0, 0],
        ],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function aStarAlgorithm(startRow, startCol, endRow, endCol, graph) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.aStarAlgorithm = aStarAlgorithm;\n',
      solutions: [
        "class Node {\n  constructor(row, col, value) {\n    this.id = row.toString() + '-' + col.toString();\n    this.row = row;\n    this.col = col;\n    this.value = value;\n    this.distanceFromStart = Infinity;\n    this.estimatedDistanceToEnd = Infinity;\n    this.cameFrom = null;\n  }\n}\n\n// O(w * h * log(w * h)) time | O(w * h) space - where\n// w is the width of the graph and h is the height\nfunction aStarAlgorithm(startRow, startCol, endRow, endCol, graph) {\n  const nodes = initializeNodes(graph);\n\n  const startNode = nodes[startRow][startCol];\n  const endNode = nodes[endRow][endCol];\n\n  startNode.distanceFromStart = 0;\n  startNode.estimatedDistanceToEnd = calculateManhattanDistance(startNode, endNode);\n\n  const nodesToVisit = new MinHeap([startNode]);\n\n  while (!nodesToVisit.isEmpty()) {\n    const currentMinDistanceNode = nodesToVisit.remove();\n\n    if (currentMinDistanceNode === endNode) break;\n\n    const neighbors = getNeighboringNodes(currentMinDistanceNode, nodes);\n    for (const neighbor of neighbors) {\n      if (neighbor.value === 1) continue;\n\n      const tentativeDistanceToNeighbor = currentMinDistanceNode.distanceFromStart + 1;\n\n      if (tentativeDistanceToNeighbor >= neighbor.distanceFromStart) continue;\n\n      neighbor.cameFrom = currentMinDistanceNode;\n      neighbor.distanceFromStart = tentativeDistanceToNeighbor;\n      neighbor.estimatedDistanceToEnd =\n        tentativeDistanceToNeighbor + calculateManhattanDistance(neighbor, endNode);\n\n      if (!nodesToVisit.containsNode(neighbor)) {\n        nodesToVisit.insert(neighbor);\n      } else {\n        nodesToVisit.update(neighbor);\n      }\n    }\n  }\n\n  return reconstructPath(endNode);\n}\n\nfunction initializeNodes(graph) {\n  const nodes = [];\n\n  for (const [i, row] of graph.entries()) {\n    nodes.push([]);\n    for (const [j, value] of row.entries()) {\n      const node = new Node(i, j, value);\n      nodes[i].push(node);\n    }\n  }\n\n  return nodes;\n}\n\nfunction calculateManhattanDistance(currentNode, endNode) {\n  const currentRow = currentNode.row;\n  const currentCol = currentNode.col;\n  const endRow = endNode.row;\n  const endCol = endNode.col;\n\n  return Math.abs(currentRow - endRow) + Math.abs(currentCol - endCol);\n}\n\nfunction getNeighboringNodes(node, nodes) {\n  const neighbors = [];\n\n  const numRows = nodes.length;\n  const numCols = nodes[0].length;\n\n  const row = node.row;\n  const col = node.col;\n\n  if (row < numRows - 1) {\n    // DOWN\n    neighbors.push(nodes[row + 1][col]);\n  }\n\n  if (row > 0) {\n    // UP\n    neighbors.push(nodes[row - 1][col]);\n  }\n\n  if (col < numCols - 1) {\n    // RIGHT\n    neighbors.push(nodes[row][col + 1]);\n  }\n\n  if (col > 0) {\n    // LEFT\n    neighbors.push(nodes[row][col - 1]);\n  }\n\n  return neighbors;\n}\n\nfunction reconstructPath(endNode) {\n  if (endNode.cameFrom === null) {\n    return [];\n  }\n\n  let currentNode = endNode;\n  const path = [];\n\n  while (currentNode !== null) {\n    path.push([currentNode.row, currentNode.col]);\n    currentNode = currentNode.cameFrom;\n  }\n\n  path.reverse(); // reverse path so it goes from start to end\n\n  return path;\n}\n\nclass MinHeap {\n  constructor(array) {\n    // Holds the position in the heap that each node is at\n    this.nodePositionsInHeap = array.reduce((obj, node, i) => {\n      obj[node.id] = i;\n      return obj;\n    }, {});\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  // O(n) time | O(1) space\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  // O(log(n)) time | O(1) space\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (\n        childTwoIdx !== -1 &&\n        heap[childTwoIdx].estimatedDistanceToEnd < heap[childOneIdx].estimatedDistanceToEnd\n      ) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap].estimatedDistanceToEnd < heap[currentIdx].estimatedDistanceToEnd) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (\n      currentIdx > 0 &&\n      heap[currentIdx].estimatedDistanceToEnd < heap[parentIdx].estimatedDistanceToEnd\n    ) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  // O(log(n)) time | O(1) space\n  remove() {\n    if (this.isEmpty()) return;\n\n    this.swap(0, this.heap.length - 1, this.heap);\n    const node = this.heap.pop();\n    delete this.nodePositionsInHeap[node.id];\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return node;\n  }\n\n  // O(log(n)) time | O(1) space\n  insert(node) {\n    this.heap.push(node);\n    this.nodePositionsInHeap[node.id] = this.heap.length - 1;\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    this.nodePositionsInHeap[this.heap[i].id] = j;\n    this.nodePositionsInHeap[this.heap[j].id] = i;\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n\n  containsNode(node) {\n    return node.id in this.nodePositionsInHeap;\n  }\n\n  update(node) {\n    this.siftUp(this.nodePositionsInHeap[node.id], this.heap);\n  }\n}\n\n// Do not edit the line below.\nexports.aStarAlgorithm = aStarAlgorithm;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const startRow = 0;\n  const startCol = 1;\n  const endRow = 4;\n  const endCol = 3;\n  const graph = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0],\n    [1, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0],\n  ];\n  const expected = [\n    [0, 1],\n    [0, 0],\n    [1, 0],\n    [2, 0],\n    [2, 1],\n    [3, 1],\n    [4, 1],\n    [4, 2],\n    [4, 3],\n  ];\n  const actual = program.aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const startRow = 0;\n  const startCol = 1;\n  const endRow = 4;\n  const endCol = 3;\n  const graph = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0],\n    [1, 0, 1, 1, 1],\n    [0, 0, 0, 0, 0],\n  ];\n  const expected = [\n    [0, 1],\n    [0, 0],\n    [1, 0],\n    [2, 0],\n    [2, 1],\n    [3, 1],\n    [4, 1],\n    [4, 2],\n    [4, 3],\n  ];\n  const actual = program.aStarAlgorithm(startRow, startCol, endRow, endCol, graph);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(w * h * log(w * h)) time | O(w * h) space - where w is the width of the graph and h is the height',
    tests: [
      {
        endCol: 3,
        endRow: 4,
        graph: [
          [0, 0, 0, 0, 0],
          [0, 1, 1, 1, 0],
          [0, 0, 0, 0, 0],
          [1, 0, 1, 1, 1],
          [0, 0, 0, 0, 0],
        ],
        startCol: 1,
        startRow: 0,
      },
      {
        endCol: 8,
        endRow: 8,
        graph: [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
          [1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
          [1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
          [1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
          [1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
          [1, 1, 0, 0, 0, 1, 0, 1, 0, 1],
          [1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
        startCol: 1,
        startRow: 1,
      },
      {
        endCol: 4,
        endRow: 7,
        graph: [
          [1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
          [1, 1, 0, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 1, 0, 1, 1, 0, 0, 0],
          [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
          [0, 0, 0, 1, 0, 0, 1, 1, 1, 0],
          [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 1, 1, 1, 0, 1, 1, 1],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ],
        startCol: 1,
        startRow: 1,
      },
      {
        endCol: 1,
        endRow: 8,
        graph: [
          [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
          [0, 0, 1, 0, 1, 1, 1, 0, 0, 0],
          [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
          [0, 0, 1, 1, 1, 0, 1, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 1, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 1, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 1, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ],
        startCol: 8,
        startRow: 1,
      },
      {
        endCol: 19,
        endRow: 0,
        graph: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
          [0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
          [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0],
          [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0],
          [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0],
          [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ],
        startCol: 0,
        startRow: 0,
      },
      {
        endCol: 17,
        endRow: 18,
        graph: [
          [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
          [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
          [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0],
          [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0],
          [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0],
          [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0],
          [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0],
          [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0],
          [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0],
          [0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0],
          [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0],
          [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
          [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0],
          [0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],
          [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1],
          [0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
          [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
        ],
        startCol: 1,
        startRow: 1,
      },
      {
        endCol: 2,
        endRow: 1,
        graph: [
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
          [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
          [0, 1, 1, 0, 1, 1, 1, 0, 0, 0],
          [0, 1, 0, 1, 1, 0, 1, 0, 1, 0],
          [0, 1, 0, 1, 0, 0, 1, 0, 1, 0],
          [0, 1, 0, 1, 0, 0, 1, 0, 0, 0],
          [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ],
        startCol: 1,
        startRow: 1,
      },
      {
        endCol: 4,
        endRow: 22,
        graph: [
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1,
          ],
          [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,
          ],
          [
            0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0,
          ],
          [
            0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 0,
          ],
          [
            0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,
          ],
        ],
        startCol: 11,
        startRow: 1,
      },
    ],
  },
  {
    id: 'topological-sort',
    name: 'Topological Sort',
    category: 'Famous Algorithms',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a list of arbitrary jobs that need to be completed; these jobs\n  are represented by distinct integers. You\'re also given a list of dependencies. A\n  dependency is represented as a pair of jobs where the first job is a\n  prerequisite of the second one. In other words, the second job depends on the\n  first one; it can only be completed once the first job is completed.\n</p>\n<p>\n  Write a function that takes in a list of jobs and a list of dependencies and\n  returns a list containing a valid order in which the given jobs can be\n  completed. If no such order exists, the function should return an empty array.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">jobs</span> = [1, 2, 3, 4]\n<span class="CodeEditor-promptParameter">deps</span> = [[1, 2], [1, 3], [3, 2], [4, 2], [4, 3]]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[1, 4, 3, 2] or [4, 1, 3, 2]\n</pre>\n</div>',
    hints: [
      '<p>\nTry representing the jobs and dependencies as a graph, where each vertex is a job and each edge is a dependency. How can you traverse this graph to topologically sort the list of jobs?\n</p>\n',
      "\n<p>\nOne approach to solving this problem is to traverse the graph mentioned in Hint #1 using Depth-first Search. Starting at a random job, traverse its prerequisite jobs in Depth-first Search fashion until you reach a job with no prerequisites; such a job can safely be appended to the final order. Once you've traversed and added all prerequisites of a job to the final order, you can append the job in question to the order. This approach will have to track whether nodes have been traversed already, whether they're in the process of being traversed (which would indicate a cycle in the graph and therefore no valid topological order), or whether they're ready to be traversed.\n</p>\n",
      "\n<p>\nAnother approach to solving this problem is to traverse the graph mentioned in Hint #1 starting specifically with jobs that have no prerequisites. Keep track of all the jobs that have no prerequisites, traverse them one by one, and append them to the final order. For all of these jobs, remove their dependencies from the graph and update the number of prerequisites for each of these dependencies accordingly (these dependencies should now have one prerequisite less since one of their prerequisite job has just been added to the final order). As you update the number of prerequisites for these other jobs, keep track of the ones that no longer have prerequisites and that are ready to be traversed. You'll eventually go through all of the jobs if there are no cycles in the graph. If there is a cycle in the graph, there will still be jobs with prerequisites and you'll know that there is no valid topological order. This approach will involve keeping track of the number of prerequisites per job as well as all the actual dependencies of each job.\n</p>",
    ],
    customInputVars: [
      {
        name: 'jobs',
        example: [1, 2, 3, 4],
        schema: {
          items: { type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
      {
        name: 'deps',
        example: [
          [1, 2],
          [1, 3],
          [3, 2],
          [4, 2],
          [4, 3],
        ],
        schema: {
          items: {
            items: { type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function topologicalSort(jobs, deps) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.topologicalSort = topologicalSort;\n',
      solutions: [
        '// O(j + d) time | O(j + d) space\nfunction topologicalSort(jobs, deps) {\n  const jobGraph = createJobGraph(jobs, deps);\n  return getOrderedJobs(jobGraph);\n}\n\nfunction createJobGraph(jobs, deps) {\n  const graph = new JobGraph(jobs);\n  for (const [prereq, job] of deps) {\n    graph.addPrereq(job, prereq);\n  }\n  return graph;\n}\n\nfunction getOrderedJobs(graph) {\n  const orderedJobs = [];\n  const {nodes} = graph;\n  while (nodes.length) {\n    const node = nodes.pop();\n    const containsCycle = depthFirstTraverse(node, orderedJobs);\n    if (containsCycle) return [];\n  }\n  return orderedJobs;\n}\n\nfunction depthFirstTraverse(node, orderedJobs) {\n  if (node.visited) return false;\n  if (node.visiting) return true;\n  node.visiting = true;\n  for (const prereqNode of node.prereqs) {\n    const containsCycle = depthFirstTraverse(prereqNode, orderedJobs);\n    if (containsCycle) return true;\n  }\n  node.visited = true;\n  node.visiting = false;\n  orderedJobs.push(node.job);\n  return false;\n}\n\nclass JobGraph {\n  constructor(jobs) {\n    this.nodes = [];\n    this.graph = {};\n    for (const job of jobs) {\n      this.addNode(job);\n    }\n  }\n\n  addPrereq(job, prereq) {\n    const jobNode = this.getNode(job);\n    const prereqNode = this.getNode(prereq);\n    jobNode.prereqs.push(prereqNode);\n  }\n\n  addNode(job) {\n    this.graph[job] = new JobNode(job);\n    this.nodes.push(this.graph[job]);\n  }\n\n  getNode(job) {\n    if (!(job in this.graph)) this.addNode(job);\n    return this.graph[job];\n  }\n}\n\nclass JobNode {\n  constructor(job) {\n    this.job = job;\n    this.prereqs = [];\n    this.visited = false;\n    this.visiting = false;\n  }\n}\n\nexports.topologicalSort = topologicalSort;\n',
        '// O(j + d) time | O(j + d) space\nfunction topologicalSort(jobs, deps) {\n  const jobGraph = createJobGraph(jobs, deps);\n  return getOrderedJobs(jobGraph);\n}\n\nfunction createJobGraph(jobs, deps) {\n  const graph = new JobGraph(jobs);\n  for (const [job, dep] of deps) {\n    graph.addDep(job, dep);\n  }\n  return graph;\n}\n\nfunction getOrderedJobs(graph) {\n  const orderedJobs = [];\n  const nodesWithNoPrereqs = graph.nodes.filter(node => !node.numOfPrereqs);\n  while (nodesWithNoPrereqs.length) {\n    const node = nodesWithNoPrereqs.pop();\n    orderedJobs.push(node.job);\n    removeDeps(node, nodesWithNoPrereqs);\n  }\n  const graphHasEdges = graph.nodes.some(node => node.numOfPrereqs);\n  return graphHasEdges ? [] : orderedJobs;\n}\n\nfunction removeDeps(node, nodesWithNoPrereqs) {\n  while (node.deps.length) {\n    const dep = node.deps.pop();\n    dep.numOfPrereqs--;\n    if (!dep.numOfPrereqs) nodesWithNoPrereqs.push(dep);\n  }\n}\n\nclass JobGraph {\n  constructor(jobs) {\n    this.nodes = [];\n    this.graph = {};\n    for (const job of jobs) {\n      this.addNode(job);\n    }\n  }\n\n  addDep(job, dep) {\n    const jobNode = this.getNode(job);\n    const depNode = this.getNode(dep);\n    jobNode.deps.push(depNode);\n    depNode.numOfPrereqs++;\n  }\n\n  addNode(job) {\n    this.graph[job] = new JobNode(job);\n    this.nodes.push(this.graph[job]);\n  }\n\n  getNode(job) {\n    if (!(job in this.graph)) this.addNode(job);\n    return this.graph[job];\n  }\n}\n\nclass JobNode {\n  constructor(job) {\n    this.job = job;\n    this.deps = [];\n    this.numOfPrereqs = 0;\n  }\n}\n\nexports.topologicalSort = topologicalSort;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const jobs = [1, 2, 3, 4];\n  const deps = [\n    [1, 2],\n    [1, 3],\n    [3, 2],\n    [4, 2],\n    [4, 3],\n  ];\n  const order = program.topologicalSort(jobs, deps);\n  chai.expect(isValidTopologicalOrder(order, jobs, deps)).to.deep.equal(true);\n});\n\nfunction isValidTopologicalOrder(order, jobs, deps) {\n  const visited = {};\n  for (const candidate of order) {\n    for (const [prereq, job] of deps) {\n      if (candidate === prereq && job in visited) return false;\n    }\n    visited[candidate] = true;\n  }\n  for (const job of jobs) {\n    if (!(job in visited)) return false;\n  }\n  return order.length === jobs.length;\n}\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const jobs = [1, 2, 3, 4];\n  const deps = [\n    [1, 2],\n    [1, 3],\n    [3, 2],\n    [4, 2],\n    [4, 3],\n  ];\n  const order = program.topologicalSort(jobs, deps);\n  chai.expect(isValidTopologicalOrder(order, jobs, deps)).to.deep.equal(true);\n});\n\nfunction isValidTopologicalOrder(order, jobs, deps) {\n  const visited = {};\n  for (const candidate of order) {\n    for (const [prereq, job] of deps) {\n      if (candidate === prereq && job in visited) return false;\n    }\n    visited[candidate] = true;\n  }\n  for (const job of jobs) {\n    if (!(job in visited)) return false;\n  }\n  return order.length === jobs.length;\n}\n",
    },
    bigO: 'O(j + d) time | O(j + d) space - where j is the number of jobs and d is the number of dependencies',
    tests: [
      {
        deps: [
          [1, 2],
          [1, 3],
          [3, 2],
          [4, 2],
          [4, 3],
        ],
        jobs: [1, 2, 3, 4],
      },
      {
        deps: [
          [3, 1],
          [8, 1],
          [8, 7],
          [5, 7],
          [5, 2],
          [1, 4],
          [1, 6],
          [1, 2],
          [7, 6],
        ],
        jobs: [1, 2, 3, 4, 5, 6, 7, 8],
      },
      {
        deps: [
          [3, 1],
          [8, 1],
          [8, 7],
          [5, 7],
          [5, 2],
          [1, 4],
          [6, 7],
          [1, 2],
          [7, 6],
        ],
        jobs: [1, 2, 3, 4, 5, 6, 7, 8],
      },
      {
        deps: [
          [3, 1],
          [8, 1],
          [8, 7],
          [5, 7],
          [5, 2],
          [1, 4],
          [1, 6],
          [1, 2],
          [7, 6],
          [4, 6],
          [6, 2],
          [2, 3],
        ],
        jobs: [1, 2, 3, 4, 5, 6, 7, 8],
      },
      {
        deps: [
          [1, 2],
          [2, 3],
          [3, 4],
          [4, 5],
          [5, 6],
          [6, 7],
          [7, 8],
          [8, 1],
        ],
        jobs: [1, 2, 3, 4, 5, 6, 7, 8],
      },
      {
        deps: [
          [1, 2],
          [2, 3],
          [3, 4],
          [4, 5],
          [5, 6],
          [7, 6],
          [7, 8],
          [8, 1],
        ],
        jobs: [1, 2, 3, 4, 5, 6, 7, 8, 9],
      },
      {
        deps: [
          [1, 2],
          [3, 5],
          [4, 6],
          [3, 6],
          [1, 7],
          [7, 8],
          [1, 8],
          [2, 8],
        ],
        jobs: [1, 2, 3, 4, 5, 6, 7, 8],
      },
      {
        deps: [
          [1, 2],
          [1, 3],
          [1, 4],
          [1, 5],
          [1, 6],
          [1, 7],
          [2, 8],
          [3, 8],
          [4, 8],
          [5, 8],
          [6, 8],
          [7, 8],
        ],
        jobs: [1, 2, 3, 4, 5, 6, 7, 8],
      },
      {
        deps: [
          [1, 2],
          [1, 3],
          [1, 4],
          [1, 5],
          [1, 6],
          [1, 7],
          [2, 8],
          [3, 8],
          [4, 8],
          [5, 8],
          [6, 8],
          [7, 8],
          [2, 3],
          [2, 4],
          [5, 4],
          [7, 6],
          [6, 2],
          [6, 3],
          [6, 5],
          [5, 9],
          [9, 8],
          [8, 0],
          [4, 0],
          [5, 0],
          [9, 0],
          [2, 0],
          [3, 9],
          [3, 10],
          [10, 11],
          [11, 12],
          [2, 12],
        ],
        jobs: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
      },
      {
        deps: [
          [1, 2],
          [1, 3],
          [1, 4],
          [1, 5],
          [1, 6],
          [1, 7],
          [2, 8],
          [3, 8],
          [4, 8],
          [5, 8],
          [6, 8],
          [7, 8],
          [2, 3],
          [2, 4],
          [5, 4],
          [7, 6],
          [6, 2],
          [6, 3],
          [6, 5],
          [5, 9],
          [9, 8],
          [8, 0],
          [4, 0],
          [5, 0],
          [9, 0],
          [2, 0],
          [3, 9],
          [3, 10],
          [10, 11],
          [11, 12],
          [12, 2],
        ],
        jobs: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
      },
      { deps: [], jobs: [1, 2, 3, 4, 5] },
      {
        deps: [
          [1, 4],
          [5, 2],
        ],
        jobs: [1, 2, 3, 4, 5],
      },
    ],
  },
  {
    id: 'minimum-waiting-time',
    name: 'Minimum Waiting Time',
    category: 'Greedy Algorithms',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a non-empty array of positive integers representing the amounts\n  of time that specific queries take to execute. Only one query can be executed\n  at a time, but the queries can be executed in any order.\n</p>\n<p>\n  A query\'s <b>waiting time</b> is defined as the amount of time that it must\n  wait before its execution starts. In other words, if a query is executed\n  second, then its waiting time is the duration of the first query; if a query\n  is executed third, then its waiting time is the sum of the durations of the\n  first two queries.\n</p>\n<p>\n  Write a function that returns the minimum amount of total waiting time for all\n  of the queries. For example, if you\'re given the queries of durations\n  <span>[1, 4, 5]</span>, then the total waiting time if the queries were\n  executed in the order of <span>[5, 1, 4]</span> would be\n  <span>(0) + (5) + (5 + 1) = 11</span>. The first query of duration\n  <span>5</span> would be executed immediately, so its waiting time would be\n  <span>0</span>, the second query of duration <span>1</span> would have to wait\n  <span>5</span> seconds (the duration of the first query) to be executed, and\n  the last query would have to wait the duration of the first two queries before\n  being executed.\n</p>\n<p>Note: you\'re allowed to mutate the input array.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">queries</span> = [3, 2, 1, 2, 6]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n17\n</pre>\n</div>',
    hints: [
      "<p>\nEven though you don't need to return the actual order in which the queries will be executed to minimize the total waiting time, it's important to determine what this order should be. Start by doing so.\n</p>\n",
      '\n<p>\nCan you solve this problem with constant space? What advantage does being able to mutate the input array provide?\n</p>\n',
      '\n<p>\nSort the input array in place, and execute the shortest queries in their sorted order. This should allow you to calculate the minimum waiting time. \n</p>\n',
      '\n<p>\nCreate a variable to store the total waiting time, and iterate through the sorted input array. At each iteration, multiply the number of queries left by the duration of the current query, and add that to the total waiting time.\n</p>',
    ],
    customInputVars: [
      {
        name: 'queries',
        example: [3, 2, 1, 2, 6],
        schema: {
          items: { minimum: 1, type: 'integer' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function minimumWaitingTime(queries) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.minimumWaitingTime = minimumWaitingTime;\n',
      solutions: [
        '// O(nlogn) time | O(1) space - where n is the number of queries\nfunction minimumWaitingTime(queries) {\n  queries.sort((a, b) => a - b);\n\n  let totalWaitingTime = 0;\n  for (let idx = 0; idx < queries.length; idx++) {\n    const duration = queries[idx];\n    const queriesLeft = queries.length - (idx + 1);\n    totalWaitingTime += duration * queriesLeft;\n  }\n\n  return totalWaitingTime;\n}\n\n// Do not edit the line below.\nexports.minimumWaitingTime = minimumWaitingTime;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const queries = [3, 2, 1, 2, 6];\n  const expected = 17;\n  const actual = program.minimumWaitingTime(queries);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const queries = [3, 2, 1, 2, 6];\n  const expected = 17;\n  const actual = program.minimumWaitingTime(queries);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlogn) time | O(1) space - where n is the number of queries',
    tests: [
      { queries: [3, 2, 1, 2, 6] },
      { queries: [2, 1, 1, 1] },
      { queries: [1, 2, 4, 5, 2, 1] },
      { queries: [25, 30, 2, 1] },
      { queries: [1, 1, 1, 1, 1] },
      { queries: [7, 9, 2, 3] },
      { queries: [4, 3, 1, 1, 3, 2, 1, 8] },
      { queries: [2] },
      { queries: [7] },
      { queries: [8, 9] },
      { queries: [1, 9] },
      { queries: [5, 4, 3, 2, 1] },
      { queries: [1, 2, 3, 4, 5] },
      { queries: [1, 1, 1, 4, 5, 6, 8, 1, 1, 2, 1] },
      { queries: [17, 4, 3] },
    ],
  },
  {
    id: 'task-assignment',
    name: 'Task Assignment',
    category: 'Greedy Algorithms',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an integer <span>k</span> representing a number of workers and an\n  array of positive integers representing durations of tasks that must be\n  completed by the workers. Specifically, each worker must complete two unique\n  tasks and can only work on one task at a time. The number of tasks will always\n  be equal to <span>2k</span> such that each worker always has exactly two tasks\n  to complete. All tasks are independent of one another and can be completed in\n  any order. Workers will complete their assigned tasks in parallel, and the\n  time taken to complete all tasks will be equal to the time taken to complete\n  the longest pair of tasks (see the sample output for an explanation).\n</p>\n<p>\n  Write a function that returns the optimal assignment of tasks to each worker\n  such that the tasks are completed as fast as possible. Your function should\n  return a list of pairs, where each pair stores the indices of the tasks that\n  should be completed by one worker. The pairs should be in the following\n  format: <span>[task1, task2]</span>, where the order of <span>task1</span> and\n  <span>task2</span> doesn\'t matter. Your function can return the pairs in any\n  order. If multiple optimal assignments exist, any correct answer will be\n  accepted.\n</p>\n<p>\n  Note: you\'ll always be given at least one worker (i.e., <span>k</span> will\n  always be greater than <b>0</b>).\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">k</span> = 3\n<span class="CodeEditor-promptParameter">tasks</span> = [1, 3, 5, 3, 1, 4]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\n  [0, 2], <span class="CodeEditor-promptComment">// tasks[0] = 1, tasks[2] = 5 | 1 + 5 = 6</span>\n  [4, 5], <span class="CodeEditor-promptComment">// tasks[4] = 1, tasks[5] = 4 | 1 + 4 = 5</span>\n  [1, 3], <span class="CodeEditor-promptComment">// tasks[1] = 3, tasks[3] = 3 | 3 + 3 = 6</span>\n] <span class="CodeEditor-promptComment">// The fastest time to complete all tasks is 6.</span>\n\n<span class="CodeEditor-promptComment">// Note: there are multiple correct answers for this sample input.</span>\n<span class="CodeEditor-promptComment">// The following is an example of another correct answer:</span>\n<span class="CodeEditor-promptComment">// [</span>\n<span class="CodeEditor-promptComment">//   [2, 4],</span>\n<span class="CodeEditor-promptComment">//   [0, 5],</span>\n<span class="CodeEditor-promptComment">//   [1, 3]</span>\n<span class="CodeEditor-promptComment">// [</span>\n</pre>\n</div>',
    hints: [
      '<p>\nStart by considering which pairs of tasks will lead to the <b>longest</b> possible time to complete all tasks. \n</p>\n',
      "\n<p>\nThe amount of time it'll take to complete all tasks will be dictated by the pair of tasks that has the longest total duration. This means that you'll want to avoid pairing long tasks together.\n</p>\n",
      "\n<p>\nSince the pair of tasks with the longest total duration is the time it takes for us to finish all tasks, we want to minimize this pair's duration. To do this, we can simply pair the shortest-duration task with the longest-duration task and repeat the process with all other tasks.\n</p>\n",
      "\n<p>\nStart by sorting the tasks array in ascending order. Then, pair the shortest-duration task with the longest-duration task, and add that pair to some output array. Repeat this process until you've paired all tasks. This will lead to an optimal pairing, because your pair of tasks with the longest duration will have the shortest duration that it can possibly have.\n</p>",
    ],
    customInputVars: [
      { name: 'k', example: 3, schema: { minimum: 1, type: 'integer' } },
      {
        name: 'tasks',
        example: [1, 3, 5, 3, 1, 4],
        schema: {
          items: { minimum: 1, type: 'integer' },
          minItems: 2,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function taskAssignment(k, tasks) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.taskAssignment = taskAssignment;\n',
      solutions: [
        '// O(nlog(n)) time | O(n) space - where n is the number of tasks\nfunction taskAssignment(k, tasks) {\n  const pairedTasks = [];\n  const taskDurationToIndices = getTaskDurationToIndices(tasks);\n\n  const sortedTasks = [...tasks].sort((a, b) => a - b);\n  for (let idx = 0; idx < k; idx++) {\n    const task1Duration = sortedTasks[idx];\n    const indicesWithTask1Duration = taskDurationToIndices[task1Duration];\n    const task1Index = indicesWithTask1Duration.pop();\n\n    const task2SortedIndex = tasks.length - 1 - idx;\n    const task2Duration = sortedTasks[task2SortedIndex];\n    const indicesWithTask2Duration = taskDurationToIndices[task2Duration];\n    const task2Index = indicesWithTask2Duration.pop();\n\n    pairedTasks.push([task1Index, task2Index]);\n  }\n\n  return pairedTasks;\n}\n\nfunction getTaskDurationToIndices(tasks) {\n  const taskDurationToIndices = {};\n\n  for (let idx = 0; idx < tasks.length; idx++) {\n    const taskDuration = tasks[idx];\n    if (taskDuration in taskDurationToIndices) {\n      taskDurationToIndices[taskDuration].push(idx);\n    } else {\n      taskDurationToIndices[taskDuration] = [idx];\n    }\n  }\n\n  return taskDurationToIndices;\n}\n\n// Do not edit the line below.\nexports.taskAssignment = taskAssignment;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const k = 3;\n  const tasks = [1, 3, 5, 3, 1, 4];\n  const expected = [\n    [4, 2],\n    [0, 5],\n    [3, 1],\n  ];\n  const actual = program.taskAssignment(k, tasks);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const k = 3;\n  const tasks = [1, 3, 5, 3, 1, 4];\n  const expected = [\n    [4, 2],\n    [0, 5],\n    [3, 1],\n  ];\n  const actual = program.taskAssignment(k, tasks);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlog(n)) time | O(n) space - where n is the number of tasks',
    tests: [
      { k: 3, tasks: [1, 3, 5, 3, 1, 4] },
      { k: 4, tasks: [1, 2, 3, 4, 5, 6, 7, 8] },
      { k: 5, tasks: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] },
      { k: 1, tasks: [3, 5] },
      { k: 7, tasks: [2, 1, 3, 4, 5, 13, 12, 9, 11, 10, 6, 7, 14, 8] },
      { k: 5, tasks: [3, 7, 5, 4, 4, 3, 6, 8, 3, 3] },
      {
        k: 10,
        tasks: [
          5, 6, 2, 3, 15, 15, 16, 19, 2, 10, 10, 3, 3, 32, 12, 1, 23, 32, 9, 2,
        ],
      },
      { k: 4, tasks: [1, 2, 2, 1, 3, 4, 4, 4] },
      { k: 3, tasks: [87, 65, 43, 32, 31, 320] },
      { k: 2, tasks: [3, 4, 5, 3] },
      { k: 3, tasks: [5, 2, 1, 6, 4, 4] },
      { k: 2, tasks: [1, 8, 9, 10] },
    ],
  },
  {
    id: 'valid-starting-city',
    name: 'Valid Starting City',
    category: 'Greedy Algorithms',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Imagine you have a set of cities that are laid out in a circle, connected by a\n  circular road that runs clockwise. Each city has a gas station that provides\n  gallons of fuel, and each city is some distance away from the next city.\n</p>\n<p>\n  You have a car that can drive some number of miles per gallon of fuel, and\n  your goal is to pick a starting city such that you can fill up your car with\n  that city\'s fuel, drive to the next city, refill up your car with that city\'s\n  fuel, drive to the next city, and so on and so forth until you return back to\n  the starting city with 0 or more gallons of fuel left.\n</p>\n<p>\n  This city is called a valid starting city, and it\'s guaranteed that there will\n  always be exactly one valid starting city.\n</p>\n<p>\n  For the actual problem, you\'ll be given an array of distances such that city\n  <span>i</span> is <span>distances[i]</span> away from city <span>i + 1</span>.\n  Since the cities are connected via a circular road, the last city is connected\n  to the first city. In other words, the last distance in the\n  <span>distances</span> array is equal to the distance from the last city to\n  the first city. You\'ll also be given an array of fuel available at each city,\n  where <span>fuel[i]</span> is equal to the fuel available at city\n  <span>i</span>. The total amount of fuel available (from all cities combined)\n  is exactly enough to travel to all cities. Your fuel tank always starts out\n  empty, and you\'re given a positive integer value for the number of miles that\n  your car can travel per gallon of fuel (miles per gallon, or MPG). You can\n  assume that you will always be given at least two cities.\n</p>\n<p>Write a function that returns the index of the valid starting city.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">distances</span> = [5, 25, 15, 10, 15]\n<span class="CodeEditor-promptParameter">fuel</span> = [1, 2, 1, 0, 3]\n<span class="CodeEditor-promptParameter">mpg</span> = 10\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4\n</pre>\n</div>',
    hints: [
      '<p>\n  Try the brute-force approach to this problem by treating each city as the\n  starting city and simulating traveling from it to all other cities.\n</p>\n',
      '\n<p>\n  Start at each city, and see if you can return back to the city in question\n  without running out of gas. If you find a city that you can return to after\n  starting at it without running out of gas, then it must be the valid starting\n  city, because there is always exactly one valid starting city.\n</p>\n',
      '\n<p>\n  You can solve this problem in <span>O(n)</span> time. Try to use the fact that\n  the amount of gas is exactly enough to travel around the road once to help\n  you.\n</p>\n',
      "\n<p>\n  Using the fact stated in Hint #3 and the knowledge that there is always\n  exactly one valid starting city, you can solve this problem in a single pass\n  of all cities. Keep track of how much gas you have as you enter a city (before\n  you fill up at that city); you'll enter the first city with 0 gas. The city\n  that you enter with the least amount of gas in your tank must be the valid\n  starting city. This is because you'll never have less gas at another city than\n  you do when you enter this city, no matter what city you start at. This means\n  that that this is the valid starting city. See the Conceptual Overview section\n  of this question's video explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'distances',
        example: [5, 25, 15, 10, 15],
        schema: {
          items: { minimum: 1, type: 'integer' },
          minItems: 2,
          type: 'array',
        },
      },
      {
        name: 'fuel',
        example: [1, 2, 1, 0, 3],
        schema: {
          items: { minimum: 0, type: 'integer' },
          minItems: 2,
          type: 'array',
        },
      },
      { name: 'mpg', example: 10, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function validStartingCity(distances, fuel, mpg) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.validStartingCity = validStartingCity;\n',
      solutions: [
        '// O(n^2) time | O(1) space - where n is the number of cities\nfunction validStartingCity(distances, fuel, mpg) {\n  const numberOfCities = distances.length;\n\n  for (let startCityIdx = 0; startCityIdx < numberOfCities; startCityIdx++) {\n    let milesRemaining = 0;\n\n    for (\n      let currentCityIdx = startCityIdx;\n      currentCityIdx < startCityIdx + numberOfCities;\n      currentCityIdx++\n    ) {\n      if (milesRemaining < 0) continue;\n\n      const currentCityIdxRotated = currentCityIdx % numberOfCities;\n\n      const fuelFromCurrentCity = fuel[currentCityIdxRotated];\n      const distanceToNextCity = distances[currentCityIdxRotated];\n      milesRemaining += fuelFromCurrentCity * mpg - distanceToNextCity;\n    }\n\n    if (milesRemaining >= 0) return startCityIdx;\n  }\n\n  // This line should never be reached if the inputs are correct.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.validStartingCity = validStartingCity;\n',
        '// O(n) time | O(1) space - where n is the number of cities\nfunction validStartingCity(distances, fuel, mpg) {\n  const numberOfCities = distances.length;\n  let milesRemaining = 0;\n\n  let indexOfStartingCityCandidate = 0;\n  let milesRemainingAtStartingCityCandidate = 0;\n\n  for (let cityIdx = 1; cityIdx < numberOfCities; cityIdx++) {\n    const distanceFromPreviousCity = distances[cityIdx - 1];\n    const fuelFromPreviousCity = fuel[cityIdx - 1];\n    milesRemaining += fuelFromPreviousCity * mpg - distanceFromPreviousCity;\n\n    if (milesRemaining < milesRemainingAtStartingCityCandidate) {\n      milesRemainingAtStartingCityCandidate = milesRemaining;\n      indexOfStartingCityCandidate = cityIdx;\n    }\n  }\n\n  return indexOfStartingCityCandidate;\n}\n\n// Do not edit the line below.\nexports.validStartingCity = validStartingCity;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const distances = [5, 25, 15, 10, 15];\n  const fuel = [1, 2, 1, 0, 3];\n  const mpg = 10;\n  const expected = 4;\n  const actual = program.validStartingCity(distances, fuel, mpg);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const distances = [5, 25, 15, 10, 15];\n  const fuel = [1, 2, 1, 0, 3];\n  const mpg = 10;\n  const expected = 4;\n  const actual = program.validStartingCity(distances, fuel, mpg);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of cities',
    tests: [
      { distances: [5, 25, 15, 10, 15], fuel: [1, 2, 1, 0, 3], mpg: 10 },
      {
        distances: [10, 20, 10, 15, 5, 15, 25],
        fuel: [0, 2, 1, 0, 0, 1, 1],
        mpg: 20,
      },
      { distances: [30, 25, 5, 100, 40], fuel: [3, 2, 1, 0, 4], mpg: 20 },
      {
        distances: [1, 3, 10, 6, 7, 7, 2, 4],
        fuel: [1, 1, 1, 1, 1, 1, 1, 1],
        mpg: 5,
      },
      { distances: [5, 2, 3], fuel: [1, 0, 1], mpg: 5 },
      { distances: [4, 6], fuel: [1, 9], mpg: 1 },
      {
        distances: [30, 40, 10, 10, 17, 13, 50, 30, 10, 40],
        fuel: [1, 2, 0, 1, 1, 0, 3, 1, 0, 1],
        mpg: 25,
      },
      {
        distances: [30, 40, 10, 10, 17, 13, 50, 30, 10, 40],
        fuel: [10, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        mpg: 25,
      },
      { distances: [15, 20, 25, 30, 35, 5], fuel: [0, 3, 0, 0, 1, 1], mpg: 26 },
      { distances: [10, 10, 10, 10], fuel: [1, 2, 3, 4], mpg: 4 },
    ],
  },
  {
    id: 'class-photos',
    name: 'Class Photos',
    category: 'Greedy Algorithms',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  It\'s photo day at the local school, and you\'re the photographer assigned to\n  take class photos. The class that you\'ll be photographing has an even number\n  of students, and all these students are wearing red or blue shirts. In fact,\n  exactly half of the class is wearing red shirts, and the other half is wearing\n  blue shirts. You\'re responsible for arranging the students in two rows before\n  taking the photo. Each row should contain the same number of the students and\n  should adhere to the following guidelines:\n</p>\n<ul>\n  <li>All students wearing red shirts must be in the same row.</li>\n  <li>All students wearing blue shirts must be in the same row.</li>\n  <li>\n    Each student in the back row must be strictly taller than the student\n    directly in front of them in the front row.\n  </li>\n</ul>\n<p>\n  You\'re given two input arrays: one containing the heights of all the students\n  with red shirts and another one containing the heights of all the students\n  with blue shirts. These arrays will always have the same length, and each\n  height will be a positive integer. Write a function that returns whether or\n  not a class photo that follows the stated guidelines can be taken.\n</p>\n<p>Note: you can assume that each class has at least 2 students.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">redShirtHeights</span> = [5, 8, 1, 3, 4]\n<span class="CodeEditor-promptParameter">blueShirtHeights</span> = [6, 9, 2, 4, 5]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue <span class="CodeEditor-promptComment">// Place all students with blue shirts in the back row.</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  Start by determining which row will have the students wearing blue shirts and\n  which row will have the students wearing red shirts. Once you know this, how\n  can you determine if it's possible to take the photo?\n</p>\n",
      "\n<p>\n  The shirt color of the tallest student will determine which students need to\n  be placed in the back row. The tallest student can't be placed in the front\n  row because there's no student taller than them who can be placed behind them.\n</p>\n",
      "\n<p>\n  Once you know which students should be placed in each row, you can simply\n  check if each student in the back row can be paired with a student in the\n  front row who is shorter than them. If you can't find a satisfactory pairing\n  for every student in the back row, then you can't take the photo.\n</p>\n",
      "\n<p>\n  Sort each input array in descending order, then determine which students will\n  be in the front and back rows following Hint #2. After this, simply loop\n  through your sorted input arrays, and check if the current tallest student in\n  the back row is taller than the current tallest student in the front row. If\n  you find that the current tallest student (one that has yet to be placed) in\n  the back row isn't taller than the current tallest student in the front row,\n  then the photo can't be taken.\n</p>",
    ],
    customInputVars: [
      {
        name: 'redShirtHeights',
        example: [5, 8, 1, 3, 4],
        schema: {
          items: { minimum: 1, type: 'integer' },
          minItems: 1,
          type: 'array',
        },
      },
      {
        name: 'blueShirtHeights',
        example: [6, 9, 2, 4, 5],
        schema: {
          items: { minimum: 1, type: 'integer' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function classPhotos(redShirtHeights, blueShirtHeights) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.classPhotos = classPhotos;\n',
      solutions: [
        "// O(nlog(n)) time | O(1) space - where n is the number of students\nfunction classPhotos(redShirtHeights, blueShirtHeights) {\n  redShirtHeights.sort((a, b) => b - a);\n  blueShirtHeights.sort((a, b) => b - a);\n\n  const shirtColorInFirstRow = redShirtHeights[0] < blueShirtHeights[0] ? 'RED' : 'BLUE';\n  for (let idx = 0; idx < redShirtHeights.length; idx++) {\n    const redShirtHeight = redShirtHeights[idx];\n    const blueShirtHeight = blueShirtHeights[idx];\n\n    if (shirtColorInFirstRow === 'RED') {\n      if (redShirtHeight >= blueShirtHeight) return false;\n    } else if (blueShirtHeight >= redShirtHeight) return false;\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.classPhotos = classPhotos;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const redShirtHeights = [5, 8, 1, 3, 4];\n  const blueShirtHeights = [6, 9, 2, 4, 5];\n  const expected = true;\n  const actual = program.classPhotos(redShirtHeights, blueShirtHeights);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const redShirtHeights = [5, 8, 1, 3, 4];\n  const blueShirtHeights = [6, 9, 2, 4, 5];\n  const expected = true;\n  const actual = program.classPhotos(redShirtHeights, blueShirtHeights);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlog(n)) time | O(1) space - where n is the number of students',
    tests: [
      { blueShirtHeights: [6, 9, 2, 4, 5], redShirtHeights: [5, 8, 1, 3, 4] },
      { blueShirtHeights: [5, 8, 1, 3, 4], redShirtHeights: [6, 9, 2, 4, 5] },
      {
        blueShirtHeights: [5, 8, 1, 3, 4, 9],
        redShirtHeights: [6, 9, 2, 4, 5, 1],
      },
      { blueShirtHeights: [6], redShirtHeights: [6] },
      { blueShirtHeights: [125], redShirtHeights: [126] },
      { blueShirtHeights: [2, 3, 4, 5, 6], redShirtHeights: [1, 2, 3, 4, 5] },
      {
        blueShirtHeights: [5, 6, 7, 2, 3, 1, 2, 3],
        redShirtHeights: [1, 1, 1, 1, 1, 1, 1, 1],
      },
      {
        blueShirtHeights: [2, 2, 2, 2, 2, 2, 2, 2],
        redShirtHeights: [1, 1, 1, 1, 1, 1, 1, 1],
      },
      { blueShirtHeights: [126], redShirtHeights: [125] },
      {
        blueShirtHeights: [21, 5, 4, 4, 4, 4, 4, 4, 4],
        redShirtHeights: [19, 2, 4, 6, 2, 3, 1, 1, 4],
      },
      {
        blueShirtHeights: [20, 5, 4, 4, 4, 4, 4, 4],
        redShirtHeights: [19, 19, 21, 1, 1, 1, 1, 1],
      },
      { blueShirtHeights: [2, 4, 7, 5, 1], redShirtHeights: [3, 5, 6, 8, 2] },
      {
        blueShirtHeights: [2, 4, 7, 5, 1, 6],
        redShirtHeights: [3, 5, 6, 8, 2, 1],
      },
      { blueShirtHeights: [5, 4], redShirtHeights: [4, 5] },
      { blueShirtHeights: [5, 4], redShirtHeights: [5, 6] },
    ],
  },
  {
    id: 'tandem-bicycle',
    name: 'Tandem Bicycle',
    category: 'Greedy Algorithms',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  A tandem bicycle is a bicycle that\'s operated by two people: person A and\n  person B. Both people pedal the bicycle, but the person that pedals faster\n  dictates the speed of the bicycle. So if person A pedals at a speed of\n  <span>5</span>, and person B pedals at a speed of <span>4</span>, the tandem\n  bicycle moves at a speed of <span>5</span> (i.e.,\n  <span>tandemSpeed = max(speedA, speedB)</span>).\n</p>\n<p>\n  You\'re given two lists of positive integers: one that contains the speeds of\n  riders wearing red shirts and one that contains the speeds of riders wearing\n  blue shirts. Each rider is represented by a single positive integer, which is\n  the speed that they pedal a tandem bicycle at. Both lists have the same\n  length, meaning that there are as many red-shirt riders as there are\n  blue-shirt riders. Your goal is to pair every rider wearing a red shirt with a\n  rider wearing a blue shirt to operate a tandem bicycle.\n</p>\n<p>\n  Write a function that returns the maximum possible total speed or the minimum\n  possible total speed of all of the tandem bicycles being ridden based on an\n  input parameter, <span>fastest</span>. If <span>fastest = true</span>, your\n  function should return the maximum possible total speed; otherwise it should\n  return the minimum total speed.\n</p>\n<p>\n  "Total speed" is defined as the sum of the speeds of all the tandem bicycles\n  being ridden. For example, if there are 4 riders (2 red-shirt riders and 2\n  blue-shirt riders) who have speeds of <span>1, 3, 4, 5</span>, and if they\'re\n  paired on tandem bicycles as follows: <span>[1, 4], [5, 3]</span>, then the\n  total speed of these tandem bicycles is <span>4 + 5 = 9</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">redShirtSpeeds</span> = [5, 5, 3, 9, 2]\n<span class="CodeEditor-promptParameter">blueShirtSpeeds</span> = [3, 6, 7, 2, 1] \n<span class="CodeEditor-promptParameter">fastest</span> = true\n</pre>\n<h3>Sample Output</h3>\n<pre>\n32\n</pre>\n</div>',
    hints: [
      "<p>\n  The brute-force approach to solve this problem is to generate every possible\n  set of pairs of riders and to determine the total speed that each of these\n  sets generates. This solution does work but, it isn't optimal. Can you think\n  of a better way to solve this problem?\n</p>\n",
      '\n<p>\n  Try looking at the input arrays in sorted order. How might this help you solve\n  the problem?\n</p>\n',
      '\n<p>\n  When generating the maximum total speed, you want to pair the slowest\n  red-shirt riders with the fastest blue-shirt riders and vice versa, so as to\n  always take advantage of the largest speeds. When generating the minimum total\n  speed, you want to pair the fastest red-shirt riders with the fastest\n  blue-shirt riders, so as to "eliminate" a large speed by pairing it with a\n  another large (larger) speed.\n</p>\n',
      '\n<p>\n  Sort the input arrays in place, and follow the strategy discussed in Hint #3.\n  With the inputs sorted, you can find the slowest and largest speeds from each\n  shirt color in constant time.\n</p>',
    ],
    customInputVars: [
      {
        name: 'redShirtSpeeds',
        example: [5, 5, 3, 9, 2],
        schema: { items: { minimum: 1, type: 'integer' }, type: 'array' },
      },
      {
        name: 'blueShirtSpeeds',
        example: [3, 6, 7, 2, 1],
        schema: { items: { minimum: 1, type: 'integer' }, type: 'array' },
      },
      { name: 'fastest', example: true, schema: { type: 'boolean' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function tandemBicycle(redShirtSpeeds, blueShirtSpeeds, fastest) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.tandemBicycle = tandemBicycle;\n',
      solutions: [
        '// O(nlog(n)) time | O(1) space - where n is the number of tandem bicycles\nfunction tandemBicycle(redShirtSpeeds, blueShirtSpeeds, fastest) {\n  redShirtSpeeds.sort((a, b) => a - b);\n  blueShirtSpeeds.sort((a, b) => a - b);\n\n  if (!fastest) reverseArrayInPlace(redShirtSpeeds);\n\n  let totalSpeed = 0;\n  for (let idx = 0; idx < redShirtSpeeds.length; idx++) {\n    const rider1 = redShirtSpeeds[idx];\n    const rider2 = blueShirtSpeeds[blueShirtSpeeds.length - idx - 1];\n    totalSpeed += Math.max(rider1, rider2);\n  }\n\n  return totalSpeed;\n}\n\nfunction reverseArrayInPlace(array) {\n  let start = 0;\n  let end = array.length - 1;\n  while (start < end) {\n    const temp = array[start];\n    array[start] = array[end];\n    array[end] = temp;\n    start++;\n    end--;\n  }\n}\n\n// Do not edit the line below.\nexports.tandemBicycle = tandemBicycle;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const redShirtSpeeds = [5, 5, 3, 9, 2];\n  const blueShirtSpeeds = [3, 6, 7, 2, 1];\n  const fastest = true;\n  const expected = 32;\n  const actual = program.tandemBicycle(redShirtSpeeds, blueShirtSpeeds, fastest);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const redShirtSpeeds = [5, 5, 3, 9, 2];\n  const blueShirtSpeeds = [3, 6, 7, 2, 1];\n  const fastest = true;\n  const expected = 32;\n  const actual = program.tandemBicycle(redShirtSpeeds, blueShirtSpeeds, fastest);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(nlog(n)) time | O(1) space - where n is the number of tandem bicycles',
    tests: [
      {
        blueShirtSpeeds: [3, 6, 7, 2, 1],
        fastest: true,
        redShirtSpeeds: [5, 5, 3, 9, 2],
      },
      {
        blueShirtSpeeds: [3, 6, 7, 2, 1],
        fastest: false,
        redShirtSpeeds: [5, 5, 3, 9, 2],
      },
      {
        blueShirtSpeeds: [3, 3, 4, 6, 1, 2],
        fastest: false,
        redShirtSpeeds: [1, 2, 1, 9, 12, 3],
      },
      {
        blueShirtSpeeds: [3, 3, 4, 6, 1, 2],
        fastest: true,
        redShirtSpeeds: [1, 2, 1, 9, 12, 3],
      },
      {
        blueShirtSpeeds: [3, 3, 4, 6, 1, 2, 5, 6, 34, 256, 123, 32],
        fastest: true,
        redShirtSpeeds: [1, 2, 1, 9, 12, 3, 1, 54, 21, 231, 32, 1],
      },
      {
        blueShirtSpeeds: [3, 3, 4, 6, 1, 2, 5, 6, 34, 256, 123, 32],
        fastest: false,
        redShirtSpeeds: [1, 2, 1, 9, 12, 3, 1, 54, 21, 231, 32, 1],
      },
      { blueShirtSpeeds: [5], fastest: true, redShirtSpeeds: [1] },
      { blueShirtSpeeds: [5], fastest: false, redShirtSpeeds: [1] },
      {
        blueShirtSpeeds: [1, 1, 1, 1],
        fastest: true,
        redShirtSpeeds: [1, 1, 1, 1],
      },
      {
        blueShirtSpeeds: [1, 1, 1, 1],
        fastest: false,
        redShirtSpeeds: [1, 1, 1, 1],
      },
      {
        blueShirtSpeeds: [1, 1, 1, 1, 3, 3, 3, 3, 5, 7],
        fastest: true,
        redShirtSpeeds: [1, 1, 1, 1, 2, 2, 2, 2, 9, 11],
      },
      {
        blueShirtSpeeds: [1, 1, 1, 1, 3, 3, 3, 3, 5, 7],
        fastest: false,
        redShirtSpeeds: [1, 1, 1, 1, 2, 2, 2, 2, 9, 11],
      },
      {
        blueShirtSpeeds: [3, 4, 4, 1, 1, 8, 9],
        fastest: true,
        redShirtSpeeds: [9, 8, 2, 2, 3, 5, 6],
      },
      {
        blueShirtSpeeds: [3, 4, 4, 1, 1, 8, 9],
        fastest: false,
        redShirtSpeeds: [9, 8, 2, 2, 3, 5, 6],
      },
      {
        blueShirtSpeeds: [1, 2, 3, 4, 5],
        fastest: false,
        redShirtSpeeds: [5, 4, 3, 2, 1],
      },
      {
        blueShirtSpeeds: [1, 2, 3, 4, 5],
        fastest: true,
        redShirtSpeeds: [5, 4, 3, 2, 1],
      },
      { blueShirtSpeeds: [], fastest: true, redShirtSpeeds: [] },
    ],
  },
  {
    id: 'nth-fibonacci',
    name: 'Nth Fibonacci',
    category: 'Recursion',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  The Fibonacci sequence is defined as follows: the first number of the sequence\n  is <span>0</span>, the second number is <span>1</span>, and the nth number is the sum of the (n - 1)th\n  and (n - 2)th numbers. Write a function that takes in an integer\n  <span>n</span> and returns the nth Fibonacci number.\n</p>\n<p>\n  Important note: the Fibonacci sequence is often defined with its first two\n  numbers as <span>F0 = 0</span> and <span>F1 = 1</span>. For the purpose of\n  this question, the first Fibonacci number is <span>F0</span>; therefore,\n  <span>getNthFib(1)</span> is equal to <span>F0</span>, <span>getNthFib(2)</span>\n  is equal to <span>F1</span>, etc..\n</p>\n<h3>Sample Input #1</h3>\n<pre>\n<span class="CodeEditor-promptParameter">n</span> = 2\n</pre>\n<h3>Sample Output #1</h3>\n<pre>\n1 <span class="CodeEditor-promptComment">// 0, 1</span>\n</pre>\n<h3>Sample Input #2</h3>\n<pre>\n<span class="CodeEditor-promptParameter">n</span> = 6\n</pre>\n<h3>Sample Output #2</h3>\n<pre>\n5 <span class="CodeEditor-promptComment">// 0, 1, 1, 2, 3, 5</span>\n</pre>\n</div>',
    hints: [
      "<p>\nThe formula to generate the nth Fibonacci number can be written as follows: F(n) = F(n - 1) + F(n - 2). Think of the case(s) for which this formula doesn't apply (the base case(s)) and try to implement a simple recursive algorithm to find the nth Fibonacci number with this formula.\n</p>\n",
      '\n<p>\nWhat are the runtime implications of solving this problem as is described in Hint #1? Can you use memoization (caching) to improve the performance of your algorithm?\n</p>\n',
      '\n<p>\nRealize that to calculate any single Fibonacci number you only need to have the two previous Fibonacci numbers. Knowing this, can you implement an iterative algorithm to solve this question, storing only the last two Fibonacci numbers at any given time?\n</p>',
    ],
    customInputVars: [
      { name: 'n', example: 6, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function getNthFib(n) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.getNthFib = getNthFib;\n',
      solutions: [
        '// O(2^n) time | O(n) space\nfunction getNthFib(n) {\n  if (n === 2) {\n    return 1;\n  } else if (n === 1) {\n    return 0;\n  } else {\n    return getNthFib(n - 1) + getNthFib(n - 2);\n  }\n}\n\nexports.getNthFib = getNthFib;\n',
        '// O(n) time | O(n) space\nfunction getNthFib(n, memoize = {1: 0, 2: 1}) {\n  if (n in memoize) {\n    return memoize[n];\n  } else {\n    memoize[n] = getNthFib(n - 1, memoize) + getNthFib(n - 2, memoize);\n    return memoize[n];\n  }\n}\n\nexports.getNthFib = getNthFib;\n',
        '// O(n) time | O(1) space\nfunction getNthFib(n) {\n  const lastTwo = [0, 1];\n  let counter = 3;\n  while (counter <= n) {\n    const nextFib = lastTwo[0] + lastTwo[1];\n    lastTwo[0] = lastTwo[1];\n    lastTwo[1] = nextFib;\n    counter++;\n  }\n  return n > 1 ? lastTwo[1] : lastTwo[0];\n}\n\nexports.getNthFib = getNthFib;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.getNthFib(6)).to.deep.equal(5);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.getNthFib(6)).to.deep.equal(5);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the input number',
    tests: [
      { n: 6 },
      { n: 1 },
      { n: 2 },
      { n: 3 },
      { n: 4 },
      { n: 5 },
      { n: 7 },
      { n: 8 },
      { n: 9 },
      { n: 10 },
      { n: 11 },
      { n: 12 },
      { n: 13 },
      { n: 14 },
      { n: 15 },
      { n: 16 },
      { n: 17 },
      { n: 18 },
    ],
  },
  {
    id: 'permutations',
    name: 'Permutations',
    category: 'Recursion',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of unique integers and returns an\n  array of all permutations of those integers in no particular order.\n</p>\n<p>If the input array is empty, the function should return an empty array.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 2, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</pre>\n</div>',
    hints: [
      '<p>\nA permutation is defined as a way in which a set of things can be ordered. Thus, for the list [1, 2, 3], there exist some permutations starting with 1, some starting with 2, and some starting with 3. For the permutations starting with 1, there will be a permutation where 2 is the second number and one where 3 is the second number. For permutations starting with 3, there will be a permutation where 1 is the second number and one where 2 is the second number. The idea is that, in order to construct a permutation, we can pick a random number from our list to be the first number, then we can pick a random number from the remaining list (without the first number) to be the second number, then we can pick a random number from the remaining list (without the first and second numbers) to be the third number, and we can repeat the process until we exhaust all of our list of numbers. At that point, we will have constructed a valid permutation. How can we implement this construction algorithmically, without picking numbers at random?\n</p>\n',
      "\n<p>\nIterate through the list of numbers, and begin constructing new permutations starting with each number. For each permutation that you've begun constructing, remove the number already used (the first number of each permutation) from the list of numbers - you'll likely have to make copies of the original list. Repeat this process by recursively iterating through the mutated lists of numbers, appending numbers to the corresponding permutations you've already begun constructing and then removing those numbers from the respective mutated lists; repeat this until your mutated lists are empty, at which point your constructed permutations will be as big as the original list and will be valid permutations.\n</p>\n",
      '\n<p>\nDo you have to create so many mutated lists of numbers? Can you come up with an alternative approach that would allow you to only rely on the original list of numbers, without ever copying it and without removing numbers from it?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 2, 3],
        schema: {
          items: { type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function getPermutations(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.getPermutations = getPermutations;\n',
      solutions: [
        '// Upper Bound: O(n^2*n!) time | O(n*n!) space\n// Roughly: O(n*n!) time | O(n*n!) space\nfunction getPermutations(array) {\n  const permutations = [];\n  permutationsHelper(array, [], permutations);\n  return permutations;\n}\n\nfunction permutationsHelper(array, currentPermutation, permutations) {\n  if (!array.length && currentPermutation.length) {\n    permutations.push(currentPermutation);\n  } else {\n    for (let i = 0; i < array.length; i++) {\n      const newArray = array.slice(0, i).concat(array.slice(i + 1));\n      const newPermutation = currentPermutation.concat([array[i]]);\n      permutationsHelper(newArray, newPermutation, permutations);\n    }\n  }\n}\n\nexports.getPermutations = getPermutations;\n',
        '// O(n*n!) time | O(n*n!) space\nfunction getPermutations(array) {\n  const permutations = [];\n  permutationsHelper(0, array, permutations);\n  return permutations;\n}\n\nfunction permutationsHelper(i, array, permutations) {\n  if (i === array.length - 1) {\n    permutations.push(array.slice());\n  } else {\n    for (let j = i; j < array.length; j++) {\n      swap(i, j, array);\n      permutationsHelper(i + 1, array, permutations);\n      swap(i, j, array);\n    }\n  }\n}\n\nfunction swap(i, j, array) {\n  const temp = array[i];\n  array[i] = array[j];\n  array[j] = temp;\n}\n\nexports.getPermutations = getPermutations;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const perms = program.getPermutations([1, 2, 3]);\n  chai.expect(perms.length).to.deep.equal(6);\n  chai.expect(perms).to.deep.include([1, 2, 3]);\n  chai.expect(perms).to.deep.include([1, 3, 2]);\n  chai.expect(perms).to.deep.include([2, 1, 3]);\n  chai.expect(perms).to.deep.include([2, 3, 1]);\n  chai.expect(perms).to.deep.include([3, 1, 2]);\n  chai.expect(perms).to.deep.include([3, 2, 1]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const perms = program.getPermutations([1, 2, 3]);\n  chai.expect(perms.length).to.deep.equal(6);\n  chai.expect(perms).to.deep.include([1, 2, 3]);\n  chai.expect(perms).to.deep.include([1, 3, 2]);\n  chai.expect(perms).to.deep.include([2, 1, 3]);\n  chai.expect(perms).to.deep.include([2, 3, 1]);\n  chai.expect(perms).to.deep.include([3, 1, 2]);\n  chai.expect(perms).to.deep.include([3, 2, 1]);\n});\n",
    },
    bigO: 'O(n*n!) time | O(n*n!) space - where n is the length of the input array',
    tests: [
      { array: [1, 2, 3] },
      { array: [] },
      { array: [1] },
      { array: [1, 2] },
      { array: [1, 2, 3, 4] },
      { array: [1, 2, 3, 4, 5] },
    ],
  },
  {
    id: 'powerset',
    name: 'Powerset',
    category: 'Recursion',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of unique integers and returns its\n  powerset.\n</p>\n<p>\n  The powerset <span>P(X)</span> of a set <span>X</span> is the set of all\n  subsets of <span>X</span>. For example, the powerset of <span>[1,2]</span> is\n  <span>[[], [1], [2], [1,2]]</span>.\n</p>\n<p>\n  Note that the sets in the powerset do not need to be in any particular order.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [1, 2, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n</pre>\n</div>',
    hints: [
      '<p>\nTry thinking about the base cases. What is the powerset of the empty set? What is the powerset of sets of length 1?\n</p>\n',
      '\n<p>\nIf you were to take the input set X and add an element to it, how would the resulting powerset change?\n</p>\n',
      '\n<p>\nCan you solve this problem recursively? Can you solve it iteratively? What are the advantages and disadvantages of using either approach?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [1, 2, 3],
        schema: {
          items: { type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function powerset(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.powerset = powerset;\n',
      solutions: [
        '// O(n*2^n) time | O(n*2^n) space\nfunction powerset(array, idx = null) {\n  if (idx === null) {\n    idx = array.length - 1;\n  }\n  if (idx < 0) {\n    return [[]];\n  }\n  const ele = array[idx];\n  const subsets = powerset(array, idx - 1);\n  const length = subsets.length;\n  for (let i = 0; i < length; i++) {\n    const currentSubset = subsets[i];\n    subsets.push(currentSubset.concat(ele));\n  }\n  return subsets;\n}\n\nexports.powerset = powerset;\n',
        '// O(n*2^n) time | O(n*2^n) space\nfunction powerset(array) {\n  const subsets = [[]];\n  for (const ele of array) {\n    const length = subsets.length;\n    for (let i = 0; i < length; i++) {\n      const currentSubset = subsets[i];\n      subsets.push(currentSubset.concat(ele));\n    }\n  }\n  return subsets;\n}\n\nexports.powerset = powerset;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nfunction sortAndStringify(array) {\n  return array.sort((a, b) => a - b).join(',');\n}\n\nit('Test Case #1', function () {\n  const output = program.powerset([1, 2, 3]).map(sortAndStringify);\n  chai.expect(output.length === 8).to.be.true;\n  chai.expect(output).to.include('');\n  chai.expect(output).to.include('1');\n  chai.expect(output).to.include('2');\n  chai.expect(output).to.include('1,2');\n  chai.expect(output).to.include('3');\n  chai.expect(output).to.include('1,3');\n  chai.expect(output).to.include('2,3');\n  chai.expect(output).to.include('1,2,3');\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nfunction sortAndStringify(array) {\n  return array.sort((a, b) => a - b).join(',');\n}\n\nit('Test Case #1', function () {\n  const output = program.powerset([1, 2, 3]).map(sortAndStringify);\n  chai.expect(output.length === 8).to.be.true;\n  chai.expect(output).to.include('');\n  chai.expect(output).to.include('1');\n  chai.expect(output).to.include('2');\n  chai.expect(output).to.include('1,2');\n  chai.expect(output).to.include('3');\n  chai.expect(output).to.include('1,3');\n  chai.expect(output).to.include('2,3');\n  chai.expect(output).to.include('1,2,3');\n});\n",
    },
    bigO: 'O(n*2^n) time | O(n*2^n) space - where n is the length of the input array',
    tests: [
      { array: [1, 2, 3] },
      { array: [] },
      { array: [1] },
      { array: [1, 2] },
      { array: [1, 2, 3, 4] },
      { array: [1, 2, 3, 4, 5] },
      { array: [1, 2, 3, 4, 5, 6] },
    ],
  },
  {
    id: 'number-of-binary-tree-topologies',
    name: 'Number Of Binary Tree Topologies',
    category: 'Recursion',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-negative integer <span>n</span> and\n  returns the number of possible Binary Tree topologies that can be created with\n  exactly n nodes.\n</p>\n<p>\n  A Binary Tree topology is defined as any Binary Tree configuration,\n  irrespective of node values. For instance, there exist only two Binary Tree\n  topologies when <span>n</span> is equal to <span>2</span>: a root node with a\n  left node, and a root node with a right node.\n</p>\n<p>\n  Note that when <span>n</span> is equal to <span>0</span>, there\'s one topology\n  that can be created: the <span>None</span> / <span>null</span> node.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">n</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5\n</pre>\n</div>',
    hints: [
      '<p>\nEvery Binary Tree topology of n nodes where n is greater than 0 must have a root node and an amount of nodes on both of its sides totaling n - 1. For instance, one such topology could have a root node, n - 3 nodes in its left subtree, and 2 nodes in its right subtree. Another one could have a root node, 4 nodes in its left subtree, and n - 3 nodes in its right subtree. How many distinct Binary Tree topologies with a root node, a left subtree of x nodes, and a right subtree of n - 1 - x nodes are there?\n</p>\n',
      "\n<p>\nConsider a Binary Tree topology of n nodes with a root node, x nodes in its left subtree, and n - 1 - x nodes in its right subtree, and call this topology T1. This is one of possibly many topologies of n nodes. Realize that for every distinct topology T-Lk of x nodes (i.e. for every distinct topology of T1's left subtree) there is a corresponding, distinct topology of as many nodes as T1. Similarly, for every distinct topology T-Rk of n - 1 - x nodes (i.e. for every distinct topology of T1's right subtree) there is a corresponding, distinct topology of as many nodes as T1. In fact, every unique combination of left and right topologies T-Lk and T-Rk forms a distinct topology of as many nodes as T1, and this is true for every x between 0 and n - 1. Realizing this, can you implement a recursive algorithm that solves this problem?\n</p>\n",
      '\n<p>\nIterate through every number x between 0 and n - 1 inclusive; at every number x, recursively calculate the number of distinct topologies of x nodes and multiply that by the number of distinct topologies of n - 1 - x nodes. Sum all of the products that you calculate to find the total number of distinct topologies of n nodes.\n</p>\n',
      '\n<p>\nCan you improve the recursive algorithm mentioned in Hints #2 and #3 by using a caching system (memoization)? Can you implement the algorithm iteratively? Is there any advantage to doing so?\n</p>',
    ],
    customInputVars: [
      { name: 'n', example: 3, schema: { minimum: 0, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function numberOfBinaryTreeTopologies(n) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.numberOfBinaryTreeTopologies = numberOfBinaryTreeTopologies;\n',
      solutions: [
        '// Upper Bound: O((n*(2n)!)/(n!(n+1)!)) time | O(n) space\nfunction numberOfBinaryTreeTopologies(n) {\n  if (n === 0) return 1;\n  let numberOfTrees = 0;\n  for (let leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n    const rightTreeSize = n - 1 - leftTreeSize;\n    const numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize);\n    const numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize);\n    numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n  }\n  return numberOfTrees;\n}\n\nexports.numberOfBinaryTreeTopologies = numberOfBinaryTreeTopologies;\n',
        '// O(n^2) time | O(n) space\nfunction numberOfBinaryTreeTopologies(n, cache = {0: 1}) {\n  if (n in cache) return cache[n];\n  let numberOfTrees = 0;\n  for (let leftTreeSize = 0; leftTreeSize < n; leftTreeSize++) {\n    const rightTreeSize = n - 1 - leftTreeSize;\n    const numberOfLeftTrees = numberOfBinaryTreeTopologies(leftTreeSize, cache);\n    const numberOfRightTrees = numberOfBinaryTreeTopologies(rightTreeSize, cache);\n    numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n  }\n  cache[n] = numberOfTrees;\n  return numberOfTrees;\n}\n\nexports.numberOfBinaryTreeTopologies = numberOfBinaryTreeTopologies;\n',
        '// O(n^2) time | O(n) space\nfunction numberOfBinaryTreeTopologies(n) {\n  const cache = [1];\n  for (let m = 1; m < n + 1; m++) {\n    let numberOfTrees = 0;\n    for (let leftTreeSize = 0; leftTreeSize < m; leftTreeSize++) {\n      const rightTreeSize = m - 1 - leftTreeSize;\n      const numberOfLeftTrees = cache[leftTreeSize];\n      const numberOfRightTrees = cache[rightTreeSize];\n      numberOfTrees += numberOfLeftTrees * numberOfRightTrees;\n    }\n    cache.push(numberOfTrees);\n  }\n  return cache[n];\n}\n\nexports.numberOfBinaryTreeTopologies = numberOfBinaryTreeTopologies;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.numberOfBinaryTreeTopologies(3)).to.deep.equal(5);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.numberOfBinaryTreeTopologies(3)).to.deep.equal(5);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the input number',
    tests: [
      { n: 3 },
      { n: 0 },
      { n: 1 },
      { n: 2 },
      { n: 4 },
      { n: 5 },
      { n: 6 },
      { n: 7 },
      { n: 8 },
      { n: 9 },
      { n: 10 },
      { n: 11 },
    ],
  },
  {
    id: 'lowest-common-manager',
    name: 'Lowest Common Manager',
    category: 'Recursion',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given three inputs, all of which are instances of an\n  <span>OrgChart</span> class that have a <span>directReports</span> property\n  pointing to their direct reports. The first input is the top manager in an\n  organizational chart (i.e., the only instance that isn\'t anybody else\'s direct\n  report), and the other two inputs are reports in the organizational chart. The\n  two reports are guaranteed to be distinct.\n</p>\n<p>\n  Write a function that returns the lowest common manager to the two reports.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptComment">// From the organizational chart below.</span>\n<span class="CodeEditor-promptParameter">topManager</span> = Node A\n<span class="CodeEditor-promptParameter">reportOne</span> = Node E\n<span class="CodeEditor-promptParameter">reportTwo</span> = Node I\n          A\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      B       C\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   D     E F     G\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\nH     I\n</pre>\n<h3>Sample Output</h3>\n<pre>\nNode B\n</pre>\n</div>',
    hints: [
      '<p>\nGiven a random subtree in the organizational chart, the manager at the root of that subtree is common to any two reports in the subtree.\n</p>\n',
      '\n<p>\nKnowing Hint #1, the lowest common manager to two reports in an organizational chart is the root of the lowest subtree containing those two reports. Find that lowest subtree to find the lowest common manager.\n</p>\n',
      '\n<p>\nTo find the lowest subtree containing both of the input reports, try recursively traversing the organizational chart and keeping track of the number of those reports contained in each subtree as well as the lowest common manager in each subtree. Some subtrees might contain neither of the two reports, some might contain one of them, and others might contain both; the first to contain both should return the lowest common manager for all of the subtrees above it that contain it, including the entire organizational chart.\n</p>',
    ],
    customInputVars: [
      { name: 'topManager', example: 'A', schema: { type: 'string' } },
      { name: 'reportOne', example: 'E', schema: { type: 'string' } },
      { name: 'reportTwo', example: 'I', schema: { type: 'string' } },
      {
        name: 'orgChart',
        example: {
          nodes: [
            { directReports: ['B', 'C'], id: 'A', name: 'A' },
            { directReports: ['D', 'E'], id: 'B', name: 'B' },
            { directReports: ['F', 'G'], id: 'C', name: 'C' },
            { directReports: ['H', 'I'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: [], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: [], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
          ],
        },
        schema: {
          description:
            "An <span>OrgChart</span> is represented by a list of <span>nodes</span>. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' lists of <span>directReports</span> and by the\n<span>topManager</span>, the <span>reportOne</span>, and the <span>reportTwo</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  directReports: {
                    items: { type: 'string' },
                    type: 'array',
                    uniqueItems: true,
                  },
                  id: { type: 'string' },
                  name: { type: 'string' },
                },
                required: ['id', 'name', 'directReports'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function getLowestCommonManager(topManager, reportOne, reportTwo) {\n  // Write your code here.\n}\n\n// This is an input class. Do not edit.\nclass OrgChart {\n  constructor(name) {\n    this.name = name;\n    this.directReports = [];\n  }\n}\n\n// Do not edit the line below.\nexports.getLowestCommonManager = getLowestCommonManager;\n',
      solutions: [
        '// O(n) time | O(d) space - where n is the number of people\n// in the org and d is the depth (height) of the org chart\nfunction getLowestCommonManager(topManager, reportOne, reportTwo) {\n  return getOrgInfo(topManager, reportOne, reportTwo).lowestCommonManager;\n}\n\nfunction getOrgInfo(manager, reportOne, reportTwo) {\n  let numImportantReports = 0;\n  for (const directReport of manager.directReports) {\n    const orgInfo = getOrgInfo(directReport, reportOne, reportTwo);\n    if (!!orgInfo.lowestCommonManager) return orgInfo;\n    numImportantReports += orgInfo.numImportantReports;\n  }\n  if (manager === reportOne || manager === reportTwo) numImportantReports++;\n  const lowestCommonManager = numImportantReports === 2 ? manager : null;\n  return {lowestCommonManager, numImportantReports};\n}\n\n// This is the input class.\nclass OrgChart {\n  constructor(name) {\n    this.name = name;\n    this.directReports = [];\n  }\n}\n\nexports.getLowestCommonManager = getLowestCommonManager;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass OrgChart {\n  constructor(name) {\n    this.name = name;\n    this.directReports = [];\n  }\n\n  addDirectReports(directReports) {\n    for (const directReport of directReports) {\n      this.directReports.push(directReport);\n    }\n  }\n}\n\nfunction getOrgCharts() {\n  const orgCharts = {};\n  const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n  for (const letter of ALPHABET) {\n    orgCharts[letter] = new OrgChart(letter);\n  }\n  return orgCharts;\n}\n\nit('Test Case #1', function () {\n  const orgCharts = getOrgCharts();\n  orgCharts['A'].addDirectReports([orgCharts['B'], orgCharts['C']]);\n  orgCharts['B'].addDirectReports([orgCharts['D'], orgCharts['E']]);\n  orgCharts['C'].addDirectReports([orgCharts['F'], orgCharts['G']]);\n  orgCharts['D'].addDirectReports([orgCharts['H'], orgCharts['I']]);\n\n  const lcm = program.getLowestCommonManager(orgCharts.A, orgCharts.A, orgCharts.B);\n  chai.expect(lcm).to.deep.equal(orgCharts.A);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass OrgChart {\n  constructor(name) {\n    this.name = name;\n    this.directReports = [];\n  }\n\n  addDirectReports(directReports) {\n    for (const directReport of directReports) {\n      this.directReports.push(directReport);\n    }\n  }\n}\n\nfunction getOrgCharts() {\n  const orgCharts = {};\n  const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n  for (const letter of ALPHABET) {\n    orgCharts[letter] = new OrgChart(letter);\n  }\n  return orgCharts;\n}\n\nit('Test Case #1', function () {\n  const orgCharts = getOrgCharts();\n  orgCharts['A'].addDirectReports([orgCharts['B'], orgCharts['C']]);\n  orgCharts['B'].addDirectReports([orgCharts['D'], orgCharts['E']]);\n  orgCharts['C'].addDirectReports([orgCharts['F'], orgCharts['G']]);\n  orgCharts['D'].addDirectReports([orgCharts['H'], orgCharts['I']]);\n\n  const lcm = program.getLowestCommonManager(orgCharts.A, orgCharts.A, orgCharts.B);\n  chai.expect(lcm).to.deep.equal(orgCharts.A);\n});\n",
    },
    bigO: 'O(n) time | O(d) space - where n is the number of people in the org and d is the depth (height) of the org chart',
    tests: [
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C'], id: 'A', name: 'A' },
            { directReports: ['D', 'E'], id: 'B', name: 'B' },
            { directReports: ['F', 'G'], id: 'C', name: 'C' },
            { directReports: ['H', 'I'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: [], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: [], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
          ],
        },
        reportOne: 'E',
        reportTwo: 'I',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'A',
        reportTwo: 'B',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'B',
        reportTwo: 'F',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'G',
        reportTwo: 'M',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'U',
        reportTwo: 'S',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'Z',
        reportTwo: 'M',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'O',
        reportTwo: 'I',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'T',
        reportTwo: 'Z',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'T',
        reportTwo: 'V',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'T',
        reportTwo: 'H',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'W',
        reportTwo: 'V',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'Z',
        reportTwo: 'B',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'Q',
        reportTwo: 'W',
        topManager: 'A',
      },
      {
        orgChart: {
          nodes: [
            { directReports: ['B', 'C', 'D', 'E', 'F'], id: 'A', name: 'A' },
            { directReports: ['G', 'H', 'I'], id: 'B', name: 'B' },
            { directReports: ['J'], id: 'C', name: 'C' },
            { directReports: ['K', 'L'], id: 'D', name: 'D' },
            { directReports: [], id: 'E', name: 'E' },
            { directReports: ['M', 'N'], id: 'F', name: 'F' },
            { directReports: [], id: 'G', name: 'G' },
            { directReports: ['O', 'P', 'Q', 'R'], id: 'H', name: 'H' },
            { directReports: [], id: 'I', name: 'I' },
            { directReports: [], id: 'J', name: 'J' },
            { directReports: ['S'], id: 'K', name: 'K' },
            { directReports: [], id: 'L', name: 'L' },
            { directReports: [], id: 'M', name: 'M' },
            { directReports: [], id: 'N', name: 'N' },
            { directReports: [], id: 'O', name: 'O' },
            { directReports: ['T', 'U'], id: 'P', name: 'P' },
            { directReports: [], id: 'Q', name: 'Q' },
            { directReports: ['V'], id: 'R', name: 'R' },
            { directReports: [], id: 'S', name: 'S' },
            { directReports: [], id: 'T', name: 'T' },
            { directReports: [], id: 'U', name: 'U' },
            { directReports: ['W', 'X', 'Y'], id: 'V', name: 'V' },
            { directReports: [], id: 'W', name: 'W' },
            { directReports: ['Z'], id: 'X', name: 'X' },
            { directReports: [], id: 'Y', name: 'Y' },
            { directReports: [], id: 'Z', name: 'Z' },
          ],
        },
        reportOne: 'A',
        reportTwo: 'Z',
        topManager: 'A',
      },
    ],
  },
  {
    id: 'product-sum',
    name: 'Product Sum',
    category: 'Recursion',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a "special" array and returns its product sum.\n</p>\n<p>\n  A "special" array is a non-empty array that contains either integers or other\n  "special" arrays. The product sum of a "special" array is the sum of its\n  elements, where "special" arrays inside it are summed themselves and then\n  multiplied by their level of depth.\n</p>\n<p>\n  The depth of a "special" array is how far nested it is. For instance, the\n  depth of <span>[]</span> is <span>1</span>; the depth of the inner array in\n  <span>[[]]</span> is <span>2</span>; the depth of the innermost array in\n  <span>[[[]]]</span> is <span>3</span>.\n</p>\n<p>\n  Therefore, the product sum of <span>[x, y]</span> is <span>x + y</span>; the\n  product sum of <span>[x, [y, z]]</span> is <span>x + 2 * (y + z)</span>; the\n  product sum of <span>[x, [y, [z]]]</span> is <span>x + 2 * (y + 3z)</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [5, 2, [7, -1], 3, [6, [-13, 8], 4]]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n12 <span class="CodeEditor-promptComment">// calculated as: 5 + 2 + 2 * (7 - 1) + 3 + 2 * (6 + 3 * (-13 + 8) + 4)</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry using recursion to solve this problem.\n</p>\n',
      '\n<p>\nInitialize the product sum of the "special" array to 0. Then, iterate through all of the array\'s elements; if you come across a number, add it to the product sum; if you come across another "special" array, recursively call the productSum function on it and add the returned value to the product sum. How will you handle multiplying the product sums at a given level of depth?\n</p>\n',
      '\n<p>\nHave the productSum function take in a second parameter: the multiplier, initialized to 1. Whenever you recursively call the productSum function, pass in the multiplier incremented by 1.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [5, 2, [7, -1], 3, [6, [-13, 8], 4]],
        schema: {
          items: { oneOf: [{ type: 'integer' }, { type: 'array' }] },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Tip: You can use the Array.isArray function to check whether an item\n// is a list or an integer.\nfunction productSum(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.productSum = productSum;\n',
      solutions: [
        '// O(n) time | O(d) space - where n is the total number of elements in the array,\n// including sub-elements, and d is the greatest depth of "special" arrays in the array\nfunction productSum(array, multiplier = 1) {\n  let sum = 0;\n  for (const element of array) {\n    if (Array.isArray(element)) {\n      sum += productSum(element, multiplier + 1);\n    } else {\n      sum += element;\n    }\n  }\n  return sum * multiplier;\n}\n\nexports.productSum = productSum;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const test = [5, 2, [7, -1], 3, [6, [-13, 8], 4]];\n  chai.expect(program.productSum(test)).to.deep.equal(12);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const test = [5, 2, [7, -1], 3, [6, [-13, 8], 4]];\n  chai.expect(program.productSum(test)).to.deep.equal(12);\n});\n",
    },
    bigO: 'O(n) time | O(d) space - where n is the total number of elements in the array, including sub-elements, and d is the greatest depth of "special" arrays in the array',
    tests: [
      { array: [5, 2, [7, -1], 3, [6, [-13, 8], 4]] },
      { array: [1, 2, 3, 4, 5] },
      { array: [1, 2, [3], 4, 5] },
      { array: [[1, 2], 3, [4, 5]] },
      { array: [[[[[5]]]]] },
      {
        array: [
          9,
          [2, -3, 4],
          1,
          [1, 1, [1, 1, 1]],
          [[[[3, 4, 1]]], 8],
          [1, 2, 3, 4, 5, [6, 7], -7],
          [1, [2, 3, [4, 5]], [6, 0, [7, 0, -8]], -7],
          [
            1,
            -3,
            2,
            [1, -3, 2, [1, -3, 2], [1, -3, 2, [1, -3, 2]], [1, -3, 2]],
          ],
          -3,
        ],
      },
    ],
  },
  {
    id: 'interweaving-strings',
    name: 'Interweaving Strings',
    category: 'Recursion',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in three strings and returns a boolean\n  representing whether the third string can be formed by interweaving the first\n  two strings.\n</p>\n<p>\n  To interweave strings means to merge them by alternating their letters without\n  any specific pattern. For instance, the strings <span>"abc"</span> and\n  <span>"123"</span> can be interwoven as <span>"a1b2c3"</span>, as\n  <span>"abc123"</span>, and as <span>"ab1c23"</span> (this list is\n  nonexhaustive).\n</p>\n<p>\n  Letters within a string must maintain their relative ordering in the\n  interwoven string.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">one</span> = "algoexpert"\n<span class="CodeEditor-promptParameter">two</span> = "your-dream-job"\n<span class="CodeEditor-promptParameter">three</span> = "your-algodream-expertjob"\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n</pre>\n</div>',
    hints: [
      '<p>\nTry traversing the three strings with three different pointers to solve this problem.\n</p>\n',
      "\n<p>\nDeclare three variables (i, j, and k, for instance) pointing to indices in the three strings, respectively, and starting at 0. At any given combination of indices, if neither the character at i in the first string nor the character at j in the second string is equal to the character at k in the third string, then the first two strings can't interweave to form the third one (at least not in whatever way led to the values of i, j, and k in question).\n</p>\n",
      '\n<p>\nIf at any given combination of the indices i, j, and k mentioned in Hint #2, the character at i in the first string or the character at j in the second string is equal to the character at k in the third string, then you can potentially interweave the first two strings to get the third one. In such a case, try incrementing the two relevant indices (i and k or j and k) and repeating this process until you confirm whether or not the first two strings can be interwoven to form the third one. Try using recursion to implement this algorithm.\n</p>\n',
      "\n<p>\nBy following Hint #3, you'll perform, in some cases, many computations multiple times. How can you use caching to improve the time complexity of this algorithm?\n</p>",
    ],
    customInputVars: [
      { name: 'one', example: 'algoexpert', schema: { type: 'string' } },
      { name: 'two', example: 'your-dream-job', schema: { type: 'string' } },
      {
        name: 'three',
        example: 'your-algodream-expertjob',
        schema: { type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function interweavingStrings(one, two, three) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.interweavingStrings = interweavingStrings;\n',
      solutions: [
        '// O(2^(n + m)) time | O(n + m) space - where n is the length\n// of the first string and m is the length of the second string\nfunction interweavingStrings(one, two, three) {\n  if (three.length !== one.length + two.length) {\n    return false;\n  }\n\n  return areInterwoven(one, two, three, 0, 0);\n}\n\nfunction areInterwoven(one, two, three, i, j) {\n  const k = i + j;\n  if (k === three.length) return true;\n\n  if (i < one.length && one[i] === three[k]) {\n    if (areInterwoven(one, two, three, i + 1, j)) return true;\n  }\n\n  if (j < two.length && two[j] === three[k]) {\n    return areInterwoven(one, two, three, i, j + 1);\n  }\n\n  return false;\n}\n\nexports.interweavingStrings = interweavingStrings;\n',
        '// O(nm) time | O(nm) space - where n is the length of the\n// first string and m is the length of the second string\nfunction interweavingStrings(one, two, three) {\n  if (three.length !== one.length + two.length) {\n    return false;\n  }\n\n  const cache = new Array(one.length + 1).fill(0).map(_ => new Array(two.length + 1).fill(null));\n  return areInterwoven(one, two, three, 0, 0, cache);\n}\n\nfunction areInterwoven(one, two, three, i, j, cache) {\n  if (cache[i][j] !== null) return cache[i][j];\n\n  const k = i + j;\n  if (k === three.length) return true;\n\n  if (i < one.length && one[i] === three[k]) {\n    cache[i][j] = areInterwoven(one, two, three, i + 1, j, cache);\n    if (cache[i][j]) return true;\n  }\n\n  if (j < two.length && two[j] === three[k]) {\n    cache[i][j] = areInterwoven(one, two, three, i, j + 1, cache);\n    return cache[i][j];\n  }\n\n  cache[i][j] = false;\n  return false;\n}\n\nexports.interweavingStrings = interweavingStrings;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const one = 'algoexpert';\n  const two = 'your-dream-job';\n  const three = 'your-algodream-expertjob';\n  chai.expect(program.interweavingStrings(one, two, three)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const one = 'algoexpert';\n  const two = 'your-dream-job';\n  const three = 'your-algodream-expertjob';\n  chai.expect(program.interweavingStrings(one, two, three)).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(nm) time | O(nm) space - where n is the length of the first string and m is the length of the second string',
    tests: [
      {
        one: 'algoexpert',
        three: 'your-algodream-expertjob',
        two: 'your-dream-job',
      },
      { one: 'a', three: 'ab', two: 'b' },
      { one: 'a', three: 'ba', two: 'b' },
      { one: 'a', three: 'ac', two: 'b' },
      { one: 'abc', three: 'abcdef', two: 'def' },
      { one: 'abc', three: 'adbecf', two: 'def' },
      { one: 'abc', three: 'deabcf', two: 'def' },
      { one: 'aabcc', three: 'aadbbcbcac', two: 'dbbca' },
      { one: 'aabcc', three: 'aadbbbaccc', two: 'dbbca' },
      {
        one: 'algoexpert',
        three: 'ayloguore-xdpreeratm-job',
        two: 'your-dream-job',
      },
      { one: 'aaaaaaa', three: 'aaaaaaaaaaaaaab', two: 'aaaabaaa' },
      { one: 'aaaaaaa', three: 'aaaaaaaaaaaaaa', two: 'aaaaaaa' },
      { one: 'aacaaaa', three: 'aaaabacaaaaaaa', two: 'aaabaaa' },
      { one: 'aacaaaa', three: 'aaaacabaaaaaaa', two: 'aaabaaa' },
      { one: 'aacaaaa', three: 'aaaaaacbaaaaaa', two: 'aaabaaa' },
      {
        one: 'algoexpert',
        three: '1your-algodream-expertjob',
        two: 'your-dream-job',
      },
      {
        one: 'algoexpert',
        three: 'your-algodream-expertjob1',
        two: 'your-dream-job',
      },
      {
        one: 'algoexpert',
        three: 'your-algodream-expertjo',
        two: 'your-dream-job',
      },
      { one: 'ae', three: 'see', two: 'e' },
      { one: 'algo', three: 'fralgogo', two: 'frog' },
    ],
  },
  {
    id: 'phone-number-mnemonics',
    name: 'Phone Number Mnemonics',
    category: 'Recursion',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>If you open the keypad of your mobile phone, it\'ll likely look like this:</p>\n<pre>\n   ----- ----- -----\n  |     |     |     |\n  |  1  |  2  |  3  |\n  |     | abc | def |\n   ----- ----- -----\n  |     |     |     |\n  |  4  |  5  |  6  |\n  | ghi | jkl | mno |\n   ----- ----- -----\n  |     |     |     |\n  |  7  |  8  |  9  |\n  | pqrs| tuv | wxyz|\n   ----- ----- -----\n        |     |\n        |  0  |\n        |     |\n         -----\n</pre>\n<p>\n  Almost every digit is associated with some letters in the alphabet; this\n  allows certain phone numbers to spell out actual words. For example, the phone\n  number <span>8464747328</span> can be written as <span>timisgreat</span>;\n  similarly, the phone number <span>2686463</span> can be written as\n  <span>antoine</span> or as <span>ant6463</span>.\n</p>\n<p>\n  It\'s important to note that a phone number doesn\'t represent a single sequence\n  of letters, but rather multiple combinations of letters. For instance, the\n  digit <span>2</span> can represent three different letters (a, b, and c).\n</p>\n<p>\n  A mnemonic is defined as a pattern of letters, ideas, or associations that\n  assist in remembering something. Companies oftentimes use a mnemonic for their\n  phone number to make it easier to remember.\n</p>\n<p>\n  Given a stringified phone number of any non-zero length, write a function that\n  returns all mnemonics for this phone number, in any order.\n</p>\n<p>\n  For this problem, a valid mnemonic may only contain letters and the digits\n  <span>0</span> and <span>1</span>. In other words, if a digit is able to be\n  represented by a letter, then it must be. Digits <span>0</span> and\n  <span>1</span> are the only two digits that don\'t have letter representations\n  on the keypad.\n</p>\n<p>\n  Note that you should rely on the keypad illustrated above for digit-letter\n  associations.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">phoneNumber</span> = "1905"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\n  "1w0j",\n  "1w0k",\n  "1w0l",\n  "1x0j",\n  "1x0k",\n  "1x0l",\n  "1y0j",\n  "1y0k",\n  "1y0l",\n  "1z0j",\n  "1z0k",\n  "1z0l",\n]\n<span class="CodeEditor-promptComment">// The mnemonics could be ordered differently.</span>\n</pre>\n</div>',
    hints: [
      "<p>\nThe first thing you'll need to do is create a mapping from digits to letters. You can do this by creating a hash table mapping all string digits to lists of their respective characters.\n</p>\n",
      "\n<p>\nThis problem can be solved fairly easily using recursion. Try generating all characters for the first digit in the phone number one at a time, and for each character, recursively performing the same action on the the next digit, and then on the digit after that, and so on and so forth until you've done so for all digits in the phone number.\n</p>\n",
      "\n<p>\nYou can recursively generate characters one digit at a time and store the intermediate results in a array. Once you've reached the last digit in the phone number, you can add the currently generated mnemonic (stored in the previously mentioned array) to a final array that stores all the results.\n</p>",
    ],
    customInputVars: [
      {
        name: 'phoneNumber',
        example: '1905',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function phoneNumberMnemonics(phoneNumber) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.phoneNumberMnemonics = phoneNumberMnemonics;\n',
      solutions: [
        "// O(4^n * n) time | O(4^n * n) space - where\n// n is the length of the phone number\nfunction phoneNumberMnemonics(phoneNumber) {\n  const currentMnemonic = new Array(phoneNumber.length).fill('0');\n  const mnemonicsFound = [];\n\n  phoneNumberMnemonicsHelper(0, phoneNumber, currentMnemonic, mnemonicsFound);\n  return mnemonicsFound;\n}\n\nfunction phoneNumberMnemonicsHelper(idx, phoneNumber, currentMnemonic, mnemonicsFound) {\n  if (idx === phoneNumber.length) {\n    const mnemonic = currentMnemonic.join('');\n    mnemonicsFound.push(mnemonic);\n  } else {\n    const digit = phoneNumber[idx];\n    const letters = DIGIT_LETTERS[digit];\n    for (const letter of letters) {\n      currentMnemonic[idx] = letter;\n      phoneNumberMnemonicsHelper(idx + 1, phoneNumber, currentMnemonic, mnemonicsFound);\n    }\n  }\n}\n\nconst DIGIT_LETTERS = {\n  0: ['0'],\n  1: ['1'],\n  2: ['a', 'b', 'c'],\n  3: ['d', 'e', 'f'],\n  4: ['g', 'h', 'i'],\n  5: ['j', 'k', 'l'],\n  6: ['m', 'n', 'o'],\n  7: ['p', 'q', 'r', 's'],\n  8: ['t', 'u', 'v'],\n  9: ['w', 'x', 'y', 'z'],\n};\n\n// Do not edit the line below.\nexports.phoneNumberMnemonics = phoneNumberMnemonics;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const phoneNumber = '1905';\n  const expected = [\n    '1w0j',\n    '1w0k',\n    '1w0l',\n    '1x0j',\n    '1x0k',\n    '1x0l',\n    '1y0j',\n    '1y0k',\n    '1y0l',\n    '1z0j',\n    '1z0k',\n    '1z0l',\n  ];\n  const actual = program.phoneNumberMnemonics(phoneNumber);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const phoneNumber = '1905';\n  const expected = [\n    '1w0j',\n    '1w0k',\n    '1w0l',\n    '1x0j',\n    '1x0k',\n    '1x0l',\n    '1y0j',\n    '1y0k',\n    '1y0l',\n    '1z0j',\n    '1z0k',\n    '1z0l',\n  ];\n  const actual = program.phoneNumberMnemonics(phoneNumber);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(4^n * n) time | O(4^n * n) space - where n is the length of the phone number',
    tests: [
      { phoneNumber: '1905' },
      { phoneNumber: '1111' },
      { phoneNumber: '002' },
      { phoneNumber: '444' },
      { phoneNumber: '9056661234' },
      { phoneNumber: '4163420000' },
      { phoneNumber: '1' },
      { phoneNumber: '0' },
      { phoneNumber: '23' },
      { phoneNumber: '1212' },
      { phoneNumber: '97' },
      { phoneNumber: '980016' },
    ],
  },
  {
    id: 'staircase-traversal',
    name: 'Staircase Traversal',
    category: 'Recursion',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given two positive integers representing the height of a staircase and\n  the maximum number of steps that you can advance up the staircase at a time.\n  Write a function that returns the number of ways in which you can climb the\n  staircase.\n</p>\n<p>\n  For example, if you were given a staircase of <span>height = 3</span> and\n  <span>maxSteps = 2</span> you could climb the staircase in 3 ways. You could\n  take <b>1 step, 1 step, then 1 step</b>, you could also take\n  <b>1 step, then 2 steps</b>, and you could take <b>2 steps, then 1 step</b>.\n</p>\n<p>Note that <span>maxSteps &lt;= height</span> will always be true.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">height</span> = 4\n<span class="CodeEditor-promptParameter">maxSteps</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5\n<span class="CodeEditor-promptComment">// You can climb the staircase in the following ways: </span>\n<span class="CodeEditor-promptComment">// 1, 1, 1, 1</span>\n<span class="CodeEditor-promptComment">// 1, 1, 2</span>\n<span class="CodeEditor-promptComment">// 1, 2, 1</span>\n<span class="CodeEditor-promptComment">// 2, 1, 1</span>\n<span class="CodeEditor-promptComment">// 2, 2</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  If you can advance <span>2</span> steps at a time, how many ways can you reach\n  a staircase of height <span>1</span> and of height <span>2</span>? Think\n  recursively.\n</p>\n',
      '\n<p>\n  Continuing from Hint #1, if you know the number of ways to climb a staircase\n  of height <span>1</span> and of height <span>2</span>, how many ways are there\n  to climb a staircase of height <span>3</span> (assuming the same max steps of\n  <span>2</span>)?\n</p>\n',
      '\n<p>\n  The number of ways to climb a staircase of height <span>k</span> with a max\n  number of steps <span>s</span> is:\n  <span>numWays[k - 1] + numWays[k - 2] + ... + numWays[k - s]</span>. This is\n  because if you can advance between <span>1</span> and <span>s</span> steps,\n  then from each step <span>k - 1, k - 2, ..., k - s</span>, you can directly\n  advance to the top of a staircase of height <span>k</span>. By adding the\n  number of ways to reach all steps that you can directly advance to the top\n  step from, you determine how many ways there are to reach the top step.\n</p>',
    ],
    customInputVars: [
      { name: 'height', example: 4, schema: { minimum: 1, type: 'integer' } },
      { name: 'maxSteps', example: 2, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function staircaseTraversal(height, maxSteps) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.staircaseTraversal = staircaseTraversal;\n',
      solutions: [
        '// O(k^n) time | O(n) space - where n is the height of the staircase and k is the number of allowed steps\nfunction staircaseTraversal(height, maxSteps) {\n  return numberOfWaysToTop(height, maxSteps);\n}\n\nfunction numberOfWaysToTop(height, maxSteps) {\n  if (height <= 1) return 1;\n\n  let numberOfWays = 0;\n  for (let step = 1; step < Math.min(maxSteps, height) + 1; step++) {\n    numberOfWays += numberOfWaysToTop(height - step, maxSteps);\n  }\n\n  return numberOfWays;\n}\n\n// Do not edit the line below.\nexports.staircaseTraversal = staircaseTraversal;\n',
        '// O(n * k) time | O(n) space - where n is the height of the staircase and k is the number of allowed steps\nfunction staircaseTraversal(height, maxSteps) {\n  return numberOfWaysToTop(height, maxSteps, {0: 1, 1: 1});\n}\n\nfunction numberOfWaysToTop(height, maxSteps, memoize) {\n  if (height in memoize) return memoize[height];\n\n  let numberOfWays = 0;\n  for (let step = 1; step < Math.min(maxSteps, height) + 1; step++) {\n    numberOfWays += numberOfWaysToTop(height - step, maxSteps, memoize);\n  }\n\n  memoize[height] = numberOfWays;\n\n  return numberOfWays;\n}\n\n// Do not edit the line below.\nexports.staircaseTraversal = staircaseTraversal;\n',
        '// O(n * k) time | O(n) space - where n is the height of the staircase and k is the number of allowed steps\nfunction staircaseTraversal(height, maxSteps) {\n  const waysToTop = new Array(height + 1).fill(0);\n  waysToTop[0] = 1;\n  waysToTop[1] = 1;\n\n  for (let currentHeight = 2; currentHeight < height + 1; currentHeight++) {\n    let step = 1;\n    while (step <= maxSteps && step <= currentHeight) {\n      waysToTop[currentHeight] = waysToTop[currentHeight] + waysToTop[currentHeight - step];\n      step++;\n    }\n  }\n\n  return waysToTop[height];\n}\n\n// Do not edit the line below.\nexports.staircaseTraversal = staircaseTraversal;\n',
        '// O(n) time | O(n) space - where n is the height of the staircase\nfunction staircaseTraversal(height, maxSteps) {\n  let currentNumberOfWays = 0;\n  const waysToTop = [1];\n\n  for (let currentHeight = 1; currentHeight < height + 1; currentHeight++) {\n    const startOfWindow = currentHeight - maxSteps - 1;\n    const endOfWindow = currentHeight - 1;\n    if (startOfWindow >= 0) currentNumberOfWays -= waysToTop[startOfWindow];\n\n    currentNumberOfWays += waysToTop[endOfWindow];\n    waysToTop.push(currentNumberOfWays);\n  }\n\n  return waysToTop[height];\n}\n\n// Do not edit the line below.\nexports.staircaseTraversal = staircaseTraversal;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const stairs = 4;\n  const maxSteps = 2;\n  const expected = 5;\n  const actual = program.staircaseTraversal(stairs, maxSteps);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const stairs = 4;\n  const maxSteps = 2;\n  const expected = 5;\n  const actual = program.staircaseTraversal(stairs, maxSteps);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the height of the staircase',
    tests: [
      { height: 4, maxSteps: 2 },
      { height: 10, maxSteps: 1 },
      { height: 10, maxSteps: 2 },
      { height: 4, maxSteps: 3 },
      { height: 1, maxSteps: 1 },
      { height: 5, maxSteps: 2 },
      { height: 4, maxSteps: 4 },
      { height: 6, maxSteps: 2 },
      { height: 100, maxSteps: 1 },
      { height: 15, maxSteps: 5 },
      { height: 7, maxSteps: 2 },
      { height: 6, maxSteps: 3 },
      { height: 3, maxSteps: 2 },
    ],
  },
  {
    id: 'solve-sudoku',
    name: 'Solve Sudoku',
    category: 'Recursion',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array that represents a 9x9 partially filled\n  Sudoku board. Write a function that returns the solved Sudoku board.\n</p>\n<p>\n  Sudoku is a famous number-placement puzzle in which you need to fill a 9x9\n  grid with integers in the range of <span>1-9</span>. Each 9x9 Sudoku board is\n  split into 9 3x3 subgrids, as seen in the illustration below, and starts out\n  partially filled.\n</p>\n<pre>\n- - 3 | - 2 - | 6 - - \n9 - - | 3 - 5 | - - 1 \n- - 1 | 8 - 6 | 4 - -\n- - - - - - - - - - - \n- - 8 | 1 - 2 | 9 - -\n7 - - | - - - | - - 8 \n- - 6 | 7 - 8 | 2 - -\n- - - - - - - - - - -\n- - 2 | 6 - 9 | 5 - - \n8 - - | 2 - 3 | - - 9\n- - 5 | - 1 - | 3 - -\n</pre>\n<p>\n  The objective is to fill the grid such that each row, column, and 3x3 subgrid\n  contains the numbers <span>1-9</span> exactly once. In other words, no row may\n  contain the same digit more than once, no column may contain the same digit\n  more than once, and none of the 9 3x3 subgrids may contain the same digit more\n  than once.\n</p>\n<p>\n  Your input for this problem will always be a partially filled 9x9\n  two-dimensional array that represents a solvable Sudoku puzzle. Every element\n  in the array will be an integer in the range of <span>0-9</span>, where a\n  <span>0</span> represents an empty square that must be filled by your\n  algorithm.\n</p>\n<p>\n  Note that you may modify the input array and that there will always be exactly\n  one solution to each input Sudoku board.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">board</span> = \n[\n  [7, 8, 0, 4, 0, 0, 1, 2, 0],\n  [6, 0, 0, 0, 7, 5, 0, 0, 9],\n  [0, 0, 0, 6, 0, 1, 0, 7, 8],\n  [0, 0, 7, 0, 4, 0, 2, 6, 0],\n  [0, 0, 1, 0, 5, 0, 9, 3, 0],\n  [9, 0, 4, 0, 6, 0, 0, 0, 5],\n  [0, 7, 0, 3, 0, 0, 0, 1, 2],\n  [1, 2, 0, 0, 0, 7, 4, 0, 0],\n  [0, 4, 9, 2, 0, 6, 0, 0, 7],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[\n  [7, 8, 5, 4, 3, 9, 1, 2, 6],\n  [6, 1, 2, 8, 7, 5, 3, 4, 9],\n  [4, 9, 3, 6, 2, 1, 5, 7, 8],\n  [8, 5, 7, 9, 4, 3, 2, 6, 1],\n  [2, 6, 1, 7, 5, 8, 9, 3, 4],\n  [9, 3, 4, 1, 6, 2, 7, 8, 5],\n  [5, 7, 8, 3, 9, 4, 6, 1, 2],\n  [1, 2, 6, 5, 8, 7, 4, 9, 3],\n  [3, 4, 9, 2, 1, 6, 8, 5, 7],\n]\n</pre>\n</div>',
    hints: [
      "<p>\n  The brute-force approach to this problem is to generate every possible Sudoku\n  board and to check each one until you find one that's valid. The issue with\n  this approach is that there are <span>9^81</span> possible 9x9 Sudoku boards.\n  This is an extremely large number, which makes it practically impossible to\n  take this approach. How can you avoid generating every possible Sudoku board?\n</p>\n",
      "\n<p>\n  Keep in mind that a Sudoku board doesn't need to be entirely filled to figure\n  out if it's invalid and won't lead to a solution. Try generating partially\n  filled Sudoku boards until they become invalid, thereby abandoning solutions\n  that will never lead to a properly solved board.\n</p>\n",
      "\n<p>\n  The method described in Hint #2 is more formally known as backtracking. This\n  involves attempting to place digits into empty positions in the Sudoku board\n  and checking at each insertion if that newly inserted digit makes the Sudoku\n  board invalid. If it does, then you try to insert another digit until you find\n  one that doesn't invalidate the board. If it doesn't invalidate the board, you\n  temporarily place that digit and continue to try to solve the rest of the\n  board. If you ever reach a position where there are no valid digits to be\n  inserted (every digit placed in that position leads to an invalid board), that\n  means that one of the previously inserted digits is incorrect. Thus, you must\n  backtrack and change previously placed digits. For more details on this\n  approach, refer to the Conceptual Overview section of this question's video\n  explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'board',
        example: [
          [7, 8, 0, 4, 0, 0, 1, 2, 0],
          [6, 0, 0, 0, 7, 5, 0, 0, 9],
          [0, 0, 0, 6, 0, 1, 0, 7, 8],
          [0, 0, 7, 0, 4, 0, 2, 6, 0],
          [0, 0, 1, 0, 5, 0, 9, 3, 0],
          [9, 0, 4, 0, 6, 0, 0, 0, 5],
          [0, 7, 0, 3, 0, 0, 0, 1, 2],
          [1, 2, 0, 0, 0, 7, 4, 0, 0],
          [0, 4, 9, 2, 0, 6, 0, 0, 7],
        ],
        schema: {
          items: {
            items: { maximum: 9, minimum: 0, type: 'integer' },
            maxItems: 9,
            minItems: 9,
            type: 'array',
          },
          maxItems: 9,
          minItems: 9,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function solveSudoku(board) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.solveSudoku = solveSudoku;\n',
      solutions: [
        '// O(1) time | O(1) space - assuming a 9x9 input board\nfunction solveSudoku(board) {\n  solvePartialSudoku(0, 0, board);\n  return board;\n}\n\nfunction solvePartialSudoku(row, col, board) {\n  let currentRow = row;\n  let currentCol = col;\n\n  if (currentCol === board[currentRow].length) {\n    currentRow++;\n    currentCol = 0;\n    if (currentRow === board.length) return true;\n  }\n\n  if (board[currentRow][currentCol] === 0) {\n    return tryDigitsAtPosition(currentRow, currentCol, board);\n  }\n\n  return solvePartialSudoku(currentRow, currentCol + 1, board);\n}\n\nfunction tryDigitsAtPosition(row, col, board) {\n  for (let digit = 1; digit < 10; digit++) {\n    if (isValidAtPosition(digit, row, col, board)) {\n      board[row][col] = digit;\n      if (solvePartialSudoku(row, col + 1, board)) return true;\n    }\n  }\n\n  board[row][col] = 0;\n  return false;\n}\n\nfunction isValidAtPosition(value, row, col, board) {\n  const rowIsValid = !board[row].includes(value);\n  const colIsValid = !board.map(r => r[col]).includes(value);\n\n  if (!rowIsValid || !colIsValid) return false;\n\n  // Check subgrid constraint.\n  const subgridRowStart = Math.floor(row / 3) * 3;\n  const subgridColStart = Math.floor(col / 3) * 3;\n  for (let rowIdx = 0; rowIdx < 3; rowIdx++) {\n    for (let colIdx = 0; colIdx < 3; colIdx++) {\n      const rowToCheck = subgridRowStart + rowIdx;\n      const colToCheck = subgridColStart + colIdx;\n      const existingValue = board[rowToCheck][colToCheck];\n\n      if (existingValue === value) return false;\n    }\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.solveSudoku = solveSudoku;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [7, 8, 0, 4, 0, 0, 1, 2, 0],\n    [6, 0, 0, 0, 7, 5, 0, 0, 9],\n    [0, 0, 0, 6, 0, 1, 0, 7, 8],\n    [0, 0, 7, 0, 4, 0, 2, 6, 0],\n    [0, 0, 1, 0, 5, 0, 9, 3, 0],\n    [9, 0, 4, 0, 6, 0, 0, 0, 5],\n    [0, 7, 0, 3, 0, 0, 0, 1, 2],\n    [1, 2, 0, 0, 0, 7, 4, 0, 0],\n    [0, 4, 9, 2, 0, 6, 0, 0, 7],\n  ];\n  const expected = [\n    [7, 8, 5, 4, 3, 9, 1, 2, 6],\n    [6, 1, 2, 8, 7, 5, 3, 4, 9],\n    [4, 9, 3, 6, 2, 1, 5, 7, 8],\n    [8, 5, 7, 9, 4, 3, 2, 6, 1],\n    [2, 6, 1, 7, 5, 8, 9, 3, 4],\n    [9, 3, 4, 1, 6, 2, 7, 8, 5],\n    [5, 7, 8, 3, 9, 4, 6, 1, 2],\n    [1, 2, 6, 5, 8, 7, 4, 9, 3],\n    [3, 4, 9, 2, 1, 6, 8, 5, 7],\n  ];\n  const actual = program.solveSudoku(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [7, 8, 0, 4, 0, 0, 1, 2, 0],\n    [6, 0, 0, 0, 7, 5, 0, 0, 9],\n    [0, 0, 0, 6, 0, 1, 0, 7, 8],\n    [0, 0, 7, 0, 4, 0, 2, 6, 0],\n    [0, 0, 1, 0, 5, 0, 9, 3, 0],\n    [9, 0, 4, 0, 6, 0, 0, 0, 5],\n    [0, 7, 0, 3, 0, 0, 0, 1, 2],\n    [1, 2, 0, 0, 0, 7, 4, 0, 0],\n    [0, 4, 9, 2, 0, 6, 0, 0, 7],\n  ];\n  const expected = [\n    [7, 8, 5, 4, 3, 9, 1, 2, 6],\n    [6, 1, 2, 8, 7, 5, 3, 4, 9],\n    [4, 9, 3, 6, 2, 1, 5, 7, 8],\n    [8, 5, 7, 9, 4, 3, 2, 6, 1],\n    [2, 6, 1, 7, 5, 8, 9, 3, 4],\n    [9, 3, 4, 1, 6, 2, 7, 8, 5],\n    [5, 7, 8, 3, 9, 4, 6, 1, 2],\n    [1, 2, 6, 5, 8, 7, 4, 9, 3],\n    [3, 4, 9, 2, 1, 6, 8, 5, 7],\n  ];\n  const actual = program.solveSudoku(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(1) time | O(1) space - assuming a 9x9 input board',
    tests: [
      {
        board: [
          [7, 8, 0, 4, 0, 0, 1, 2, 0],
          [6, 0, 0, 0, 7, 5, 0, 0, 9],
          [0, 0, 0, 6, 0, 1, 0, 7, 8],
          [0, 0, 7, 0, 4, 0, 2, 6, 0],
          [0, 0, 1, 0, 5, 0, 9, 3, 0],
          [9, 0, 4, 0, 6, 0, 0, 0, 5],
          [0, 7, 0, 3, 0, 0, 0, 1, 2],
          [1, 2, 0, 0, 0, 7, 4, 0, 0],
          [0, 4, 9, 2, 0, 6, 0, 0, 7],
        ],
      },
      {
        board: [
          [0, 0, 0, 0, 3, 0, 0, 0, 9],
          [0, 4, 0, 5, 0, 0, 0, 7, 8],
          [2, 9, 0, 0, 0, 1, 0, 5, 0],
          [0, 7, 8, 0, 0, 3, 0, 0, 6],
          [0, 3, 0, 0, 6, 0, 0, 8, 0],
          [6, 0, 0, 8, 0, 0, 9, 3, 0],
          [0, 6, 0, 9, 0, 0, 0, 2, 7],
          [7, 2, 0, 0, 0, 5, 0, 6, 0],
          [8, 0, 0, 0, 7, 0, 0, 0, 0],
        ],
      },
      {
        board: [
          [5, 3, 8, 0, 1, 0, 0, 0, 0],
          [0, 7, 9, 6, 0, 0, 0, 0, 0],
          [0, 0, 4, 0, 0, 2, 0, 0, 0],
          [0, 0, 7, 0, 2, 3, 4, 0, 0],
          [0, 0, 5, 0, 8, 0, 0, 0, 9],
          [4, 6, 0, 0, 9, 0, 0, 0, 1],
          [0, 9, 0, 2, 3, 4, 1, 5, 0],
          [0, 4, 1, 5, 0, 0, 2, 0, 0],
          [0, 0, 0, 8, 6, 1, 0, 3, 0],
        ],
      },
      {
        board: [
          [0, 2, 0, 0, 9, 0, 1, 0, 0],
          [0, 0, 7, 8, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 3, 6, 0],
          [0, 0, 1, 9, 0, 4, 0, 0, 0],
          [0, 0, 0, 6, 0, 5, 0, 0, 7],
          [8, 0, 0, 0, 0, 0, 0, 0, 9],
          [0, 0, 0, 0, 2, 0, 0, 0, 0],
          [7, 0, 0, 0, 0, 0, 0, 8, 5],
          [4, 9, 0, 0, 3, 0, 0, 0, 0],
        ],
      },
    ],
  },
  {
    id: 'generate-div-tags',
    name: 'Generate Div Tags',
    category: 'Recursion',
    complexity: 2,
    prompt:
      '<div class="html">\n  <p>\n    Write a function that takes in a positive integer\n    <span>numberOfTags</span> and returns a list of all the valid strings that\n    you can generate with that number of matched\n    <span>&lt;div&gt;&lt;/div&gt;</span> tags.\n  </p>\n  <p>\n    A string is valid and contains matched\n    <span>&lt;div&gt;&lt;/div&gt;</span> tags if for every opening tag\n    <span>&lt;div&gt;</span>, there\'s a closing tag <span>&lt;/div&gt;</span>\n    that comes after the opening tag and that isn\'t used as a closing tag for\n    another opening tag. Each output string should contain exactly\n    <span>numberOfTags</span> opening tags and <span>numberOfTags</span> closing\n    tags.\n  </p>\n  <p>\n    For example, given <span>numberOfTags = 2</span>, the valid strings to\n    return would be: <span>["&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;", "&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;"]</span>.\n  </p>\n  <p>Note that the output strings don\'t need to be in any particular order.</p>\n  <h3>Sample Input</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">numberOfTags</span> = 3\n</pre>\n  <h3>Sample Output</h3>\n  <pre>\n  [\n    "&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;",\n    "&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;",\n    "&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;",\n    "&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;",\n    "&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;",\n  ] <span class="CodeEditor-promptComment">// The strings could be ordered differently.</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  The brute-force approach to solve this problem is to generate every single\n  possible string that contains <span>numberOfTags</span> tags and to then check\n  all of those strings to see if they're valid. Can you think of a better way to\n  do this?\n</p>\n",
      "\n<p>\n  To solve this problem optimally, you'll have to incrementally build valid\n  strings by adding <span>&lt;div&gt;</span> and <span>&lt;/div&gt;</span> tags\n  to already valid partial strings. While doing this, you can avoid creating\n  strings that will never lead to a valid final string by following two rules:\n</p>\n<ol>\n  <li>\n    If a string has fewer opening tags than\n    <span>numberOfTags</span>, it's valid to add an opening tag to the end of\n    it.\n  </li>\n  <li>\n    If a string has fewer closing tags than opening tags, it's valid to add a\n    closing tag to the end of it.\n  </li>\n</ol>\n",
      "\n<p>\n  Using the rules defined in Hint #2, write a recursive algorithm that generates\n  all possible valid strings. You'll need to keep track of how many opening and\n  closing tags each partial string has available (at each recursive call), and\n  you'll simply follow the rules outlined in Hint #2. Once a string has no more\n  opening and closing tags available, you can add it to your final list of\n  strings. Your first call to the function will start with an empty string as\n  the partial string and with <span>numberOfTags</span> as the number of opening\n  and closing tags available. For example, after you add an opening tag to a\n  partial string, you'll recursively call the function like this:\n  <span\n    >recursiveFunction(partialStringWithExtraOpeningTag, openingTags - 1,\n    closingTags)</span\n  >\n</p>",
    ],
    customInputVars: [
      {
        name: 'numberOfTags',
        example: 3,
        schema: { minimum: 1, type: 'integer' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function generateDivTags(numberOfTags) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.generateDivTags = generateDivTags;\n',
      solutions: [
        "// O((2n)!/((n!((n + 1)!)))) time | O((2n)!/((n!((n + 1)!)))) space -\n// where n is the input number\nfunction generateDivTags(numberOfTags) {\n  const matchedDivTags = [];\n  generateDivTagsFromPrefix(numberOfTags, numberOfTags, '', matchedDivTags);\n  return matchedDivTags;\n}\n\nfunction generateDivTagsFromPrefix(openingTagsNeeded, closingTagsNeeded, prefix, result) {\n  if (openingTagsNeeded > 0) {\n    const newPrefix = prefix + '<div>';\n    generateDivTagsFromPrefix(openingTagsNeeded - 1, closingTagsNeeded, newPrefix, result);\n  }\n\n  if (openingTagsNeeded < closingTagsNeeded) {\n    const newPrefix = prefix + '</div>';\n    generateDivTagsFromPrefix(openingTagsNeeded, closingTagsNeeded - 1, newPrefix, result);\n  }\n\n  if (closingTagsNeeded === 0) result.push(prefix);\n}\n\n// Do not edit the line below.\nexports.generateDivTags = generateDivTags;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 3;\n  const expected = [\n    '<div><div><div></div></div></div>',\n    '<div><div></div><div></div></div>',\n    '<div><div></div></div><div></div>',\n    '<div></div><div><div></div></div>',\n    '<div></div><div></div><div></div>',\n  ];\n  const actual = program.generateDivTags(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 3;\n  const expected = [\n    '<div><div><div></div></div></div>',\n    '<div><div></div><div></div></div>',\n    '<div><div></div></div><div></div>',\n    '<div></div><div><div></div></div>',\n    '<div></div><div></div><div></div>',\n  ];\n  const actual = program.generateDivTags(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O((2n)!/((n!((n + 1)!)))) time | O((2n)!/((n!((n + 1)!)))) space - where n is the input number',
    tests: [
      { numberOfTags: 3 },
      { numberOfTags: 2 },
      { numberOfTags: 1 },
      { numberOfTags: 4 },
      { numberOfTags: 5 },
      { numberOfTags: 6 },
    ],
  },
  {
    id: 'ambiguous-measurements',
    name: 'Ambiguous Measurements',
    category: 'Recursion',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  This problem deals with measuring cups that are missing important measuring\n  labels. Specifically, a measuring cup only has two measuring lines, a Low (L)\n  line and a High (H) line. This means that these cups can\'t precisely measure\n  and can only guarantee that the substance poured into them will be between the\n  L and H line. For example, you might have a measuring cup that has a Low line\n  at <span>400ml</span> and a high line at <span>435ml</span>. This means that\n  when you use this measuring cup, you can only be sure that what you\'re\n  measuring is between <span>400ml</span> and <span>435ml</span>.\n</p>\n<p>\n  You\'re given a list of measuring cups containing their low and high lines as\n  well as one <span>low</span> integer and one <span>high</span> integer\n  representing a range for a target measurement. Write a function that returns a\n  boolean representing whether you can use the cups to accurately measure a\n  volume in the specified <span>[low, high]</span> range (the range is\n  inclusive).\n</p>\n<p>Note that:</p>\n<ul>\n  <li>\n    Each measuring cup will be represented by a pair of positive integers\n    <span>[L, H]</span>, where <span>0 &lt;= L &lt;= H</span>.\n  </li>\n  <li>\n    You\'ll always be given at least one measuring cup, and the\n    <span>low</span> and <span>high</span> input parameters will always satisfy\n    the following constraint: <span>0 &lt;= low &lt;= high</span>.\n  </li>\n  <li>\n    Once you\'ve measured some liquid, it will immediately be transferred to a\n    larger bowl that will eventually (possibly) contain the target measurement.\n  </li>\n  <li>You can\'t pour the contents of one measuring cup into another cup.</li>\n</ul>\n<p></p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">measuringCups</span> = [\n  [200, 210],\n  [450, 465],\n  [800, 850],\n] \n<span class="CodeEditor-promptParameter">low</span> = 2100\n<span class="CodeEditor-promptParameter">high</span> = 2300\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n<span class="CodeEditor-promptComment">// We use cup [450, 465] to measure four volumes:</span>\n<span class="CodeEditor-promptComment">// First measurement: Low = 450, High = 465</span>\n<span class="CodeEditor-promptComment">// Second measurement: Low = 450 + 450 = 900, High = 465 + 465 = 930</span>\n<span class="CodeEditor-promptComment">// Third measurement: Low = 900 + 450 = 1350, High = 930 + 465 = 1395</span>\n<span class="CodeEditor-promptComment">// Fourth measurement: Low = 1350 + 450 = 1800, High = 1395 + 465 = 1860</span>\n\n<span class="CodeEditor-promptComment">// Then we use cup [200, 210] to measure two volumes:</span>\n<span class="CodeEditor-promptComment">// Fifth measurement: Low = 1800 + 200 = 2000, High = 1860 + 210 = 2070</span>\n<span class="CodeEditor-promptComment">// Sixth measurement: Low = 2000 + 200 = 2200, High = 2070 + 210 = 2280</span>\n\n<span class="CodeEditor-promptComment">// We\'ve measured a volume in the range [2200, 2280].</span>\n<span class="CodeEditor-promptComment">// This is within our target range, so we return `true`.</span>\n\n<span class="CodeEditor-promptComment">// Note: there are other ways to measure a volume in the target range.</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  Start by considering the last cup that you'll use in your sequence of\n  measurements. If it isn't possible to use any of the cups as the last cup,\n  then you can't measure the desired volume.\n</p>\n",
      "\n<p>\n  If the cup that you're going to use last has a measuring range of\n  <span>[100, 110]</span> and you want to measure in the range of\n  <span>[500, 550]</span>, then after you pick this cup as the last cup, you\n  need to measure a range of <span>[400, 440]</span>. Now, you can simply pick\n  the last cup you'll use to measure this new range. If you continue these\n  steps, you'll eventually know if you're able to measure the entire range or\n  not.\n</p>\n",
      "\n<p>\n  Hint #2 should give you an idea of how to solve this problem recursively. Try\n  every cup as the last cup for the starting range, then recursively try to\n  measure the new ranges created after using the selected last cups. If you ever\n  reach a point where one cup can measure the entire range, then you're finished\n  and you can measure the target range. Try to think of a way to optimize this\n  recursive approach, since it might involve a lot of repeated calculations.\n</p>",
    ],
    customInputVars: [
      {
        name: 'measuringCups',
        example: [
          [200, 210],
          [450, 465],
          [800, 850],
        ],
        schema: {
          items: {
            items: { minimum: 0, type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
      { name: 'low', example: 2100, schema: { minimum: 0, type: 'integer' } },
      { name: 'high', example: 2300, schema: { minimum: 0, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function ambiguousMeasurements(measuringCups, low, high) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.ambiguousMeasurements = ambiguousMeasurements;\n',
      solutions: [
        "// O(low * high * n) time | O(low * high) space - where n is\n// the number of measuring cups\nfunction ambiguousMeasurements(measuringCups, low, high) {\n  const memoization = {};\n  return canMeasureInRange(measuringCups, low, high, memoization);\n}\n\nfunction canMeasureInRange(measuringCups, low, high, memoization) {\n  const memoizeKey = createHashableKey(low, high);\n  if (memoizeKey in memoization) return memoization[memoizeKey];\n\n  if (low <= 0 && high <= 0) return false;\n\n  let canMeasure = false;\n  for (const cup of measuringCups) {\n    const [cupLow, cupHigh] = cup;\n    if (low <= cupLow && cupHigh <= high) {\n      canMeasure = true;\n      break;\n    }\n\n    const newLow = Math.max(0, low - cupLow);\n    const newHigh = Math.max(0, high - cupHigh);\n    canMeasure = canMeasureInRange(measuringCups, newLow, newHigh, memoization);\n    if (canMeasure) break;\n  }\n\n  memoization[memoizeKey] = canMeasure;\n  return canMeasure;\n}\n\nfunction createHashableKey(low, high) {\n  return low.toString() + ':' + high.toString();\n}\n\n// Do not edit the line below.\nexports.ambiguousMeasurements = ambiguousMeasurements;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const cups = [\n    [200, 210],\n    [450, 465],\n    [800, 850],\n  ];\n  const low = 2100;\n  const high = 2300;\n  const expected = true;\n  const actual = program.ambiguousMeasurements(cups, low, high);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(low * high * n) time | O(low * high) space - where n is the number of measuring cups',
    tests: [
      {
        high: 2300,
        low: 2100,
        measuringCups: [
          [200, 210],
          [450, 465],
          [800, 850],
        ],
      },
      { high: 20, low: 10, measuringCups: [[200, 210]] },
      {
        high: 2300,
        low: 2100,
        measuringCups: [
          [230, 240],
          [290, 310],
          [500, 515],
        ],
      },
      {
        high: 101,
        low: 100,
        measuringCups: [
          [1, 3],
          [2, 4],
          [5, 6],
        ],
      },
      {
        high: 120,
        low: 100,
        measuringCups: [
          [1, 3],
          [2, 4],
          [5, 6],
        ],
      },
      {
        high: 12,
        low: 10,
        measuringCups: [
          [1, 3],
          [2, 4],
          [5, 6],
          [10, 20],
        ],
      },
      {
        high: 12,
        low: 10,
        measuringCups: [
          [1, 3],
          [2, 4],
          [5, 7],
          [10, 20],
        ],
      },
      {
        high: 1050,
        low: 1000,
        measuringCups: [
          [50, 60],
          [100, 120],
          [20, 40],
          [10, 15],
          [400, 500],
        ],
      },
      {
        high: 1200,
        low: 1000,
        measuringCups: [
          [50, 65],
          [100, 120],
          [20, 40],
          [10, 15],
          [400, 500],
        ],
      },
      {
        high: 3300,
        low: 3000,
        measuringCups: [
          [50, 65],
          [100, 120],
          [20, 40],
          [10, 15],
          [400, 500],
          [300, 350],
          [10, 25],
        ],
      },
      {
        high: 1050,
        low: 1000,
        measuringCups: [
          [50, 60],
          [100, 120],
          [20, 40],
          [400, 500],
        ],
      },
      { high: 200, low: 200, measuringCups: [[50, 65]] },
      { high: 200, low: 200, measuringCups: [[50, 50]] },
      {
        high: 200,
        low: 200,
        measuringCups: [
          [50, 50],
          [50, 51],
        ],
      },
      {
        high: 1000,
        low: 0,
        measuringCups: [
          [100, 150],
          [1000, 2000],
        ],
      },
      { high: 20, low: 10, measuringCups: [[10, 20]] },
      { high: 20, low: 10, measuringCups: [[15, 18]] },
      { high: 20, low: 10, measuringCups: [[15, 22]] },
    ],
  },
  {
    id: 'non-attacking-queens',
    name: 'Non-Attacking Queens',
    category: 'Recursion',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a positive integer <span>n</span> and returns\n  the number of non-attacking placements of <span>n</span> queens on an\n  <span>n x n</span> chessboard.\n</p>\n<p>\n  A non-attacking placement is one where no queen can attack another queen in a\n  single turn. In other words, it\'s a placement where no queen can move to the\n  same position as another queen in a single turn.\n</p>\n<p>\n  In chess, queens can move any number of squares horizontally, vertically, or\n  diagonally in a single turn.\n</p>\n<pre>\n+--+--+--+--+  \n|  |Q |  |  |\n+--+--+--+--+\n|  |  |  |Q |\n+--+--+--+--+\n|Q |  |  |  |\n+--+--+--+--+\n|  |  |Q |  |\n+--+--+--+--+\n</pre>\n<p>\n  The chessboard above is an example of a non-attacking placement of 4 queens on\n  a 4x4 chessboard. For reference, there are only 2 non-attacking placements of\n  4 queens on a 4x4 chessboard.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">n</span> = 4\n</pre>\n<h3>Sample Output</h3>\n<pre>\n2\n</pre>\n</div>',
    hints: [
      "<p>\n  As soon as the input gets relatively large, this problem can no longer be\n  solved with a brute-force approach. For example, there are\n  <span>16,777,216</span> possible placements of 8 queens on an 8x8 chessboard.\n  To consider all of these placements and to check if they're non-attacking\n  isn't viable. Can you come up with an approach that limits the number of\n  placements to consider?\n</p>\n",
      "\n<p>\n  In order to generate a placement of <span>n</span> queens, you naturally have\n  to place queens one at a time. Try only placing queens such that they're in a\n  non-attacking position, given where you've previously placed queens. This\n  should drastically limit the total number of placements that you consider. For\n  example, if you place the first queen in the first row and in the first\n  column, then don't consider a placement where any other queen is in the first\n  row, in the first column, or in the down diagonal that starts at the first\n  queen.\n</p>\n",
      "\n<p>\n  When placing a queen in order to generate a full placement of\n  <span>n</span> queens, you'll have to check if the position that you're\n  considering is non-attacking. This can be done in linear time or in constant\n  time, depending on if and how you store what columns and diagonals are blocked\n  by previously placed queens. See the Conceptual Overview section of this\n  question's video explanation for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      { name: 'n', example: 4, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function nonAttackingQueens(n) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.nonAttackingQueens = nonAttackingQueens;\n',
      solutions: [
        '// Lower Bound: O(n!) time | O(n) space - where n is the input number\nfunction nonAttackingQueens(n) {\n  // Each index of `columnPlacements` represents a row of the chessboard,\n  // and the value at each index is the column (on the relevant row) where\n  // a queen is currently placed.\n  const columnPlacements = new Array(n).fill(0);\n  return getNumberOfNonAttackingQueenPlacements(0, columnPlacements, n);\n}\n\nfunction getNumberOfNonAttackingQueenPlacements(row, columnPlacements, boardSize) {\n  if (row === boardSize) return 1;\n\n  let validPlacements = 0;\n  for (let col = 0; col < boardSize; col++) {\n    if (isNonAttackingPlacement(row, col, columnPlacements)) {\n      columnPlacements[row] = col;\n      validPlacements += getNumberOfNonAttackingQueenPlacements(\n        row + 1,\n        columnPlacements,\n        boardSize,\n      );\n    }\n  }\n\n  return validPlacements;\n}\n\n// As `row` tends to `n`, this becomes an O(n)-time operation.\nfunction isNonAttackingPlacement(row, col, columnPlacements) {\n  for (let previousRow = 0; previousRow < row; previousRow++) {\n    const columnToCheck = columnPlacements[previousRow];\n    const sameColumn = columnToCheck === col;\n    const onDiagonal = Math.abs(columnToCheck - col) === row - previousRow;\n    if (sameColumn || onDiagonal) return false;\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.nonAttackingQueens = nonAttackingQueens;\n',
        '// Upper Bound: O(n!) time | O(n) space - where n is the input number\nfunction nonAttackingQueens(n) {\n  const blockedColumns = new Set();\n  const blockedUpDiagonals = new Set();\n  const blockedDownDiagonals = new Set();\n  return getNumberOfNonAttackingQueenPlacements(\n    0,\n    blockedColumns,\n    blockedUpDiagonals,\n    blockedDownDiagonals,\n    n,\n  );\n}\n\nfunction getNumberOfNonAttackingQueenPlacements(\n  row,\n  blockedColumns,\n  blockedUpDiagonals,\n  blockedDownDiagonals,\n  boardSize,\n) {\n  if (row === boardSize) return 1;\n\n  let validPlacements = 0;\n  for (let col = 0; col < boardSize; col++) {\n    if (\n      isNonAttackingPlacement(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals)\n    ) {\n      placeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals);\n      validPlacements += getNumberOfNonAttackingQueenPlacements(\n        row + 1,\n        blockedColumns,\n        blockedUpDiagonals,\n        blockedDownDiagonals,\n        boardSize,\n      );\n      removeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals);\n    }\n  }\n\n  return validPlacements;\n}\n\n// This is always an O(1)-time operation.\nfunction isNonAttackingPlacement(\n  row,\n  col,\n  blockedColumns,\n  blockedUpDiagonals,\n  blockedDownDiagonals,\n) {\n  if (blockedColumns.has(col)) return false;\n  if (blockedUpDiagonals.has(row + col)) return false;\n  if (blockedDownDiagonals.has(row - col)) return false;\n\n  return true;\n}\n\nfunction placeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals) {\n  blockedColumns.add(col);\n  blockedUpDiagonals.add(row + col);\n  blockedDownDiagonals.add(row - col);\n}\n\nfunction removeQueen(row, col, blockedColumns, blockedUpDiagonals, blockedDownDiagonals) {\n  blockedColumns.delete(col);\n  blockedUpDiagonals.delete(row + col);\n  blockedDownDiagonals.delete(row - col);\n}\n\n// Do not edit the line below.\nexports.nonAttackingQueens = nonAttackingQueens;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 4;\n  const expected = 2;\n  const actual = program.nonAttackingQueens(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = 4;\n  const expected = 2;\n  const actual = program.nonAttackingQueens(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'Upper Bound: O(n!) time | O(n) space - where n is the input number',
    tests: [
      { n: 4 },
      { n: 2 },
      { n: 1 },
      { n: 3 },
      { n: 8 },
      { n: 5 },
      { n: 6 },
      { n: 7 },
      { n: 10 },
    ],
  },
  {
    id: 'max-subset-sum-no-adjacent',
    name: 'Max Subset Sum No Adjacent',
    category: 'Dynamic Programming',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of positive integers and returns the\n  maximum sum of non-adjacent elements in the array.\n</p>\n<p>If the input array is empty, the function should return <span>0</span>.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [75, 105, 120, 75, 90, 135]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n330 <span class="CodeEditor-promptComment">// 75 + 120 + 135</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building an array of the same length as the input array. At each index in this new array, store the maximum sum that can be generated using no adjacent numbers located between index 0 and the current index.\n</p>\n',
      '\n<p>\nCan you come up with a formula that relates the max sum at index i to the max sums at indices i - 1 and i - 2?\n</p>\n',
      '\n<p>\nDo you really need to store the entire array mentioned in Hint #1, or can you somehow store just the max sums that you need at any point in time?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [75, 105, 120, 75, 90, 135],
        schema: { items: { minimum: 1, type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function maxSubsetSumNoAdjacent(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.maxSubsetSumNoAdjacent = maxSubsetSumNoAdjacent;\n',
      solutions: [
        '// O(n) time | O(n) space\nfunction maxSubsetSumNoAdjacent(array) {\n  if (!array.length) return 0;\n  if (array.length === 1) return array[0];\n  const maxSums = array.slice();\n  maxSums[1] = Math.max(array[0], array[1]);\n  for (let i = 2; i < array.length; i++) {\n    maxSums[i] = Math.max(maxSums[i - 1], maxSums[i - 2] + array[i]);\n  }\n  return maxSums[maxSums.length - 1];\n}\n\nexports.maxSubsetSumNoAdjacent = maxSubsetSumNoAdjacent;\n',
        '// O(n) time | O(1) space\nfunction maxSubsetSumNoAdjacent(array) {\n  if (!array.length) return 0;\n  if (array.length === 1) return array[0];\n  let second = array[0];\n  let first = Math.max(array[0], array[1]);\n  for (let i = 2; i < array.length; i++) {\n    const current = Math.max(first, second + array[i]);\n    second = first;\n    first = current;\n  }\n  return first;\n}\n\nexports.maxSubsetSumNoAdjacent = maxSubsetSumNoAdjacent;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.maxSubsetSumNoAdjacent([75, 105, 120, 75, 90, 135])).to.deep.equal(330);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.maxSubsetSumNoAdjacent([75, 105, 120, 75, 90, 135])).to.deep.equal(330);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [75, 105, 120, 75, 90, 135] },
      { array: [] },
      { array: [1] },
      { array: [1, 2] },
      { array: [1, 2, 3] },
      { array: [1, 15, 3] },
      { array: [7, 10, 12, 7, 9, 14] },
      { array: [4, 3, 5, 200, 5, 3] },
      { array: [10, 5, 20, 25, 15, 5, 5, 15] },
      { array: [10, 5, 20, 25, 15, 5, 5, 15, 3, 15, 5, 5, 15] },
      { array: [125, 210, 250, 120, 150, 300] },
      { array: [30, 25, 50, 55, 100] },
      { array: [30, 25, 50, 55, 100, 120] },
      { array: [7, 10, 12, 7, 9, 14, 15, 16, 25, 20, 4] },
    ],
  },
  {
    id: 'number-of-ways-to-make-change',
    name: 'Number Of Ways To Make Change',
    category: 'Dynamic Programming',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Given an array of distinct positive integers representing coin denominations and a\n  single non-negative integer <span>n</span> representing a target amount of\n  money, write a function that returns the number of ways to make change for\n  that target amount using the given coin denominations.\n</p>\n<p>Note that an unlimited amount of coins is at your disposal.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">n</span> = 6\n<span class="CodeEditor-promptParameter">denoms</span> = [1, 5]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n2 <span class="CodeEditor-promptComment">// 1x1 + 1x5 and 6x1</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building an array of the number of ways to make change for all amounts between 0 and n inclusive. Note that there is only one way to make change for 0: that is to not use any coins.\n</p>\n',
      '\n<p>\nBuild up the array mentioned in Hint #1 one coin denomination at a time. In other words, find the number of ways to make change for all amounts between 0 and n with only one denomination, then with two, etc., until you use all denominations.\n</p>',
    ],
    customInputVars: [
      { name: 'n', example: 6, schema: { minimum: 0, type: 'integer' } },
      {
        name: 'denoms',
        example: [1, 5],
        schema: {
          items: { minimum: 1, type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function numberOfWaysToMakeChange(n, denoms) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.numberOfWaysToMakeChange = numberOfWaysToMakeChange;\n',
      solutions: [
        '// O(nd) time | O(n) space\nfunction numberOfWaysToMakeChange(n, denoms) {\n  const ways = new Array(n + 1).fill(0);\n  ways[0] = 1;\n  for (let denom of denoms) {\n    for (let amount = 1; amount < n + 1; amount++) {\n      if (denom <= amount) {\n        ways[amount] += ways[amount - denom];\n      }\n    }\n  }\n  return ways[n];\n}\n\nexports.numberOfWaysToMakeChange = numberOfWaysToMakeChange;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.numberOfWaysToMakeChange(6, [1, 5])).to.deep.equal(2);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.numberOfWaysToMakeChange(6, [1, 5])).to.deep.equal(2);\n});\n",
    },
    bigO: 'O(nd) time | O(n) space - where n is the target amount and d is the number of coin denominations',
    tests: [
      { denoms: [1, 5], n: 6 },
      { denoms: [2, 3, 4, 7], n: 0 },
      { denoms: [5], n: 9 },
      { denoms: [2, 4], n: 7 },
      { denoms: [1, 5, 10, 25], n: 4 },
      { denoms: [1, 5, 10, 25], n: 5 },
      { denoms: [1, 5, 10, 25], n: 10 },
      { denoms: [1, 5, 10, 25], n: 25 },
      { denoms: [2, 3, 7], n: 12 },
      { denoms: [2, 3, 4, 7], n: 7 },
    ],
  },
  {
    id: 'min-number-of-coins-for-change',
    name: 'Min Number Of Coins For Change',
    category: 'Dynamic Programming',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Given an array of positive integers representing coin denominations and a\n  single non-negative integer <span>n</span> representing a target amount of\n  money, write a function that returns the smallest number of coins needed to\n  make change for (to sum up to) that target amount using the given coin\n  denominations.\n</p>\n<p>\n  Note that you have access to an unlimited amount of coins. In other words, if\n  the denominations are <span>[1, 5, 10]</span>, you have access to an unlimited\n  amount of <span>1</span>s, <span>5</span>s, and <span>10</span>s.\n</p>\n<p>\n  If it\'s impossible to make change for the target amount, return\n  <span>-1</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">n</span> = 7\n<span class="CodeEditor-promptParameter">denoms</span> = [1, 5, 10]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// 2x1 + 1x5</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building an array of the minimum number of coins needed to make change for all amounts between 0 and n inclusive. Note that no coins are needed to make change for 0: in order to make change for 0, you do not need to use any coins.\n</p>\n',
      '\n<p>\nBuild up the array mentioned in Hint #1 one coin denomination at a time. In other words, find the minimum number of coins needed to make change for all amounts between 0 and n with only one denomination, then with two, etc., until you use all denominations.\n</p>',
    ],
    customInputVars: [
      { name: 'n', example: 7, schema: { minimum: 0, type: 'integer' } },
      {
        name: 'denoms',
        example: [1, 5, 10],
        schema: {
          items: { minimum: 1, type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function minNumberOfCoinsForChange(n, denoms) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.minNumberOfCoinsForChange = minNumberOfCoinsForChange;\n',
      solutions: [
        '// O(nd) time | O(n) space\nfunction minNumberOfCoinsForChange(n, denoms) {\n  const numOfCoins = new Array(n + 1).fill(Infinity);\n  numOfCoins[0] = 0;\n  for (const denom of denoms) {\n    for (let amount = 0; amount < numOfCoins.length; amount++) {\n      if (denom <= amount) {\n        numOfCoins[amount] = Math.min(numOfCoins[amount], numOfCoins[amount - denom] + 1);\n      }\n    }\n  }\n  return numOfCoins[n] !== Infinity ? numOfCoins[n] : -1;\n}\n\nexports.minNumberOfCoinsForChange = minNumberOfCoinsForChange;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.minNumberOfCoinsForChange(7, [1, 5, 10])).to.deep.equal(3);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.minNumberOfCoinsForChange(7, [1, 5, 10])).to.deep.equal(3);\n});\n",
    },
    bigO: 'O(nd) time | O(n) space - where n is the target amount and d is the number of coin denominations',
    tests: [
      { denoms: [1, 5, 10], n: 7 },
      { denoms: [1, 10, 5], n: 7 },
      { denoms: [10, 1, 5], n: 7 },
      { denoms: [1, 2, 3], n: 0 },
      { denoms: [2, 1], n: 3 },
      { denoms: [1, 5, 10], n: 4 },
      { denoms: [1, 5, 10], n: 10 },
      { denoms: [1, 5, 10], n: 11 },
      { denoms: [1, 5, 10], n: 24 },
      { denoms: [1, 5, 10], n: 25 },
      { denoms: [2, 4], n: 7 },
      { denoms: [3, 7], n: 7 },
      { denoms: [3, 5], n: 9 },
      { denoms: [3, 4, 5], n: 9 },
      { denoms: [39, 45, 130, 40, 4, 1], n: 135 },
      { denoms: [39, 45, 130, 40, 4, 1, 60, 75], n: 135 },
      { denoms: [1, 3, 4], n: 10 },
    ],
  },
  {
    id: 'max-sum-increasing-subsequence',
    name: 'Max Sum Increasing Subsequence',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a non-empty array of integers and returns the\n  greatest sum that can be generated from a strictly-increasing subsequence in\n  the array as well as an array of the numbers in that subsequence.\n</p>\n<p>\n  A subsequence of an array is a set of numbers that aren\'t necessarily adjacent\n  in the array but that are in the same order as they appear in the array. For\n  instance, the numbers <span>[1, 3, 4]</span> form a subsequence of the array\n  <span>[1, 2, 3, 4]</span>, and so do the numbers <span>[2, 4]</span>. Note\n  that a single number in an array and the array itself are both valid\n  subsequences of the array.\n</p>\n<p>\n  You can assume that there will only be one increasing subsequence with the\n  greatest sum.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [10, 70, 20, 30, 50, 11, 30]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[110, [10, 20, 30, 50]] <span class="CodeEditor-promptComment">// The subsequence [10, 20, 30, 50] is strictly increasing and yields the greatest sum: 110.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building an array of the same length as the input array. At each index in this new array, store the maximum sum that can be generated from an increasing subsequence ending with the number found at that index in the input array.\n</p>\n',
      '\n<p>\nCan you efficiently keep track of potential sequences in another array? Instead of storing entire sequences, try storing the indices of previous numbers. For example, at index 3 in this other array, store the index of the before-last number in the max-sum increasing subsequence ending with the number at index 3.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [10, 70, 20, 30, 50, 11, 30],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function maxSumIncreasingSubsequence(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.maxSumIncreasingSubsequence = maxSumIncreasingSubsequence;\n',
      solutions: [
        '// O(n^2) time | O(n) space\nfunction maxSumIncreasingSubsequence(array) {\n  const sequences = new Array(array.length);\n  const sums = array.map(num => num);\n  let maxSumIdx = 0;\n  for (let i = 0; i < array.length; i++) {\n    const currentNum = array[i];\n    for (let j = 0; j < i; j++) {\n      const otherNum = array[j];\n      if (otherNum < currentNum && sums[j] + currentNum >= sums[i]) {\n        sums[i] = sums[j] + currentNum;\n        sequences[i] = j;\n      }\n    }\n    if (sums[i] >= sums[maxSumIdx]) maxSumIdx = i;\n  }\n  return [sums[maxSumIdx], buildSequence(array, sequences, maxSumIdx)];\n}\n\nfunction buildSequence(array, sequences, currentIdx) {\n  const sequence = [];\n  while (currentIdx !== undefined) {\n    sequence.unshift(array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n\nexports.maxSumIncreasingSubsequence = maxSumIncreasingSubsequence;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.maxSumIncreasingSubsequence([10, 70, 20, 30, 50, 11, 30]))\n    .to.deep.equal([110, [10, 20, 30, 50]]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.maxSumIncreasingSubsequence([10, 70, 20, 30, 50, 11, 30]))\n    .to.deep.equal([110, [10, 20, 30, 50]]);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the length of the input array',
    tests: [
      { array: [10, 70, 20, 30, 50, 11, 30] },
      { array: [1] },
      { array: [-1] },
      { array: [-1, 1] },
      { array: [5, 4, 3, 2, 1] },
      { array: [1, 2, 3, 4, 5] },
      { array: [-5, -4, -3, -2, -1] },
      { array: [8, 12, 2, 3, 15, 5, 7] },
      { array: [10, 15, 4, 5, 11, 14, 31, 25, 31, 23, 25, 31, 50] },
      { array: [10, 1, 2, 3, 4, 5, 6, 7, 8, 9] },
    ],
  },
  {
    id: 'levenshtein-distance',
    name: 'Levenshtein Distance',
    category: 'Dynamic Programming',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in two strings and returns the minimum number of\n  edit operations that need to be performed on the first string to obtain the\n  second string.\n</p>\n<p>\n  There are three edit operations: insertion of a character, deletion of a\n  character, and substitution of a character for another.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">str1</span> = "abc"\n<span class="CodeEditor-promptParameter">str2</span> = "yabd"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n2 <span class="CodeEditor-promptComment">// insert "y"; substitute "c" for "d"</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building a two-dimensional array of the minimum numbers of edits for pairs of substrings of the input strings. Let the rows of the array represent substrings of the second input string str2. Let the first row represent the empty string. Let each row i thereafter represent the substrings of str2 from 0 to i, with i excluded. Let the columns similarly represent the first input string str1.\n</p>\n',
      '\n<p>\nBuild up the array mentioned in Hint #1 one row at a time. In other words, find the minimum numbers of edits between all the substrings of str1 represented by the columns and the empty string represented by the first row, then between all the substrings of str1 represented by the columns and the first letter of str2 represented by the second row, etc., until you compare both full strings. Find a formula that relates the minimum number of edits at any given point to previous numbers.\n</p>\n',
      '\n<p>\nAt any position (i, j) in the two-dimensional array, if str2[i] is equal to str1[j], then the edit distance at position (i, j) is equal to the one at position (i - 1, j - 1), since adding str2[i] and str1[j] to the substrings represented at position (i - 1, j - 1) does not require any additional edit operation. If str2[i] is not equal to str1[j] however, then the edit distance at position (i, j) is equal to 1 + the minimum of the edit distances at positions (i - 1, j), (i, j - 1), and (i - 1, j - 1). Why is that the case?\n</p>\n',
      '\n<p>\nDo you really need to store the entire two-dimensional array mentioned in Hint #1? Identify what stored values you actually use throughout the process of building the array and come up with a way of storing only what you need and nothing more.\n</p>',
    ],
    customInputVars: [
      { name: 'str1', example: 'abc', schema: { type: 'string' } },
      { name: 'str2', example: 'yabd', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function levenshteinDistance(str1, str2) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.levenshteinDistance = levenshteinDistance;\n',
      solutions: [
        '// O(nm) time | O(nm) space\nfunction levenshteinDistance(str1, str2) {\n  const edits = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    const row = [];\n    for (let j = 0; j < str1.length + 1; j++) {\n      row.push(j);\n    }\n    row[0] = i;\n    edits.push(row);\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        edits[i][j] = edits[i - 1][j - 1];\n      } else {\n        edits[i][j] = 1 + Math.min(edits[i - 1][j - 1], edits[i - 1][j], edits[i][j - 1]);\n      }\n    }\n  }\n  return edits[str2.length][str1.length];\n}\n\nexports.levenshteinDistance = levenshteinDistance;\n',
        '// O(nm) time | O(min(n, m)) space\nfunction levenshteinDistance(str1, str2) {\n  const small = str1.length < str2.length ? str1 : str2;\n  const big = str1.length >= str2.length ? str1 : str2;\n  const evenEdits = [];\n  const oddEdits = new Array(small.length + 1);\n  for (let j = 0; j < small.length + 1; j++) {\n    evenEdits.push(j);\n  }\n  for (let i = 1; i < big.length + 1; i++) {\n    let currentEdits, previousEdits;\n    if (i % 2 === 1) {\n      currentEdits = oddEdits;\n      previousEdits = evenEdits;\n    } else {\n      currentEdits = evenEdits;\n      previousEdits = oddEdits;\n    }\n    currentEdits[0] = i;\n    for (let j = 1; j < small.length + 1; j++) {\n      if (big[i - 1] === small[j - 1]) {\n        currentEdits[j] = previousEdits[j - 1];\n      } else {\n        currentEdits[j] = 1 + Math.min(previousEdits[j - 1], previousEdits[j], currentEdits[j - 1]);\n      }\n    }\n  }\n  return big.length % 2 === 0 ? evenEdits[small.length] : oddEdits[small.length];\n}\n\nexports.levenshteinDistance = levenshteinDistance;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.levenshteinDistance('abc', 'yabd')).to.deep.equal(2);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.levenshteinDistance('abc', 'yabd')).to.deep.equal(2);\n});\n",
    },
    bigO: 'O(nm) time | O(min(n, m)) space - where n and m are the lengths of the two input strings',
    tests: [
      { str1: 'abc', str2: 'yabd' },
      { str1: '', str2: '' },
      { str1: '', str2: 'abc' },
      { str1: 'abc', str2: 'abc' },
      { str1: 'abc', str2: 'abx' },
      { str1: 'abc', str2: 'abcx' },
      { str1: 'abc', str2: 'yabcx' },
      { str1: 'algoexpert', str2: 'algozexpert' },
      { str1: 'abcdefghij', str2: '1234567890' },
      { str1: 'abcdefghij', str2: 'a234567890' },
      { str1: 'biting', str2: 'mitten' },
      { str1: 'cereal', str2: 'saturday' },
      { str1: 'cereal', str2: 'saturdzz' },
      { str1: 'abbbbbbbbb', str2: 'bbbbbbbbba' },
      { str1: 'xabc', str2: 'abcx' },
      { str1: 'table', str2: 'bal' },
      { str1: 'gumbo', str2: 'gambol' },
    ],
  },
  {
    id: 'longest-common-subsequence',
    name: 'Longest Common Subsequence',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in two strings and returns their longest common\n  subsequence.\n</p>\n<p>\n  A subsequence of a string is a set of characters that aren\'t necessarily\n  adjacent in the string but that are in the same order as they appear in the\n  string. For instance, the characters <span>["a", "c", "d"]</span> form a\n  subsequence of the string <span>"abcd"</span>, and so do the characters\n  <span>["b", "d"]</span>. Note that a single character in a string and the\n  string itself are both valid subsequences of the string.\n</p>\n<p>\n  You can assume that there will only be one longest common subsequence.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">str1</span> = "ZXVVYZW"\n<span class="CodeEditor-promptParameter">str2</span> = "XKYKZPW"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["X", "Y", "Z", "W"]\n</pre>\n</div>',
    hints: [
      '<p>\nTry building a two-dimensional array of the longest common subsequences of substring pairs of the input strings. Let the rows of the array represent substrings of the second input string str2. Let the first row represent the empty string. Let each row i thereafter represent the substrings of str2 from 0 to i, with i excluded. Let the columns similarly represent the first input string str1.\n</p>\n',
      '\n<p>\nBuild up the array mentioned in Hint #1 one row at a time. In other words, find the longest common subsequences for all the substrings of str1 represented by the columns and the empty string represented by the first row, then for all the substrings of str1 represented by the columns and the first letter of str2 represented by the second row, etc., until you compare both full strings. Find a formula that relates the longest common subsequence at any given point to previous subsequences.\n</p>\n',
      '\n<p>\nDo you really need to build and store subsequences at each point in the two-dimensional array mentioned in Hint #1? Try storing booleans to determine whether or not a letter at a given point in the two-dimensional array is part of the longest common subsequence as well as pointers to determine what should come before this letter in the final subsequence. Use these pointers to backtrack your way through the array and to build up the longest common subsequence at the end of your algorithm.\n</p>',
    ],
    customInputVars: [
      { name: 'str1', example: 'ZXVVYZW', schema: { type: 'string' } },
      { name: 'str2', example: 'XKYKZPW', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function longestCommonSubsequence(str1, str2) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestCommonSubsequence = longestCommonSubsequence;\n',
      solutions: [
        '// O(nm*min(n, m)) time | O(nm*min(n, m)) space\nfunction longestCommonSubsequence(str1, str2) {\n  const lcs = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    const row = new Array(str1.length + 1).fill([]);\n    lcs.push(row);\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lcs[i][j] = lcs[i - 1][j - 1].concat(str2[i - 1]);\n      } else {\n        lcs[i][j] = lcs[i - 1][j].length > lcs[i][j - 1].length ? lcs[i - 1][j] : lcs[i][j - 1];\n      }\n    }\n  }\n  return lcs[str2.length][str1.length];\n}\n\nexports.longestCommonSubsequence = longestCommonSubsequence;\n',
        '// O(nm*min(n, m)) time | O((min(n, m))^2) space\nfunction longestCommonSubsequence(str1, str2) {\n  const small = str1.length < str2.length ? str1 : str2;\n  const big = str1.length >= str2.length ? str1 : str2;\n  const evenLcs = new Array(small.length + 1).fill([]);\n  const oddLcs = new Array(small.length + 1).fill([]);\n  for (let i = 1; i < big.length + 1; i++) {\n    let currentLcs, previousLcs;\n    if (i % 2 === 1) {\n      currentLcs = oddLcs;\n      previousLcs = evenLcs;\n    } else {\n      currentLcs = evenLcs;\n      previousLcs = oddLcs;\n    }\n    for (let j = 1; j < small.length + 1; j++) {\n      if (big[i - 1] === small[j - 1]) {\n        currentLcs[j] = previousLcs[j - 1].concat(big[i - 1]);\n      } else {\n        currentLcs[j] =\n          previousLcs[j].length > currentLcs[j - 1].length ? previousLcs[j] : currentLcs[j - 1];\n      }\n    }\n  }\n  return big.length % 2 === 0 ? evenLcs[small.length] : oddLcs[small.length];\n}\n\nexports.longestCommonSubsequence = longestCommonSubsequence;\n',
        '// O(nm) time | O(nm) space\nfunction longestCommonSubsequence(str1, str2) {\n  const lcs = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    const row = [];\n    for (let j = 0; j < str1.length + 1; j++) {\n      const entry = new Array(4);\n      entry[1] = 0;\n      row.push(entry);\n    }\n    lcs.push(row);\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lcs[i][j] = [str2[i - 1], lcs[i - 1][j - 1][1] + 1, i - 1, j - 1];\n      } else {\n        if (lcs[i - 1][j][1] > lcs[i][j - 1][1]) {\n          lcs[i][j] = [null, lcs[i - 1][j][1], i - 1, j];\n        } else {\n          lcs[i][j] = [null, lcs[i][j - 1][1], i, j - 1];\n        }\n      }\n    }\n  }\n  return buildSequence(lcs);\n}\n\nfunction buildSequence(lcs) {\n  const sequence = [];\n  let i = lcs.length - 1;\n  let j = lcs[0].length - 1;\n  while (i !== 0 && j !== 0) {\n    let currentEntry = lcs[i][j];\n    if (currentEntry[0]) {\n      sequence.unshift(currentEntry[0]);\n    }\n    i = currentEntry[2];\n    j = currentEntry[3];\n  }\n  return sequence;\n}\n\nexports.longestCommonSubsequence = longestCommonSubsequence;\n',
        '// O(nm) time | O(nm) space\nfunction longestCommonSubsequence(str1, str2) {\n  const lengths = [];\n  for (let i = 0; i < str2.length + 1; i++) {\n    lengths.push(new Array(str1.length + 1).fill(0));\n  }\n  for (let i = 1; i < str2.length + 1; i++) {\n    for (let j = 1; j < str1.length + 1; j++) {\n      if (str2[i - 1] === str1[j - 1]) {\n        lengths[i][j] = lengths[i - 1][j - 1] + 1;\n      } else {\n        lengths[i][j] = Math.max(lengths[i - 1][j], lengths[i][j - 1]);\n      }\n    }\n  }\n  return buildSequence(lengths, str1);\n}\n\nfunction buildSequence(lengths, string) {\n  const sequence = [];\n  let i = lengths.length - 1;\n  let j = lengths[0].length - 1;\n  while (i !== 0 && j !== 0) {\n    if (lengths[i][j] === lengths[i - 1][j]) {\n      i--;\n    } else if (lengths[i][j] === lengths[i][j - 1]) {\n      j--;\n    } else {\n      sequence.unshift(string[j - 1]);\n      i--;\n      j--;\n    }\n  }\n  return sequence;\n}\n\nexports.longestCommonSubsequence = longestCommonSubsequence;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestCommonSubsequence('ZXVVYZW', 'XKYKZPW'))\n    .to.deep.equal(['X', 'Y', 'Z', 'W']);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestCommonSubsequence('ZXVVYZW', 'XKYKZPW'))\n    .to.deep.equal(['X', 'Y', 'Z', 'W']);\n});\n",
    },
    bigO: 'O(nm) time | O(nm) space - where n and m are the lengths of the two input strings',
    tests: [
      { str1: 'ZXVVYZW', str2: 'XKYKZPW' },
      { str1: '', str2: '' },
      { str1: '', str2: 'ABCDEFG' },
      { str1: 'ABCDEFG', str2: '' },
      { str1: 'ABCDEFG', str2: 'ABCDEFG' },
      { str1: 'ABCDEFG', str2: 'APPLES' },
      { str1: 'clement', str2: 'antoine' },
      {
        str1: '8111111111111111142',
        str2: '222222222822222222222222222222433333333332',
      },
      {
        str1: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
        str2: 'CCCDDEGDHAGKGLWAJWKJAWGKGWJAKLGGWAFWLFFWAGJWKAG',
      },
      {
        str1: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
        str2: 'CCCDDEGDHAGKGLWAJWKJAWGKGWJAKLGGWAFWLFFWAGJWKAGTUV',
      },
    ],
  },
  {
    id: 'min-number-of-jumps',
    name: 'Min Number Of Jumps',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a non-empty array of positive integers where each integer represents the\n  maximum number of steps you can take forward in the array. For example, if the\n  element at index <span>1</span> is <span>3</span>, you can go from index\n  <span>1</span> to index <span>2</span>, <span>3</span>, or <span>4</span>.\n</p>\n<p>\n  Write a function that returns the minimum number of jumps needed to reach the\n  final index.\n</p>\n<p>\n  Note that jumping from index <span>i</span> to index <span>i + x</span> always\n  constitutes one jump, no matter how large <span>x</span> is.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4 <span class="CodeEditor-promptComment">// 3 --> (4 or 2) --> (2 or 3) --> 7 --> 3</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building an array of the minimum number of jumps needed to go from index 0 to all indices. Start at index 0 and progressively build up the array, using previously calculated values to find next ones.\n</p>\n',
      '\n<p>\nBuilding the array mentioned in Hint #1 should be feasible using two for loops. In an effort to optimize your algorithm, realize that at any point in the array you know the farthest index that you can reach as well as the number of steps that you have left until you must "consume" a jump.\n</p>\n',
      "\n<p>\nAfter initializing your maximum reach as well as your current number of steps to the value stored at index 0, you can easily update your maximum reach as you traverse the input array by simply comparing it to the value stored at each index. You can also remove one step from your current number of steps at each index, since moving from one index to the next uses up one step. When your steps reach zero, find a way to calculate how many steps you actually have left using the maximum reach and the index that you're at.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3],
        schema: {
          items: { minimum: 1, type: 'integer' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function minNumberOfJumps(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.minNumberOfJumps = minNumberOfJumps;\n',
      solutions: [
        '// O(n^2) time | O(n) space\nfunction minNumberOfJumps(array) {\n  const jumps = new Array(array.length).fill(Infinity);\n  jumps[0] = 0;\n  for (let i = 1; i < array.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (array[j] >= i - j) {\n        jumps[i] = Math.min(jumps[j] + 1, jumps[i]);\n      }\n    }\n  }\n  return jumps[jumps.length - 1];\n}\n\nexports.minNumberOfJumps = minNumberOfJumps;\n',
        '// O(n) time | O(1) space\nfunction minNumberOfJumps(array) {\n  if (array.length === 1) return 0;\n  let jumps = 0;\n  let maxReach = array[0];\n  let steps = array[0];\n  for (let i = 1; i < array.length - 1; i++) {\n    maxReach = Math.max(maxReach, i + array[i]);\n    steps--;\n    if (steps === 0) {\n      jumps++;\n      steps = maxReach - i;\n    }\n  }\n  return jumps + 1;\n}\n\nexports.minNumberOfJumps = minNumberOfJumps;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.minNumberOfJumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3])).to.deep.equal(4);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.minNumberOfJumps([3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3])).to.deep.equal(4);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3] },
      { array: [1] },
      { array: [1, 1] },
      { array: [3, 1] },
      { array: [1, 1, 1] },
      { array: [2, 1, 1] },
      { array: [2, 1, 2, 3, 1] },
      { array: [2, 1, 2, 3, 1, 1, 1] },
      { array: [2, 1, 2, 2, 1, 1, 1] },
      { array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 6, 2, 1, 1, 1, 1] },
      { array: [3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1] },
      { array: [3, 10, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1] },
      { array: [3, 12, 2, 1, 2, 3, 7, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1] },
      { array: [3, 12, 2, 1, 2, 3, 15, 1, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1] },
    ],
  },
  {
    id: 'water-area',
    name: 'Water Area',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an array of non-negative integers where each non-zero integer\n  represents the height of a pillar of width <span>1</span>. Imagine water being\n  poured over all of the pillars; write a function that returns the surface area\n  of the water trapped between the pillars viewed from the front. Note that\n  spilled water should be ignored.\n</p>\n<p>\n  You can refer to the first three minutes of this question\'s video explanation\n  for a visual example.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">heights</span> = [0, 8, 0, 0, 5, 0, 0, 10, 0, 0, 1, 1, 0, 3]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n48\n\n<span class="CodeEditor-promptComment">// Below is a visual representation of the sample input.</span>\n<span class="CodeEditor-promptComment">// The dots and vertical lines represent trapped water and pillars, respectively.</span>\n<span class="CodeEditor-promptComment">// Note that there are 48 dots.</span>\n<span class="CodeEditor-promptComment">//        |</span>\n<span class="CodeEditor-promptComment">//        |</span>\n<span class="CodeEditor-promptComment">//  |.....|</span>\n<span class="CodeEditor-promptComment">//  |.....|</span>\n<span class="CodeEditor-promptComment">//  |.....|</span>\n<span class="CodeEditor-promptComment">//  |..|..|</span>\n<span class="CodeEditor-promptComment">//  |..|..|</span>\n<span class="CodeEditor-promptComment">//  |..|..|.....|</span>\n<span class="CodeEditor-promptComment">//  |..|..|.....|</span>\n<span class="CodeEditor-promptComment">// _|..|..|..||.|</span>\n</pre>\n</div>',
    hints: [
      '<p>\nIn order to calculate the amount of water above a single point in the input array, you must know the height of the tallest pillar to its left and the height of the tallest pillar to its right.\n</p>\n',
      '\n<p>\nIf a point can hold water above it, then the smallest of the two heights mentioned in Hint #1 minus the height at that respective point should lead you to the amount of water above it.\n</p>\n',
      '\n<p>\nTry building an array of the left and right max heights for each point in the input array. You should be able to build this array and to compute the final amount of water above each point in just two loops over the input array.\n</p>',
    ],
    customInputVars: [
      {
        name: 'heights',
        example: [0, 8, 0, 0, 5, 0, 0, 10, 0, 0, 1, 1, 0, 3],
        schema: { items: { minimum: 0, type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function waterArea(heights) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.waterArea = waterArea;\n',
      solutions: [
        '// O(n) time | O(n) space - where n is the length of the input array\nfunction waterArea(heights) {\n  const maxes = new Array(heights.length).fill(0);\n  let leftMax = 0;\n  for (let i = 0; i < heights.length; i++) {\n    const height = heights[i];\n    maxes[i] = leftMax;\n    leftMax = Math.max(leftMax, height);\n  }\n  let rightMax = 0;\n  for (let i = heights.length - 1; i >= 0; i--) {\n    const height = heights[i];\n    const minHeight = Math.min(rightMax, maxes[i]);\n    if (height < minHeight) {\n      maxes[i] = minHeight - height;\n    } else {\n      maxes[i] = 0;\n    }\n    rightMax = Math.max(rightMax, height);\n  }\n  return maxes.reduce((a, b) => a + b, 0);\n}\n\nexports.waterArea = waterArea;\n',
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction waterArea(heights) {\n  if (heights.length === 0) return 0;\n\n  let leftIdx = 0;\n  let rightIdx = heights.length - 1;\n  let leftMax = heights[leftIdx];\n  let rightMax = heights[rightIdx];\n  let surfaceArea = 0;\n\n  while (leftIdx < rightIdx) {\n    if (heights[leftIdx] < heights[rightIdx]) {\n      leftIdx++;\n      leftMax = Math.max(leftMax, heights[leftIdx]);\n      surfaceArea += leftMax - heights[leftIdx];\n    } else {\n      rightIdx--;\n      rightMax = Math.max(rightMax, heights[rightIdx]);\n      surfaceArea += rightMax - heights[rightIdx];\n    }\n  }\n\n  return surfaceArea;\n}\n\nexports.waterArea = waterArea;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.waterArea([0, 8, 0, 0, 5, 0, 0, 10, 0, 0, 1, 1, 0, 3])).to.deep.equal(48);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.waterArea([0, 8, 0, 0, 5, 0, 0, 10, 0, 0, 1, 1, 0, 3])).to.deep.equal(48);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { heights: [0, 8, 0, 0, 5, 0, 0, 10, 0, 0, 1, 1, 0, 3] },
      { heights: [] },
      { heights: [0, 0, 0, 0, 0] },
      { heights: [0, 1, 0, 0, 0] },
      { heights: [0, 1, 1, 0, 0] },
      { heights: [0, 1, 2, 1, 1] },
      { heights: [0, 1, 0, 1, 0] },
      { heights: [0, 1, 0, 1, 0, 2, 0, 3] },
      { heights: [0, 8, 0, 0, 10, 0, 0, 10, 0, 0, 1, 1, 0, 3] },
      { heights: [0, 100, 0, 0, 10, 1, 1, 10, 1, 0, 1, 1, 0, 100] },
      { heights: [0, 100, 0, 0, 10, 1, 1, 10, 1, 0, 1, 1, 0, 0] },
      { heights: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8] },
      { heights: [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] },
      { heights: [1, 8, 6, 2, 5, 4, 8, 3, 7] },
    ],
  },
  {
    id: 'knapsack-problem',
    name: 'Knapsack Problem',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an array of arrays where each subarray holds two integer values\n  and represents an item; the first integer is the item\'s value, and the second\n  integer is the item\'s weight. You\'re also given an integer representing the\n  maximum capacity of a knapsack that you have.\n</p>\n<p>\n  Your goal is to fit items in your knapsack without having the sum of their\n  weights exceed the knapsack\'s capacity, all the while maximizing their\n  combined value. Note that you only have one of each item at your disposal.\n</p>\n<p>\n  Write a function that returns the maximized combined value of the items that\n  you should pick as well as an array of the indices of each item picked.\n</p>\n<p>\n  If there are multiple combinations of items that maximize the total value in\n  the knapsack, your function can return any of them.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">items</span> = [[1, 2], [4, 3], [5, 6], [6, 7]]\n<span class="CodeEditor-promptParameter">capacity</span> = 10\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[10, [1, 3]] <span class="CodeEditor-promptComment"></span>// items [4, 3] and [6, 7]\n</pre>\n</div>',
    hints: [
      '<p>\nTry building a two-dimensional array of the maximum values that knapsacks of all capacities between 0 and c inclusive could hold, given one, two, three, etc., items. Let columns represent capacities and rows represent items.\n</p>\n',
      '\n<p>\nBuild up the array mentioned in Hint #1 one row at a time. In other words, find the maximum values that knapsacks of all capacities between 0 and c can hold with only one item, then with two, etc., until you use all items. Find a formula that relates the maximum value at any given point to previous values.\n</p>\n',
      "\n<p>\nBacktrack your way through the two-dimensional array mentioned in Hint #1 to find which items are in your knapsack. Start at the final index in the array and check whether or not the value stored at that index is equal to the value located one row above. If it isn't, then the item represented by the current row is in the knapsack.\n</p>",
    ],
    customInputVars: [
      {
        name: 'items',
        example: [
          [1, 2],
          [4, 3],
          [5, 6],
          [6, 7],
        ],
        schema: {
          items: {
            items: { type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
      {
        name: 'capacity',
        example: 10,
        schema: { minimum: 0, type: 'integer' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function knapsackProblem(items, capacity) {\n  // Write your code here.\n  // Replace return below.\n  return [\n    10, // total value\n    [1, 2], // item indices\n  ];\n}\n\n// Do not edit the line below.\nexports.knapsackProblem = knapsackProblem;\n',
      solutions: [
        '// O(nc) time | O(nc) space\nfunction knapsackProblem(items, capacity) {\n  const knapsackValues = [];\n  for (let i = 0; i < items.length + 1; i++) {\n    const row = new Array(capacity + 1).fill(0);\n    knapsackValues.push(row);\n  }\n  for (let i = 1; i < items.length + 1; i++) {\n    const currentWeight = items[i - 1][1];\n    const currentValue = items[i - 1][0];\n    for (let c = 0; c < capacity + 1; c++) {\n      if (currentWeight > c) {\n        knapsackValues[i][c] = knapsackValues[i - 1][c];\n      } else {\n        knapsackValues[i][c] = Math.max(\n          knapsackValues[i - 1][c],\n          knapsackValues[i - 1][c - currentWeight] + currentValue,\n        );\n      }\n    }\n  }\n  return [knapsackValues[items.length][capacity], getKnapsackItems(knapsackValues, items)];\n}\n\nfunction getKnapsackItems(knapsackValues, items) {\n  const sequence = [];\n  let i = knapsackValues.length - 1;\n  let c = knapsackValues[0].length - 1;\n  while (i > 0) {\n    if (knapsackValues[i][c] === knapsackValues[i - 1][c]) {\n      i -= 1;\n    } else {\n      sequence.unshift(i - 1);\n      c -= items[i - 1][1];\n      i -= 1;\n    }\n    if (c === 0) break;\n  }\n  return sequence;\n}\n\nexports.knapsackProblem = knapsackProblem;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.knapsackProblem(\n        [\n          [1, 2],\n          [4, 3],\n          [5, 6],\n          [6, 7],\n        ],\n        10,\n      ),\n    )\n    .to.deep.equal([10, [1, 3]]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.knapsackProblem(\n        [\n          [1, 2],\n          [4, 3],\n          [5, 6],\n          [6, 7],\n        ],\n        10,\n      ),\n    )\n    .to.deep.equal([10, [1, 3]]);\n});\n",
    },
    bigO: 'O(nc) time | O(nc) space - where n is the number of items and c is the capacity',
    tests: [
      {
        capacity: 10,
        items: [
          [1, 2],
          [4, 3],
          [5, 6],
          [6, 7],
        ],
      },
      {
        capacity: 11,
        items: [
          [1, 2],
          [4, 3],
          [5, 6],
          [6, 9],
        ],
      },
      {
        capacity: 200,
        items: [
          [465, 100],
          [400, 85],
          [255, 55],
          [350, 45],
          [650, 130],
          [1000, 190],
          [455, 100],
          [100, 25],
          [1200, 190],
          [320, 65],
          [750, 100],
          [50, 45],
          [550, 65],
          [100, 50],
          [600, 70],
          [240, 40],
        ],
      },
      {
        capacity: 200,
        items: [
          [465, 100],
          [400, 85],
          [255, 55],
          [350, 45],
          [650, 130],
          [1000, 190],
          [455, 100],
          [100, 25],
          [1200, 190],
          [320, 65],
          [750, 100],
          [50, 45],
          [550, 65],
          [100, 50],
          [600, 70],
          [255, 40],
        ],
      },
      {
        capacity: 100,
        items: [
          [2, 1],
          [70, 70],
          [30, 30],
          [69, 69],
          [100, 100],
        ],
      },
      {
        capacity: 100,
        items: [
          [1, 2],
          [70, 70],
          [30, 30],
          [69, 69],
          [99, 100],
        ],
      },
      {
        capacity: 0,
        items: [
          [1, 2],
          [70, 70],
          [30, 30],
          [69, 69],
          [100, 100],
        ],
      },
    ],
  },
  {
    id: 'disk-stacking',
    name: 'Disk Stacking',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a non-empty array of arrays where each subarray holds three\n  integers and represents a disk. These integers denote each disk\'s width,\n  depth, and height, respectively. Your goal is to stack up the disks and to\n  maximize the total height of the stack. A disk must have a strictly smaller\n  width, depth, and height than any other disk below it.\n</p>\n<p>\n  Write a function that returns an array of the disks in the final stack,\n  starting with the top disk and ending with the bottom disk. Note that you\n  can\'t rotate disks; in other words, the integers in each subarray must\n  represent <span>[width, depth, height]</span> at all times.\n</p>\n<p>\n  You can assume that there will only be one stack with the greatest total\n  height.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">disks</span> = [[2, 1, 2], [3, 2, 3], [2, 2, 8], [2, 3, 4], [1, 3, 1], [4, 4, 5]]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[[2, 1, 2], [3, 2, 3], [4, 4, 5]]\n<span class="CodeEditor-promptComment">// 10 (2 + 3 + 5) is the tallest height we can get by</span>\n<span class="CodeEditor-promptComment">// stacking disks following the rules laid out above.</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building an array of the same length as the array of disks. At each index i in this new array, store the height of the tallest tower that can be created with the disk located at index i at the bottom.\n</p>\n',
      '\n<p>\nConsider sorting the disks by width, depth, or height for a slight optimization.\n</p>\n',
      '\n<p>\nCan you efficiently keep track of potential towers in another array? Instead of storing entire sequences of disks, try storing the indices of previous disks. For example, at index 3 in this other array, store the index of the before-last disk in the tallest tower whose base is the disk at index 3.\n</p>',
    ],
    customInputVars: [
      {
        name: 'disks',
        example: [
          [2, 1, 2],
          [3, 2, 3],
          [2, 2, 8],
          [2, 3, 4],
          [1, 3, 1],
          [4, 4, 5],
        ],
        schema: {
          items: {
            items: { minimum: 1, type: 'integer' },
            maxItems: 3,
            minItems: 3,
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function diskStacking(disks) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.diskStacking = diskStacking;\n',
      solutions: [
        '// O(n^2) time | O(n) space\nfunction diskStacking(disks) {\n  disks.sort((a, b) => a[2] - b[2]);\n  const heights = disks.map(disk => disk[2]);\n  const sequences = new Array(disks.length);\n  let maxHeightIdx = 0;\n  for (let i = 1; i < disks.length; i++) {\n    const currentDisk = disks[i];\n    for (let j = 0; j < i; j++) {\n      const otherDisk = disks[j];\n      if (areValidDimensions(otherDisk, currentDisk)) {\n        if (heights[i] <= currentDisk[2] + heights[j]) {\n          heights[i] = currentDisk[2] + heights[j];\n          sequences[i] = j;\n        }\n      }\n    }\n    if (heights[i] >= heights[maxHeightIdx]) maxHeightIdx = i;\n  }\n  return buildSequence(disks, sequences, maxHeightIdx);\n}\n\nfunction areValidDimensions(o, c) {\n  return o[0] < c[0] && o[1] < c[1] && o[2] < c[2];\n}\n\nfunction buildSequence(array, sequences, currentIdx) {\n  const sequence = [];\n  while (currentIdx !== undefined) {\n    sequence.unshift(array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n\nexports.diskStacking = diskStacking;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.diskStacking([\n        [2, 1, 2],\n        [3, 2, 3],\n        [2, 2, 8],\n        [2, 3, 4],\n        [2, 2, 1],\n        [4, 4, 5],\n      ]),\n    )\n    .to.deep.equal([\n      [2, 1, 2],\n      [3, 2, 3],\n      [4, 4, 5],\n    ]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(\n      program.diskStacking([\n        [2, 1, 2],\n        [3, 2, 3],\n        [2, 2, 8],\n        [2, 3, 4],\n        [2, 2, 1],\n        [4, 4, 5],\n      ]),\n    )\n    .to.deep.equal([\n      [2, 1, 2],\n      [3, 2, 3],\n      [4, 4, 5],\n    ]);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the number of disks',
    tests: [
      {
        disks: [
          [2, 1, 2],
          [3, 2, 3],
          [2, 2, 8],
          [2, 3, 4],
          [1, 3, 1],
          [4, 4, 5],
        ],
      },
      { disks: [[2, 1, 2]] },
      {
        disks: [
          [2, 1, 2],
          [3, 2, 3],
        ],
      },
      {
        disks: [
          [2, 1, 2],
          [3, 2, 3],
          [2, 2, 8],
        ],
      },
      {
        disks: [
          [2, 1, 2],
          [3, 2, 3],
          [2, 3, 4],
        ],
      },
      {
        disks: [
          [2, 1, 2],
          [3, 2, 3],
          [2, 2, 8],
          [2, 3, 4],
          [2, 2, 1],
          [4, 4, 5],
        ],
      },
      {
        disks: [
          [2, 1, 2],
          [3, 2, 5],
          [2, 2, 8],
          [2, 3, 4],
          [2, 2, 1],
          [4, 4, 5],
        ],
      },
      {
        disks: [
          [2, 1, 2],
          [3, 2, 3],
          [2, 2, 8],
          [2, 3, 4],
          [1, 2, 1],
          [4, 4, 5],
          [1, 1, 4],
        ],
      },
      {
        disks: [
          [3, 3, 4],
          [2, 1, 2],
          [3, 2, 3],
          [2, 2, 8],
          [2, 3, 4],
          [5, 5, 6],
          [1, 2, 1],
          [4, 4, 5],
          [1, 1, 4],
          [2, 2, 3],
        ],
      },
    ],
  },
  {
    id: 'max-profit-with-k-transactions',
    name: 'Max Profit With K Transactions',
    category: 'Dynamic Programming',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  You\'re given an array of positive integers representing the prices of a single stock on\n  various days (each index in the array represents a different day). You\'re also\n  given an integer <span>k</span>, which represents the number of transactions\n  you\'re allowed to make. One transaction consists of buying the stock on a\n  given day and selling it on another, later day.\n</p>\n<p>\n  Write a function that returns the maximum profit that you can make by buying\n  and selling the stock, given k transactions.\n</p>\n<p>\n  Note that you can only hold one share of the stock at a time; in other words,\n  you can\'t buy more than one share of the stock on any given day, and you can\'t\n  buy a share of the stock if you\'re still holding another share. Also, you\n  don\'t need to use all k transactions that you\'re allowed.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">prices</span> = [5, 11, 3, 50, 60, 90]\n<span class="CodeEditor-promptParameter">k</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n93 <span class="CodeEditor-promptComment">// Buy: 5, Sell: 11; Buy: 3, Sell: 90</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building a two-dimensional array of the maximum profits you can make on each day with zero, one, two, etc., k transactions. Let columns represent days and rows represent the number of transactions.\n</p>\n',
      '\n<p>\nBuild up the array mentioned in Hint #1 one row at a time. In other words, find the maximum profits that you can make on each day with zero transactions first, then with one transaction, etc., until you reach k transactions. Find a formula that relates the maximum profit at any given point to previous profits. Once you find that formula, identify certain values that you repeatedly need and that you can temporarily store to optimize your algorithm.\n</p>\n',
      '\n<p>\nDo you really need to store the entire two-dimensional array mentioned in Hint #1? Identify what stored values you actually use throughout the process of building the array and come up with a way of storing only what you need and nothing more.\n</p>',
    ],
    customInputVars: [
      {
        name: 'prices',
        example: [5, 11, 3, 50, 60, 90],
        schema: { items: { minimum: 1, type: 'integer' }, type: 'array' },
      },
      { name: 'k', example: 2, schema: { minimum: 0, type: 'integer' } },
    ],
    isFree: true,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function maxProfitWithKTransactions(prices, k) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.maxProfitWithKTransactions = maxProfitWithKTransactions;\n',
      solutions: [
        '// O(nk) time | O(nk) space\nfunction maxProfitWithKTransactions(prices, k) {\n  if (!prices.length) return 0;\n  const profits = [];\n  for (let t = 0; t < k + 1; t++) {\n    const row = new Array(prices.length).fill(0);\n    profits.push(row);\n  }\n  for (let t = 1; t < k + 1; t++) {\n    let maxThusFar = -Infinity;\n    for (let d = 1; d < prices.length; d++) {\n      maxThusFar = Math.max(maxThusFar, profits[t - 1][d - 1] - prices[d - 1]);\n      profits[t][d] = Math.max(profits[t][d - 1], maxThusFar + prices[d]);\n    }\n  }\n  return profits[k][prices.length - 1];\n}\n\nexports.maxProfitWithKTransactions = maxProfitWithKTransactions;\n',
        '// O(nk) time | O(n) space\nfunction maxProfitWithKTransactions(prices, k) {\n  if (!prices.length) return 0;\n  const evenProfits = new Array(prices.length).fill(0);\n  const oddProfits = new Array(prices.length).fill(0);\n  for (let t = 1; t < k + 1; t++) {\n    let maxThusFar = -Infinity;\n    let currentProfits, previousProfits;\n    if (t % 2 === 1) {\n      currentProfits = oddProfits;\n      previousProfits = evenProfits;\n    } else {\n      currentProfits = evenProfits;\n      previousProfits = oddProfits;\n    }\n    for (let d = 1; d < prices.length; d++) {\n      maxThusFar = Math.max(maxThusFar, previousProfits[d - 1] - prices[d - 1]);\n      currentProfits[d] = Math.max(currentProfits[d - 1], maxThusFar + prices[d]);\n    }\n  }\n  return k % 2 === 0 ? evenProfits[prices.length - 1] : oddProfits[prices.length - 1];\n}\n\nexports.maxProfitWithKTransactions = maxProfitWithKTransactions;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.maxProfitWithKTransactions([5, 11, 3, 50, 60, 90], 2)).to.deep.equal(93);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.maxProfitWithKTransactions([5, 11, 3, 50, 60, 90], 2)).to.deep.equal(93);\n});\n",
    },
    bigO: 'O(nk) time | O(n) space - where n is the number of prices and k is the number of transactions',
    tests: [
      { k: 2, prices: [5, 11, 3, 50, 60, 90] },
      { k: 1, prices: [] },
      { k: 1, prices: [1] },
      { k: 1, prices: [1, 10] },
      { k: 3, prices: [1, 10] },
      { k: 1, prices: [3, 2, 5, 7, 1, 3, 7] },
      { k: 3, prices: [5, 11, 3, 50, 60, 90] },
      { k: 2, prices: [5, 11, 3, 50, 40, 90] },
      { k: 3, prices: [5, 11, 3, 50, 40, 90] },
      { k: 2, prices: [50, 25, 12, 4, 3, 10, 1, 100] },
      { k: 5, prices: [100, 99, 98, 97, 1] },
      { k: 5, prices: [1, 100, 2, 200, 3, 300, 4, 400, 5, 500] },
      { k: 5, prices: [1, 100, 101, 200, 201, 300, 301, 400, 401, 500] },
      { k: 4, prices: [1, 25, 24, 23, 12, 36, 14, 40, 31, 41, 5] },
      { k: 2, prices: [1, 25, 24, 23, 12, 36, 14, 40, 31, 41, 5] },
    ],
  },
  {
    id: 'palindrome-partitioning-min-cuts',
    name: 'Palindrome Partitioning Min Cuts',
    category: 'Dynamic Programming',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Given a non-empty string, write a function that returns the minimum number of\n  cuts needed to perform on the string such that each remaining substring is a\n  palindrome.\n</p>\n<p>\n  A palindrome is defined as a string that\'s written the same forward as\n  backward. Note that single-character strings are palindromes.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">string</span> = "noonabbad"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n2 <span class="CodeEditor-promptComment">// noon | abba | d"</span>\n</pre>\n</div>',
    hints: [
      '<p>\nTry building a two-dimensional array of the palindromicities of all substrings of the input string. Let the value stored at row i and at column j represent the palindromicity of the substring starting at index i and ending at index j.\n</p>\n',
      '\n<p>\nChecking for palindromicity is typically an O(n) time operation. Can you eliminate this step and build the same two-dimensional array mentioned in Hint #1 a different way? Realize that the substring whose starting and ending indices are (i, j) is only a palindrome if string[i] is equal to string[j] and if the substring denoted by (i + 1, j - 1) is also a palindrome.\n</p>\n',
      '\n<p>\nBuild a one-dimensional array of the same length as the input string. At each index i in this array compute and store the minimum number of cuts needed for the substring whose starting and ending indices are (0, i). Use previously calculated values as well as the two-dimensional array mentioned in Hint #1 to find each value in this array.\n</p>',
    ],
    customInputVars: [
      {
        name: 'string',
        example: 'noonabbad',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function palindromePartitioningMinCuts(string) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.palindromePartitioningMinCuts = palindromePartitioningMinCuts;\n',
      solutions: [
        '// O(n^3) time | O(n^2) space\nfunction palindromePartitioningMinCuts(string) {\n  const palindromes = new Array(string.length).fill(1).map(row => []);\n  for (let i = 0; i < string.length; i++) {\n    for (let j = i; j < string.length; j++) {\n      palindromes[i][j] = isPalindrome(string.slice(i, j + 1));\n    }\n  }\n  const cuts = new Array(string.length);\n  cuts.fill(Infinity);\n  for (let i = 0; i < string.length; i++) {\n    if (palindromes[0][i]) {\n      cuts[i] = 0;\n    } else {\n      cuts[i] = cuts[i - 1] + 1;\n      for (let j = 1; j < i; j++) {\n        if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n          cuts[i] = cuts[j - 1] + 1;\n        }\n      }\n    }\n  }\n  return cuts[cuts.length - 1];\n}\n\nfunction isPalindrome(string) {\n  let leftIdx = 0;\n  let rightIdx = string.length - 1;\n  while (leftIdx < rightIdx) {\n    if (string[leftIdx] !== string[rightIdx]) return false;\n    leftIdx++;\n    rightIdx--;\n  }\n  return true;\n}\n\nexports.palindromePartitioningMinCuts = palindromePartitioningMinCuts;\n',
        '// O(n^2) time | O(n^2) space\nfunction palindromePartitioningMinCuts(string) {\n  const palindromes = [];\n  for (let i = 0; i < string.length; i++) {\n    const row = [];\n    for (let j = 0; j < string.length; j++) {\n      if (i === j) {\n        row.push(true);\n      } else {\n        row.push(false);\n      }\n    }\n    palindromes.push(row);\n  }\n  for (let length = 2; length < string.length + 1; length++) {\n    for (let i = 0; i < string.length - length + 1; i++) {\n      const j = i + length - 1;\n      if (length === 2) {\n        palindromes[i][j] = string[i] === string[j];\n      } else {\n        palindromes[i][j] = string[i] === string[j] && palindromes[i + 1][j - 1];\n      }\n    }\n  }\n  const cuts = new Array(string.length);\n  cuts.fill(Infinity);\n  for (let i = 0; i < string.length; i++) {\n    if (palindromes[0][i]) {\n      cuts[i] = 0;\n    } else {\n      cuts[i] = cuts[i - 1] + 1;\n      for (let j = 1; j < i; j++) {\n        if (palindromes[j][i] && cuts[j - 1] + 1 < cuts[i]) {\n          cuts[i] = cuts[j - 1] + 1;\n        }\n      }\n    }\n  }\n  return cuts[cuts.length - 1];\n}\n\nexports.palindromePartitioningMinCuts = palindromePartitioningMinCuts;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.palindromePartitioningMinCuts('noonabbad')).to.deep.equal(2);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.palindromePartitioningMinCuts('noonabbad')).to.deep.equal(2);\n});\n",
    },
    bigO: 'O(n^2) time | O(n^2) space - where n is the length of the input string',
    tests: [
      { string: 'noonabbad' },
      { string: 'a' },
      { string: 'abba' },
      { string: 'abbba' },
      { string: 'abb' },
      { string: 'abbb' },
      { string: 'abcbm' },
      { string: 'ababbbabbababa' },
      { string: 'abbbacecffgbgffab' },
      { string: 'abcdefghijklmonpqrstuvwxyz' },
      { string: 'abcdefghijklmracecaronpqrstuvwxyz' },
    ],
  },
  {
    id: 'longest-increasing-subsequence',
    name: 'Longest Increasing Subsequence',
    category: 'Dynamic Programming',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Given a non-empty array of integers, write a function that returns the longest\n  strictly-increasing subsequence in the array.\n</p>\n<p>\n  A subsequence of an array is a set of numbers that aren\'t necessarily adjacent\n  in the array but that are in the same order as they appear in the array. For\n  instance, the numbers <span>[1, 3, 4]</span> form a subsequence of the array\n  <span>[1, 2, 3, 4]</span>, and so do the numbers <span>[2, 4]</span>. Note\n  that a single number in an array and the array itself are both valid\n  subsequences of the array.\n</p>\n<p>\n  You can assume that there will only be one longest increasing subsequence.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[-24, 2, 3, 5, 6, 35]\n</pre>\n</div>',
    hints: [
      '<p>\nTry building an array of the same length as the input array. At each index in this new array, store the length of the longest increasing subsequence ending with the number found at that index in the input array.\n</p>\n',
      '\n<p>\nCan you efficiently keep track of potential sequences in another array? Instead of storing entire sequences, try storing the indices of previous numbers. For example, at index 3 in this other array, store the index of the before-last number in the longest increasing subsequence ending with the number at index 3.\n</p>\n',
      "\n<p>\nYou can optimize your algorithm by taking a slightly different approach. Instead of building the array mentioned in Hint #1, try building an array whose indices represent lengths of subsequences and whose values represent the smallest numbers in the input array that can end a subsequence of a given length. Traverse the input array, and for each number determine what the length L of the longest increasing subsequence ending with that number is; store the position of that number at index L in the new array that you're building. Find a way to use binary search to build this array.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35],
        schema: { items: { type: 'integer' }, minItems: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function longestIncreasingSubsequence(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestIncreasingSubsequence = longestIncreasingSubsequence;\n',
      solutions: [
        '// O(n^2) time | O(n) space\nfunction longestIncreasingSubsequence(array) {\n  const sequences = new Array(array.length);\n  const lengths = array.map(num => 1);\n  let maxLengthIdx = 0;\n  for (let i = 0; i < array.length; i++) {\n    const currentNum = array[i];\n    for (let j = 0; j < i; j++) {\n      const otherNum = array[j];\n      if (otherNum < currentNum && lengths[j] + 1 >= lengths[i]) {\n        lengths[i] = lengths[j] + 1;\n        sequences[i] = j;\n      }\n    }\n    if (lengths[i] >= lengths[maxLengthIdx]) maxLengthIdx = i;\n  }\n  return buildSequence(array, sequences, maxLengthIdx);\n}\n\nfunction buildSequence(array, sequences, currentIdx) {\n  const sequence = [];\n  while (currentIdx !== undefined) {\n    sequence.unshift(array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n\nexports.longestIncreasingSubsequence = longestIncreasingSubsequence;\n',
        '// O(nlogn) time | O(n) space\nfunction longestIncreasingSubsequence(array) {\n  const sequences = new Array(array.length);\n  const indices = new Array(array.length + 1);\n  let length = 0;\n  for (let i = 0; i < array.length; i++) {\n    const num = array[i];\n    const newLength = binarySearch(1, length, indices, array, num);\n    sequences[i] = indices[newLength - 1];\n    indices[newLength] = i;\n    length = Math.max(length, newLength);\n  }\n  return buildSequence(array, sequences, indices[length]);\n}\n\nfunction binarySearch(startIdx, endIdx, indices, array, num) {\n  if (startIdx > endIdx) return startIdx;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  if (array[indices[middleIdx]] < num) {\n    startIdx = middleIdx + 1;\n  } else {\n    endIdx = middleIdx - 1;\n  }\n  return binarySearch(startIdx, endIdx, indices, array, num);\n}\n\nfunction buildSequence(array, sequences, currentIdx) {\n  const sequence = [];\n  while (currentIdx !== undefined) {\n    sequence.unshift(array[currentIdx]);\n    currentIdx = sequences[currentIdx];\n  }\n  return sequence;\n}\n\nexports.longestIncreasingSubsequence = longestIncreasingSubsequence;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]))\n    .to.deep.equal([-24, 2, 3, 5, 6, 35]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.longestIncreasingSubsequence([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]))\n    .to.deep.equal([-24, 2, 3, 5, 6, 35]);\n});\n",
    },
    bigO: 'O(nlogn) time | O(n) space - where n is the length of the input array',
    tests: [
      { array: [5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35] },
      { array: [-1] },
      { array: [-1, 2] },
      { array: [-1, 2, 1, 2] },
      { array: [1, 5, -1, 10] },
      { array: [1, 5, -1, 0, 6, 2, 4] },
      { array: [3, 4, -1] },
      { array: [29, 2, 32, 12, 30, 31] },
      { array: [10, 22, 9, 33, 21, 61, 41, 60, 80] },
      { array: [100, 1, 2, 3, 4, 101] },
    ],
  },
  {
    id: 'numbers-in-pi',
    name: 'Numbers In Pi',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Given a string representation of the first n digits of Pi and a list of\n  positive integers (all in string format), write a function that returns the\n  smallest number of spaces that can be added to the n digits of Pi such that\n  all resulting numbers are found in the list of integers.\n</p>\n<p>\n  Note that a single number can appear multiple times in the resulting numbers.\n  For example, if Pi is <span>"3141"</span> and the numbers are\n  <span>["1", "3", "4"]</span>, the number <span>"1"</span> is allowed to appear\n  twice in the list of resulting numbers after three spaces are added:\n  <span>"3 | 1 | 4 | 1"</span>.\n</p>\n<p>\n  If no number of spaces to be added exists such that all resulting numbers are\n  found in the list of integers, the function should return\n  <span>-1</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">pi</span> = "3141592653589793238462643383279",\n<span class="CodeEditor-promptParameter">numbers</span> = ["314159265358979323846", "26433", "8", "3279", "314159265", "35897932384626433832", "79"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n2 <span class="CodeEditor-promptComment">// "314159265 | 35897932384626433832 | 79"</span>\n</pre>\n</div>',
    hints: [
      "<p>\nYou'll need to look numbers up quickly; is the input array the best data structure for this?\n</p>\n",
      '\n<p>\nDump every favorite number in a hash table for fast lookup. Iterate through the digits of Pi, checking if every prefix of the n digits is a favorite number. What should you do if you find that a prefix of the n digits of Pi is a favorite number?\n</p>\n',
      "\n<p>\nGoing off of Hint #2, if you find a prefix of the n digits of Pi that is a favorite number, try adding 1 space after it and then recursively calculating the smallest number of spaces in the suffix that comes after it. Do this for every prefix, and you'll find the answer. Can this method be optimized with a cache?\n</p>",
    ],
    customInputVars: [
      {
        name: 'pi',
        example: '3141592653589793238462643383279',
        schema: { type: 'string' },
      },
      {
        name: 'numbers',
        example: [
          '314159265358979323846',
          '26433',
          '8',
          '3279',
          '314159265',
          '35897932384626433832',
          '79',
        ],
        schema: { items: { type: 'string' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function numbersInPi(pi, numbers) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.numbersInPi = numbersInPi;\n',
      solutions: [
        '// O(n^3 + m) time | O(n + m) space - where n is the number of digits in Pi and m is the number of favorite numbers\nfunction numbersInPi(pi, numbers) {\n  const numbersTable = {};\n  for (const number of numbers) {\n    numbersTable[number] = true;\n  }\n  const minSpaces = getMinSpaces(pi, numbersTable, {}, 0);\n  return minSpaces === Infinity ? -1 : minSpaces;\n}\n\nfunction getMinSpaces(pi, numbersTable, cache, idx) {\n  if (idx === pi.length) return -1;\n  if (idx in cache) return cache[idx];\n  let minSpaces = Infinity;\n  for (let i = idx; i < pi.length; i++) {\n    const prefix = pi.slice(idx, i + 1);\n    if (prefix in numbersTable) {\n      const minSpacesInSuffix = getMinSpaces(pi, numbersTable, cache, i + 1);\n      minSpaces = Math.min(minSpaces, minSpacesInSuffix + 1);\n    }\n  }\n  cache[idx] = minSpaces;\n  return cache[idx];\n}\n\nexports.numbersInPi = numbersInPi;\n',
        '// O(n^3 + m) time | O(n + m) space - where n is the number of digits in Pi and m is the number of favorite numbers\nfunction numbersInPi(pi, numbers) {\n  const numbersTable = {};\n  for (const number of numbers) {\n    numbersTable[number] = true;\n  }\n  const cache = {};\n  for (let i = pi.length - 1; i >= 0; i--) {\n    getMinSpaces(pi, numbersTable, cache, i);\n  }\n  return cache[0] === Infinity ? -1 : cache[0];\n}\n\nfunction getMinSpaces(pi, numbersTable, cache, idx) {\n  if (idx === pi.length) return -1;\n  if (idx in cache) return cache[idx];\n  let minSpaces = Infinity;\n  for (let i = idx; i < pi.length; i++) {\n    const prefix = pi.slice(idx, i + 1);\n    if (prefix in numbersTable) {\n      const minSpacesInSuffix = getMinSpaces(pi, numbersTable, cache, i + 1);\n      minSpaces = Math.min(minSpaces, minSpacesInSuffix + 1);\n    }\n  }\n  cache[idx] = minSpaces;\n  return cache[idx];\n}\n\nexports.numbersInPi = numbersInPi;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst PI = '3141592653589793238462643383279';\n\nit('Test Case #1', function () {\n  const numbers = [\n    '314159265358979323846',\n    '26433',\n    '8',\n    '3279',\n    '314159265',\n    '35897932384626433832',\n    '79',\n  ];\n  chai.expect(program.numbersInPi(PI, numbers)).to.deep.equal(2);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst PI = '3141592653589793238462643383279';\n\nit('Test Case #1', function () {\n  const numbers = [\n    '314159265358979323846',\n    '26433',\n    '8',\n    '3279',\n    '314159265',\n    '35897932384626433832',\n    '79',\n  ];\n  chai.expect(program.numbersInPi(PI, numbers)).to.deep.equal(2);\n});\n",
    },
    bigO: 'O(n^3 + m) time | O(n + m) space - where n is the number of digits in Pi and m is the number of favorite numbers',
    tests: [
      {
        numbers: [
          '314159265358979323846',
          '26433',
          '8',
          '3279',
          '314159265',
          '35897932384626433832',
          '79',
        ],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: ['314159265358979323846264338327', '9'],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: [
          '3',
          '314',
          '49',
          '9001',
          '15926535897',
          '14',
          '9323',
          '8462643383279',
          '4',
          '793',
        ],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: ['3141592653589793238462643383279'],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: ['3141', '1512', '159', '793', '12412451', '8462643383279'],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: [
          '314159265358979323846',
          '327',
          '26433',
          '8',
          '3279',
          '9',
          '314159265',
          '35897932384626433832',
          '79',
        ],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: [
          '141592653589793238462643383279',
          '314159265358979323846',
          '327',
          '26433',
          '8',
          '3279',
          '9',
          '314159265',
          '35897932384626433832',
          '79',
          '3',
        ],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: [
          '3',
          '1',
          '4',
          '592',
          '65',
          '55',
          '35',
          '8',
          '9793',
          '2384626',
          '83279',
        ],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: [
          '3',
          '1',
          '4',
          '592',
          '65',
          '55',
          '35',
          '8',
          '9793',
          '2384626',
          '383279',
        ],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: [
          '3',
          '141',
          '592',
          '65',
          '55',
          '35',
          '8',
          '9793',
          '2384626',
          '383279',
        ],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: [
          '3',
          '141',
          '592',
          '65',
          '55',
          '35',
          '8',
          '9793',
          '23846264',
          '383279',
        ],
        pi: '3141592653589793238462643383279',
      },
      {
        numbers: [
          '3',
          '141',
          '592',
          '65',
          '55',
          '35',
          '8',
          '9793',
          '23846264',
          '3832798',
        ],
        pi: '3141592653589793238462643383279',
      },
    ],
  },
  {
    id: 'longest-string-chain',
    name: 'Longest String Chain',
    category: 'Dynamic Programming',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Given a list of strings, write a function that returns the longest string\n  chain that can be built from those strings.\n</p>\n<p>\n  A string chain is defined as follows: let string <span>A</span> be a string in\n  the initial array; if removing any single character from string\n  <span>A</span> yields a new string <span>B</span> that\'s contained in the\n  initial array of strings, then strings <span>A</span> and <span>B</span> form\n  a string chain of length 2. Similarly, if removing any single character from\n  string <span>B</span> yields a new string <span>C</span> that\'s contained in\n  the initial array of strings, then strings <span>A</span>, <span>B</span>, and\n  <span>C</span> form a string chain of length 3.\n</p>\n<p>\n  The function should return the string chain in descending order (i.e., from\n  the longest string to the shortest one). Note that string chains of length 1\n  don\'t exist; if the list of strings doesn\'t contain any string chain formed by\n  two or more strings, the function should return an empty array.\n</p>\n<p>\n  You can assume that there will only be one longest string chain.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">strings</span> = ["abde", "abc", "abd", "abcde", "ade", "ae", "1abde", "abcdef"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n["abcdef", "abcde", "abde", "ade", "ae"]\n</pre>\n</div>',
    hints: [
      '<p>\nFor each string, you will have to remove every letter one at a time to see if the resulting strings are contained in the input list of strings. What data structure lends itself to quickly checking if these strings are located in the list of input strings?\n</p>\n',
      "\n<p>\nRealize that every string in the input list of strings potentially has a string chain (and therefore a longest string chain) that starts with itself. Compute all of these string chains and store them so that you don't have to compute them more than once.\n</p>\n",
      "\n<p>\nSort the input list of strings (from shortest to longest string) in order to simplify the problem. Iterate through the list of sorted strings, and for each string, compute the longest string chain that starts with itself. To do so, try removing every letter from each string and seeing if the resulting strings are in the input list of strings; you can do so in constant time by dumping every string in a hash table. In the hash table, store the longest string chain of every string as you compute them. As you iterate through longer strings, whenever you find a shorter string for which you've already computed the longest string chain, you can very quickly append the longer string to that already-computed string chain. Do this for every string, and you'll eventually find the longest string chain that you're looking for.\n</p>\n",
      "\n<p>\nDo you need to store every string's longest string chain mentioned in Hint #3, or can you store less information per string so as to take up less auxiliary space?\n</p>",
    ],
    customInputVars: [
      {
        name: 'strings',
        example: [
          'abde',
          'abc',
          'abd',
          'abcde',
          'ade',
          'ae',
          '1abde',
          'abcdef',
        ],
        schema: { items: { type: 'string' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function longestStringChain(strings) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.longestStringChain = longestStringChain;\n',
      solutions: [
        "// O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and\n// m is the length of the longest string\nfunction longestStringChain(strings) {\n  // For every string, imagine the longest string chain that starts with it.\n  // Set up every string to point to the next string in its respective longest\n  // string chain. Also keep track of the lengths of these longest string chains.\n  const stringChains = {};\n  for (const string of strings) {\n    stringChains[string] = {nextString: '', maxChainLength: 1};\n  }\n\n  // Sort the strings based on their length so that whenever we visit a\n  // string (as we iterate through them from left to right), we can\n  // already have computed the longest string chains of any smaller strings.\n  const sortedStrings = strings.sort((a, b) => a.length - b.length);\n  for (const string of sortedStrings) {\n    findLongestStringChain(string, stringChains);\n  }\n\n  return buildLongestStringChain(strings, stringChains);\n}\n\nfunction findLongestStringChain(string, stringChains) {\n  // Try removing every letter of the current string to see if the\n  // remaining strings form a string chain.\n  for (let i = 0; i < string.length; i++) {\n    const smallerString = getSmallerString(string, i);\n    if (!(smallerString in stringChains)) continue;\n    tryUpdateLongestStringChain(string, smallerString, stringChains);\n  }\n}\n\nfunction getSmallerString(string, index) {\n  return string.slice(0, index) + string.slice(index + 1);\n}\n\nfunction tryUpdateLongestStringChain(currentString, smallerString, stringChains) {\n  const smallerStringChainLength = stringChains[smallerString].maxChainLength;\n  const currentStringChainLength = stringChains[currentString].maxChainLength;\n  // Update the string chain of the current string only if the smaller string leads\n  // to a longer string chain.\n  if (smallerStringChainLength + 1 > currentStringChainLength) {\n    stringChains[currentString].maxChainLength = smallerStringChainLength + 1;\n    stringChains[currentString].nextString = smallerString;\n  }\n}\n\nfunction buildLongestStringChain(strings, stringChains) {\n  // Find the string that starts the longest string chain.\n  let maxChainLength = 0;\n  let chainStartingString = '';\n  for (const string of strings) {\n    if (stringChains[string].maxChainLength > maxChainLength) {\n      maxChainLength = stringChains[string].maxChainLength;\n      chainStartingString = string;\n    }\n  }\n\n  // Starting at the string found above, build the longest string chain.\n  const ourLongestStringChain = [];\n  let currentString = chainStartingString;\n  while (currentString !== '') {\n    ourLongestStringChain.push(currentString);\n    currentString = stringChains[currentString].nextString;\n  }\n\n  return ourLongestStringChain.length === 1 ? [] : ourLongestStringChain;\n}\n\nexports.longestStringChain = longestStringChain;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['abde', 'abc', 'abd', 'abcde', 'ade', 'ae', '1abde', 'abcdef'];\n  const expected = ['abcdef', 'abcde', 'abde', 'ade', 'ae'];\n  chai.expect(program.longestStringChain(strings)).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * m^2 + nlog(n)) time | O(nm) space - where n is the number of strings and m is the length of the longest string',
    tests: [
      {
        strings: [
          'abde',
          'abc',
          'abd',
          'abcde',
          'ade',
          'ae',
          '1abde',
          'abcdef',
        ],
      },
      { strings: ['abcdefg', 'abcdef', 'abcde', 'abcd', 'abc', 'ab', 'a'] },
      { strings: ['abcdefg', 'abdefg', 'abdfg', 'bdfg', 'bfg', 'bg', 'g'] },
      {
        strings: [
          'abcdefg',
          '1234',
          'abdefg',
          'abdfg',
          '123',
          '12',
          'bg',
          'g',
          '12345',
          '12a345',
        ],
      },
      {
        strings: [
          'abcdefg1',
          '1234c',
          'abdefg2',
          'abdfg',
          '123',
          '122',
          'bgg',
          'g',
          '1a2345',
          '12a345',
        ],
      },
      {
        strings: [
          'lgoprt',
          '12345678',
          'algoxpert',
          'abcde',
          '123468',
          'lgoxprt',
          'abde',
          'lgopt',
          '1234678',
          'ade',
          'ae',
          'algoxprt',
          'a',
          '1abde',
          'lgpt',
          '123456789',
          '234678',
          'algoexpert',
        ],
      },
      {
        strings: [
          '12345678',
          'algoxpert',
          '123468',
          'abde',
          'lgopt',
          '1234678',
          'ade',
          'ae',
          'a',
          '1abde',
          'lgpt',
          '123456789',
          '234678',
          'algoexpert',
        ],
      },
    ],
  },
  {
    id: 'square-of-zeroes',
    name: 'Square of Zeroes',
    category: 'Dynamic Programming',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a square-shaped n x n two-dimensional array of\n  only 1s and 0s and returns a boolean representing whether the input matrix\n  contains a square whose borders are made up of only 0s.\n</p>\n<p>\n  Note that a 1 x 1 square doesn\'t count as a valid square for the purpose of\n  this question. In other words, a singular <span>0</span> in the input matrix\n  doesn\'t constitute a square whose borders are made up of only 0s; a square of\n  zeroes has to be at least 2 x 2.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">matrix</span> = [\n  [1, 1, 1, 0, 1, 0],\n  [0, 0, 0, 0, 0, 1],\n  [0, 1, 1, 1, 0, 1],\n  [0, 0, 0, 1, 0, 1],\n  [0, 1, 1, 1, 0, 1],\n  [0, 0, 0, 0, 0, 1],\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\ntrue\n<span class="CodeEditor-promptComment">[</span>\n<span class="CodeEditor-promptComment">  [ ,  ,  ,  ,  ,  ],</span>\n<span class="CodeEditor-promptComment">  [0, 0, 0, 0, 0,  ],</span>\n<span class="CodeEditor-promptComment">  [0,  ,  ,  , 0,  ],</span>\n<span class="CodeEditor-promptComment">  [0,  ,  ,  , 0,  ],</span>\n<span class="CodeEditor-promptComment">  [0,  ,  ,  , 0,  ],</span>\n<span class="CodeEditor-promptComment">  [0, 0, 0, 0, 0,  ],</span>\n<span class="CodeEditor-promptComment">]</span>\n</pre>\n</div>',
    hints: [
      '<p>\nFor the purpose of this question, a square is defined by its topmost and bottommost rows and by its leftmost and rightmost columns. Given a pair of rows and a pair of columns that form a valid square, you can easily determine if the relevant square is a square of zeroes with two for loops.\n</p>\n',
      "\n<p>\nYou can apply the logic described in Hint #1 on every valid square in the input matrix in order to solve this problem. To find every valid square, you can either traverse the matrix iteratively with three nested loops, or you can start out at the outtermost square and recursively go inwards in the matrix, checking the squares obtained by moving each corner of a square inwards. If you go with this recursive approach, you'll need to use a cache to avoid doing many duplicate computations.\n</p>\n",
      '\n<p>\nThe operation described in Hint #1 is a computationally expensive one to have to repeat for every single square in the matrix. Can you precompute certain values to make this operation a constant-time operation?\n</p>\n',
      "\n<p>\nYou can make the operation described in Hint #1 a constant-time operation by precomputing some values in the matrix. Specifically, you can precompute two values for every element in the matrix: the number of 0s to the right of each element (including the element itself) and the number of 0s below each element (including the element itself). You can compute these values by iterating through the matrix starting at the bottom right corner and moving your way up by traversing each row from right to left; applying some simple dynamic programming techniques will allow you to build up these values trivially. Once you have these values precomputed, you can perform the operation described in Hint #1 in constant time just by looking at the number of 0s below any square's two top corners and the number of 0s to the right of the same square's two left corners.\n</p>",
    ],
    customInputVars: [
      {
        name: 'matrix',
        example: [
          [0, 0],
          [0, 0],
        ],
        schema: {
          items: {
            items: { maximum: 1, minimum: 0, type: 'integer' },
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function squareOfZeroes(matrix) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.squareOfZeroes = squareOfZeroes;\n',
      solutions: [
        "// O(n^4) time | O(n^3) space - where n is the height and width of the matrix\nfunction squareOfZeroes(matrix) {\n  const lastIdx = matrix.length - 1;\n  return hasSquareOfZeroes(matrix, 0, 0, lastIdx, lastIdx, {});\n}\n\n// r1 is the top row, c1 is the left column\n// r2 is the bottom row, c2 is the right column\nfunction hasSquareOfZeroes(matrix, r1, c1, r2, c2, cache) {\n  if (r1 >= r2 || c1 >= c2) return false;\n\n  const key = r1.toString() + '-' + c1.toString() + '-' + r2.toString() + '-' + c2.toString();\n  if (key in cache) return cache[key];\n\n  cache[key] =\n    isSquareOfZeroes(matrix, r1, c1, r2, c2) ||\n    hasSquareOfZeroes(matrix, r1 + 1, c1 + 1, r2 - 1, c2 - 1, cache) ||\n    hasSquareOfZeroes(matrix, r1, c1 + 1, r2 - 1, c2, cache) ||\n    hasSquareOfZeroes(matrix, r1 + 1, c1, r2, c2 - 1, cache) ||\n    hasSquareOfZeroes(matrix, r1 + 1, c1 + 1, r2, c2, cache) ||\n    hasSquareOfZeroes(matrix, r1, c1, r2 - 1, c2 - 1, cache);\n\n  return cache[key];\n}\n\n// r1 is the top row, c1 is the left column\n// r2 is the bottom row, c2 is the right column\nfunction isSquareOfZeroes(matrix, r1, c1, r2, c2) {\n  for (let row = r1; row < r2 + 1; row++) {\n    if (matrix[row][c1] !== 0 || matrix[row][c2] !== 0) return false;\n  }\n  for (let col = c1; col < c2 + 1; col++) {\n    if (matrix[r1][col] !== 0 || matrix[r2][col] !== 0) return false;\n  }\n  return true;\n}\n\nexports.squareOfZeroes = squareOfZeroes;\n",
        '// O(n^4) time | O(1) space - where n is the height and width of the matrix\nfunction squareOfZeroes(matrix) {\n  const n = matrix.length;\n  for (let topRow = 0; topRow < n; topRow++) {\n    for (let leftCol = 0; leftCol < n; leftCol++) {\n      let squareLength = 2;\n      while (squareLength <= n - leftCol && squareLength <= n - topRow) {\n        const bottomRow = topRow + squareLength - 1;\n        const rightCol = leftCol + squareLength - 1;\n        if (isSquareOfZeroes(matrix, topRow, leftCol, bottomRow, rightCol)) return true;\n        squareLength++;\n      }\n    }\n  }\n  return false;\n}\n\n// r1 is the top row, c1 is the left column\n// r2 is the bottom row, c2 is the right column\nfunction isSquareOfZeroes(matrix, r1, c1, r2, c2) {\n  for (let row = r1; row < r2 + 1; row++) {\n    if (matrix[row][c1] !== 0 || matrix[row][c2] !== 0) return false;\n  }\n  for (let col = c1; col < c2 + 1; col++) {\n    if (matrix[r1][col] !== 0 || matrix[r2][col] !== 0) return false;\n  }\n  return true;\n}\n\nexports.squareOfZeroes = squareOfZeroes;\n',
        "// O(n^3) time | O(n^3) space - where n is the height and width of the matrix\nfunction squareOfZeroes(matrix) {\n  const infoMatrix = preComputeNumOfZeroes(matrix);\n  const lastIdx = matrix.length - 1;\n  return hasSquareOfZeroes(infoMatrix, 0, 0, lastIdx, lastIdx, {});\n}\n\n// r1 is the top row, c1 is the left column\n// r2 is the bottom row, c2 is the right column\nfunction hasSquareOfZeroes(infoMatrix, r1, c1, r2, c2, cache) {\n  if (r1 >= r2 || c1 >= c2) return false;\n\n  const key = r1.toString() + '-' + c1.toString() + '-' + r2.toString() + '-' + c2.toString();\n  if (key in cache) return cache[key];\n\n  cache[key] =\n    isSquareOfZeroes(infoMatrix, r1, c1, r2, c2) ||\n    hasSquareOfZeroes(infoMatrix, r1 + 1, c1 + 1, r2 - 1, c2 - 1, cache) ||\n    hasSquareOfZeroes(infoMatrix, r1, c1 + 1, r2 - 1, c2, cache) ||\n    hasSquareOfZeroes(infoMatrix, r1 + 1, c1, r2, c2 - 1, cache) ||\n    hasSquareOfZeroes(infoMatrix, r1 + 1, c1 + 1, r2, c2, cache) ||\n    hasSquareOfZeroes(infoMatrix, r1, c1, r2 - 1, c2 - 1, cache);\n\n  return cache[key];\n}\n\n// r1 is the top row, c1 is the left column\n// r2 is the bottom row, c2 is the right column\nfunction isSquareOfZeroes(infoMatrix, r1, c1, r2, c2) {\n  const squareLength = c2 - c1 + 1;\n  const hasTopBorder = infoMatrix[r1][c1].numZeroesRight >= squareLength;\n  const hasLeftBorder = infoMatrix[r1][c1].numZeroesBelow >= squareLength;\n  const hasBottomBorder = infoMatrix[r2][c1].numZeroesRight >= squareLength;\n  const hasRightBorder = infoMatrix[r1][c2].numZeroesBelow >= squareLength;\n  return hasTopBorder && hasLeftBorder && hasBottomBorder && hasRightBorder;\n}\n\nfunction preComputeNumOfZeroes(matrix) {\n  const infoMatrix = matrix.map(row =>\n    row.map(value => {\n      const numZeroes = value === 0 ? 1 : 0;\n      return {numZeroesBelow: numZeroes, numZeroesRight: numZeroes};\n    }),\n  );\n\n  const lastIdx = matrix.length - 1;\n  for (let row = lastIdx; row >= 0; row--) {\n    for (let col = lastIdx; col >= 0; col--) {\n      if (matrix[row][col] === 1) continue;\n      if (row < lastIdx) {\n        infoMatrix[row][col].numZeroesBelow += infoMatrix[row + 1][col].numZeroesBelow;\n      }\n      if (col < lastIdx) {\n        infoMatrix[row][col].numZeroesRight += infoMatrix[row][col + 1].numZeroesRight;\n      }\n    }\n  }\n\n  return infoMatrix;\n}\n\nexports.squareOfZeroes = squareOfZeroes;\n",
        '// O(n^3) time | O(n^2) space - where n is the height and width of the matrix\nfunction squareOfZeroes(matrix) {\n  const infoMatrix = preComputeNumOfZeroes(matrix);\n  const n = matrix.length;\n  for (let topRow = 0; topRow < n; topRow++) {\n    for (let leftCol = 0; leftCol < n; leftCol++) {\n      let squareLength = 2;\n      while (squareLength <= n - leftCol && squareLength <= n - topRow) {\n        const bottomRow = topRow + squareLength - 1;\n        const rightCol = leftCol + squareLength - 1;\n        if (isSquareOfZeroes(infoMatrix, topRow, leftCol, bottomRow, rightCol)) return true;\n        squareLength++;\n      }\n    }\n  }\n  return false;\n}\n\n// r1 is the top row, c1 is the left column\n// r2 is the bottom row, c2 is the right column\nfunction isSquareOfZeroes(infoMatrix, r1, c1, r2, c2) {\n  const squareLength = c2 - c1 + 1;\n  const hasTopBorder = infoMatrix[r1][c1].numZeroesRight >= squareLength;\n  const hasLeftBorder = infoMatrix[r1][c1].numZeroesBelow >= squareLength;\n  const hasBottomBorder = infoMatrix[r2][c1].numZeroesRight >= squareLength;\n  const hasRightBorder = infoMatrix[r1][c2].numZeroesBelow >= squareLength;\n  return hasTopBorder && hasLeftBorder && hasBottomBorder && hasRightBorder;\n}\n\nfunction preComputeNumOfZeroes(matrix) {\n  const infoMatrix = matrix.map(row =>\n    row.map(value => {\n      const numZeroes = value === 0 ? 1 : 0;\n      return {numZeroesBelow: numZeroes, numZeroesRight: numZeroes};\n    }),\n  );\n\n  const lastIdx = matrix.length - 1;\n  for (let row = lastIdx; row >= 0; row--) {\n    for (let col = lastIdx; col >= 0; col--) {\n      if (matrix[row][col] === 1) continue;\n      if (row < lastIdx) {\n        infoMatrix[row][col].numZeroesBelow += infoMatrix[row + 1][col].numZeroesBelow;\n      }\n      if (col < lastIdx) {\n        infoMatrix[row][col].numZeroesRight += infoMatrix[row][col + 1].numZeroesRight;\n      }\n    }\n  }\n\n  return infoMatrix;\n}\n\nexports.squareOfZeroes = squareOfZeroes;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 1, 1, 0, 1, 0],\n    [0, 0, 0, 0, 0, 1],\n    [0, 1, 1, 1, 0, 1],\n    [0, 0, 0, 1, 0, 1],\n    [0, 1, 1, 1, 0, 1],\n    [0, 0, 0, 0, 0, 1],\n  ];\n  chai.expect(program.squareOfZeroes(matrix)).to.deep.equal(true);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 1, 1, 0, 1, 0],\n    [0, 0, 0, 0, 0, 1],\n    [0, 1, 1, 1, 0, 1],\n    [0, 0, 0, 1, 0, 1],\n    [0, 1, 1, 1, 0, 1],\n    [0, 0, 0, 0, 0, 1],\n  ];\n  chai.expect(program.squareOfZeroes(matrix)).to.deep.equal(true);\n});\n",
    },
    bigO: 'O(n^3) time | O(n^2) space - where n is the height and width of the matrix',
    tests: [
      {
        matrix: [
          [0, 0],
          [0, 0],
        ],
      },
      {
        matrix: [
          [1, 1, 0, 1],
          [1, 0, 0, 1],
          [0, 0, 0, 1],
          [1, 1, 1, 1],
        ],
      },
      {
        matrix: [
          [0, 1],
          [0, 0],
        ],
      },
      {
        matrix: [
          [0, 0, 0],
          [1, 0, 0],
          [0, 0, 0],
        ],
      },
      {
        matrix: [
          [0, 0, 0],
          [0, 1, 0],
          [0, 1, 0],
        ],
      },
      {
        matrix: [
          [0, 0, 0, 1],
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 1],
        ],
      },
      {
        matrix: [
          [0, 0, 0, 1],
          [0, 1, 1, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 1, 1, 0, 1, 0],
          [0, 0, 0, 0, 0, 1],
          [0, 1, 1, 1, 0, 1],
          [0, 0, 0, 1, 0, 1],
          [0, 1, 1, 1, 0, 1],
          [0, 0, 0, 0, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 1, 1, 0, 1, 0],
          [0, 0, 0, 0, 0, 1],
          [0, 1, 1, 1, 0, 1],
          [0, 0, 0, 1, 1, 1],
          [0, 1, 1, 1, 0, 1],
          [0, 0, 0, 0, 0, 1],
        ],
      },
      {
        matrix: [
          [0, 1, 0, 1, 1, 1],
          [0, 1, 0, 1, 1, 1],
          [0, 0, 0, 1, 1, 1],
          [1, 1, 1, 1, 1, 1],
          [0, 0, 0, 1, 1, 1],
        ],
      },
      {
        matrix: [
          [
            0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
        ],
      },
      {
        matrix: [
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
        ],
      },
      {
        matrix: [
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
        ],
      },
      {
        matrix: [
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
          [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1,
          ],
        ],
      },
    ],
  },
  {
    id: 'number-of-ways-to-traverse-graph',
    name: 'Number Of Ways To Traverse Graph',
    category: 'Dynamic Programming',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given two positive integers representing the width and height of a\n  grid-shaped, rectangular graph. Write a function that returns the number of\n  ways to reach the bottom right corner of the graph when starting at the top\n  left corner. Each move you take must either go down or right. In other words,\n  you can never move up or left in the graph.\n</p>\n<p>\n  For example, given the graph illustrated below, with\n  <span>width = 2</span> and <span>height = 3</span>, there are three ways to\n  reach the bottom right corner when starting at the top left corner:\n</p>\n<pre>\n _ _\n|_|_|\n|_|_|\n|_|_|\n</pre>\n<ol>\n  <li>Down, Down, Right</li>\n  <li>Right, Down, Down</li>\n  <li>Down, Right, Down</li>\n</ol>\n<p>\n  Note: you may assume that <span>width * height >= 2</span>. In other words,\n  the graph will never be a 1x1 grid.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">width</span> = 4\n<span class="CodeEditor-promptParameter">height</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n10\n</pre>\n</div>',
    hints: [
      '<p>\n  Think recursively. How many positions in the graph can access the bottom right\n  corner of the graph? In other words, what positions do you need to reach\n  before you can reach the bottom right corner?\n</p>\n',
      '\n<p>\n  The number of ways to reach any position in the graph is equal to the number\n  of ways to reach the position directly above it plus the number of ways to\n  reach the position directly to its left. This is because you can only travel\n  down and right.\n</p>\n',
      "\n<p>\n  Using the information in Hints #1 and #2, can you come up with an efficient\n  way to solve this problem that doesn't repeatedly perform the same work? What\n  does a dynamic-programming implementation look like?\n</p>\n",
      "\n<p>\n  To efficiency solve this problem, simply loop through the entire graph, column\n  by column, row by row, and calculate the number of ways to reach each\n  position. If you're on the top or left edge of the graph, there's only one way\n  to reach your position. If you're anywhere else in the graph, the number of\n  ways to reach your position is the number of ways to reach the position\n  directly above it plus the number of ways to reach the position directly to\n  its left (which you've already calculated and should be storing). Every time\n  you calculate the number of ways to reach a position, store the answer so that\n  you can use it later in the calculation of other positions.\n</p>",
    ],
    customInputVars: [
      { name: 'width', example: 4, schema: { minimum: 1, type: 'integer' } },
      { name: 'height', example: 3, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function numberOfWaysToTraverseGraph(width, height) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.numberOfWaysToTraverseGraph = numberOfWaysToTraverseGraph;\n',
      solutions: [
        '// O(2^(n + m)) time | O(n + m) space - where n\n// is the width of the graph and m is the height\nfunction numberOfWaysToTraverseGraph(width, height) {\n  if (width === 1 || height === 1) return 1;\n\n  return (\n    numberOfWaysToTraverseGraph(width - 1, height) + numberOfWaysToTraverseGraph(width, height - 1)\n  );\n}\n\n// Do not edit the line below.\nexports.numberOfWaysToTraverseGraph = numberOfWaysToTraverseGraph;\n',
        '// O(n * m) time | O(n * m) space - where n\n// is the width of the graph and m is the height\nfunction numberOfWaysToTraverseGraph(width, height) {\n  const numberOfWays = [];\n  for (let i = 0; i < height + 1; i++) {\n    numberOfWays.push([]);\n    for (let j = 0; j < width + 1; j++) {\n      numberOfWays[i].push(0);\n    }\n  }\n\n  for (let widthIdx = 1; widthIdx < width + 1; widthIdx++) {\n    for (let heightIdx = 1; heightIdx < height + 1; heightIdx++) {\n      if (widthIdx === 1 || heightIdx === 1) {\n        numberOfWays[heightIdx][widthIdx] = 1;\n      } else {\n        const waysLeft = numberOfWays[heightIdx][widthIdx - 1];\n        const waysUp = numberOfWays[heightIdx - 1][widthIdx];\n        numberOfWays[heightIdx][widthIdx] = waysLeft + waysUp;\n      }\n    }\n  }\n\n  return numberOfWays[height][width];\n}\n\n// Do not edit the line below.\nexports.numberOfWaysToTraverseGraph = numberOfWaysToTraverseGraph;\n',
        '// O(n + m) time | O(1) space - where n is\n// the width of the graph and m is the height\nfunction numberOfWaysToTraverseGraph(width, height) {\n  const xDistanceToCorner = width - 1;\n  const yDistanceToCorner = height - 1;\n\n  // The number of permutations of right and down movements\n  // is the number of ways to reach the bottom right corner.\n  const numerator = factorial(xDistanceToCorner + yDistanceToCorner);\n  const denominator = factorial(xDistanceToCorner) * factorial(yDistanceToCorner);\n  return Math.floor(numerator / denominator);\n}\n\nfunction factorial(num) {\n  let result = 1;\n\n  for (let n = 2; n < num + 1; n++) {\n    result *= n;\n  }\n\n  return result;\n}\n\n// Do not edit the line below.\nexports.numberOfWaysToTraverseGraph = numberOfWaysToTraverseGraph;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const width = 4;\n  const height = 3;\n  const expected = 10;\n  const actual = program.numberOfWaysToTraverseGraph(width, height);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const width = 4;\n  const height = 3;\n  const expected = 10;\n  const actual = program.numberOfWaysToTraverseGraph(width, height);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n + m) time | O(1) space - where n is the width of the graph and m is the height',
    tests: [
      { height: 3, width: 4 },
      { height: 2, width: 3 },
      { height: 3, width: 2 },
      { height: 5, width: 5 },
      { height: 6, width: 5 },
      { height: 5, width: 7 },
      { height: 2, width: 10 },
      { height: 2, width: 11 },
      { height: 9, width: 5 },
      { height: 7, width: 6 },
      { height: 5, width: 8 },
      { height: 2, width: 2 },
      { height: 1, width: 2 },
      { height: 2, width: 1 },
      { height: 3, width: 3 },
    ],
  },
  {
    id: 'maximum-sum-submatrix',
    name: 'Maximum Sum Submatrix',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array (a matrix) of potentially unequal height\n  and width that\'s filled with integers. You\'re also given a positive integer\n  <span>size</span>. Write a function that returns the maximum sum that can be\n  generated from a submatrix with dimensions <span>size * size</span>.\n</p>\n<p>For example, consider the following matrix:</p>\n<pre>\n[\n  [2, 4],\n  [5, 6],\n  [-3, 2],\n]\n</pre>\n<p>If <span>size = 2</span>, then the 2x2 submatrices to consider are:</p>\n<pre>\n[2, 4]\n[5, 6]\n------\n[5, 6]\n[-3, 2]\n</pre>\n<p>\n  The sum of the elements in the first submatrix is <span>17</span>, and the sum\n  of the elements in the second submatrix is <span>10</span>. In this example,\n  your function should return <span>17</span>.\n</p>\n<p>\n  Note: <span>size</span> will always be at least <span>1</span>, and the\n  dimensions of the input <span>matrix</span> will always be at least\n  <span>size * size</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">matrix</span> = \n[\n  [5, 3, -1, 5],\n  [-7, 3, 7, 4],\n  [12, 8, 0, 0],\n  [1, -8, -8, 2],\n]\n<span class="CodeEditor-promptParameter">size</span> = 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n18\n<span class="CodeEditor-promptComment">// [</span>\n<span class="CodeEditor-promptComment">//   [., ., ., .],</span>\n<span class="CodeEditor-promptComment">//   [., 3, 7, .],</span>\n<span class="CodeEditor-promptComment">//   [., 8, 0, .],</span>\n<span class="CodeEditor-promptComment">//   [., ., ., .],</span>\n<span class="CodeEditor-promptComment">// ]</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  The brute-force approach to solve this problem involves simply considering all\n  possible submatrices of size <span>size * size</span>, determining their sums,\n  and finally returning the maximum sum. This approach is acceptable, but it\n  isn't optimal. Why isn't it optimal?\n</p>\n",
      "\n<p>\n  The approach stated in Hint #1 isn't optimal because it repeats some\n  additions. When considering submatrices of any size larger than\n  <span>1</span>, it's almost always the case that some these matrices will have\n  overlapping elements, meaning that we'll repeatedly add up the same numbers.\n  If we were to use the brute-force approach, we would get a time complexity of\n  <span>O(width * height * size)</span>. To achieve a more optimal time\n  complexity, we need to avoid readding elements that have already been added.\n  Can you think of a way to solve this problem in\n  <span>O(width * height)</span> time?\n</p>\n",
      '\n<p>\n  To avoid doing repeated addition, we have to use auxiliary space. Ideally,\n  this extra space will allow us to determine the sum of a submatrix of any size\n  in constant time. Start by creating a matrix with the same dimensions as the\n  input matrix (we call this matrix <span>sums</span>). The element at position\n  <span>i, j</span> (where <span>i</span> is the row and <span>j</span> is the\n  column) in this new matrix should be the sum of all the elements in the\n  submatrix whose top left corner is at <span>0, 0</span> and whose bottom right\n  corner is at <span>i, j</span>. How can you quickly fill up this new matrix,\n  and how can you then use it to determine the sum of a submatrix of any size in\n  constant time?\n</p>\n',
      "\n<p>\n  The sum of a matrix whose bottom right corner is at <span>i, j</span> (where\n  <span>size &lt;= i &lt;= j</span>) is simply\n  <span>sums[i][j] - sums[i - size][j] - sums[i][j - size] + sums[i - size][j - size]</span>.\n  See the Conceptual Overview section of this question's video explanation\n  for a more in-depth explanation.\n</p>",
    ],
    customInputVars: [
      {
        name: 'matrix',
        example: [
          [5, 3, -1, 5],
          [-7, 3, 7, 4],
          [12, 8, 0, 0],
          [1, -8, -8, 2],
        ],
        schema: {
          items: { items: { type: 'integer' }, minItems: 1, type: 'array' },
          minItems: 1,
          type: 'array',
        },
      },
      { name: 'size', example: 2, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function maximumSumSubmatrix(matrix, size) {\n  // Write your code here.\n  return 0;\n}\n\n// Do not edit the line below.\nexports.maximumSumSubmatrix = maximumSumSubmatrix;\n',
      solutions: [
        '// O(w * h) time | O(w * h) space - where w is\n// the width of the matrix and h is the height\nfunction maximumSumSubmatrix(matrix, size) {\n  const sums = createSumMatrix(matrix);\n  let maxSubMatrixSum = -Infinity;\n\n  for (let row = size - 1; row < matrix.length; row++) {\n    for (let col = size - 1; col < matrix[row].length; col++) {\n      let total = sums[row][col];\n\n      const touchesTopBorder = row - size < 0;\n      if (!touchesTopBorder) total -= sums[row - size][col];\n\n      const touchesLeftBorder = col - size < 0;\n      if (!touchesLeftBorder) total -= sums[row][col - size];\n\n      const touchesTopOrLeftBorder = touchesTopBorder || touchesLeftBorder;\n      if (!touchesTopOrLeftBorder) total += sums[row - size][col - size];\n\n      maxSubMatrixSum = Math.max(maxSubMatrixSum, total);\n    }\n  }\n\n  return maxSubMatrixSum;\n}\n\nfunction createSumMatrix(matrix) {\n  const sums = [];\n  for (let row = 0; row < matrix.length; row++) {\n    sums.push([]);\n    for (let col = 0; col < matrix[row].length; col++) {\n      sums[row].push(0);\n    }\n  }\n  sums[0][0] = matrix[0][0];\n\n  // Fill the first row.\n  for (let idx = 1; idx < matrix[0].length; idx++) {\n    sums[0][idx] = sums[0][idx - 1] + matrix[0][idx];\n  }\n\n  // Fill the first column.\n  for (let idx = 1; idx < matrix.length; idx++) {\n    sums[idx][0] = sums[idx - 1][0] + matrix[idx][0];\n  }\n\n  // Fill the rest of the matrix.\n  for (let row = 1; row < matrix.length; row++) {\n    for (let col = 1; col < matrix[row].length; col++) {\n      sums[row][col] =\n        sums[row - 1][col] + sums[row][col - 1] - sums[row - 1][col - 1] + matrix[row][col];\n    }\n  }\n\n  return sums;\n}\n\n// Do not edit the line below.\nexports.maximumSumSubmatrix = maximumSumSubmatrix;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [5, 3, -1, 5],\n    [-7, 3, 7, 4],\n    [12, 8, 0, 0],\n    [1, -8, -8, 2],\n  ];\n  const size = 2;\n  const expected = 18;\n  const actual = program.maximumSumSubmatrix(matrix, size);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [5, 3, -1, 5],\n    [-7, 3, 7, 4],\n    [12, 8, 0, 0],\n    [1, -8, -8, 2],\n  ];\n  const size = 2;\n  const expected = 18;\n  const actual = program.maximumSumSubmatrix(matrix, size);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(w * h) time | O(w * h) space - where w is the width of the matrix and h is the height',
    tests: [
      {
        matrix: [
          [5, 3, -1, 5],
          [-7, 3, 7, 4],
          [12, 8, 0, 0],
          [1, -8, -8, 2],
        ],
        size: 2,
      },
      {
        matrix: [
          [3, -4, 6, -5, 1],
          [1, -2, 8, -4, -2],
          [3, -8, 9, 3, 1],
          [-7, 3, 4, 2, 7],
          [-3, 7, -5, 7, -6],
        ],
        size: 3,
      },
      {
        matrix: [
          [2, 4],
          [5, 6],
          [-3, 2],
        ],
        size: 2,
      },
      {
        matrix: [
          [3, -4, 6, -5, 1],
          [1, -2, 8, -4, -2],
          [3, -8, 9, 3, 1],
          [-7, 3, 4, 2, 7],
          [-3, 7, -5, 7, -6],
          [2, 4, 5, 2, 3],
        ],
        size: 4,
      },
      { matrix: [[1]], size: 1 },
      {
        matrix: [
          [1, 1],
          [1, 1],
        ],
        size: 2,
      },
      {
        matrix: [
          [1, 1, 2, -1],
          [1, 1, 2, -1],
        ],
        size: 2,
      },
      {
        matrix: [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
        size: 5,
      },
      {
        matrix: [
          [2, 1, 1, 1, 1, 4, -1, 1, 1, 5],
          [1, -1, 1, 1, 1, 1, -1, 1, 4, 1],
          [-50, 12, -1, 1, 5, 1, -1, 1, 1, 1],
          [-52, 99, 1, -1, 1, 1, -1, 1, 1, 1],
          [1, -10, -287, 9, -1, 1, -1, 1, 1, 1],
          [1, 2, 1, 8, 1, -1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, -1, 1, 1, 1],
        ],
        size: 6,
      },
      {
        matrix: [
          [-1, -2, -3, -4, -5],
          [-5, -4, -3, -2, -1],
          [-1, -2, -3, -4, -5],
        ],
        size: 2,
      },
      {
        matrix: [
          [-1, -2, -3, -4, -5],
          [-5, -4, -3, -2, -1],
          [-1, -2, -3, -4, -5],
          [-5, -4, -3, -2, -1],
          [-5, -4, -3, -2, -1],
        ],
        size: 3,
      },
      {
        matrix: [
          [-1, -2, -3, -4, -5],
          [1, 1, 1, 1, 1],
          [-1, -10, -10, -4, -5],
          [5, 5, 5, 5, 5],
          [-5, -4, -3, -10, -1],
        ],
        size: 1,
      },
      {
        matrix: [
          [-1, -2, -3, -4, -5],
          [1, 1, 1, 1, 1],
          [-1, -10, -10, -4, -5],
          [5, 5, 5, 5, 5],
          [-5, -4, -3, -10, -1],
        ],
        size: 2,
      },
      {
        matrix: [
          [3, -4, 6, -5, 1],
          [1, -2, 8, -4, -2],
          [3, -8, 9, 3, 1],
          [-7, 3, 4, 2, 7],
          [-3, 7, -5, 7, -6],
        ],
        size: 4,
      },
      {
        matrix: [
          [3, -4, 6, -5, 1],
          [1, -2, 8, -4, -2],
          [3, -8, 9, 3, 1],
          [-7, 3, 4, 2, 7],
          [-3, 7, -5, 7, -6],
        ],
        size: 5,
      },
      {
        matrix: [
          [22, 24, -9, 23],
          [12, 10, -19, 35],
          [45, -20, -20, 99],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [-100, 200, -50, 5],
          [5, 6, 7, 8],
        ],
        size: 3,
      },
    ],
  },
  {
    id: 'maximize-expression',
    name: 'Maximize Expression',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of integers and returns the largest\n  possible value for the expression\n  <span>array[a] - array[b] + array[c] - array[d]</span>, where <span>a</span>,\n  <span>b</span>, <span>c</span>, and <span>d</span> are indices of the array\n  and <span>a &lt; b &lt; c &lt; d</span>.\n</p>\n<p>\n  If the input array has fewer than <span>4</span> elements, your function\n  should return <span>0</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [3, 6, 1, -3, 2, 7]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n4\n<span class="CodeEditor-promptComment">// Choose a = 1, b = 3, c = 4, and d = 5</span>\n<span class="CodeEditor-promptComment">// -> 6 - (-3) + 2 - 7 = 4</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  The brute-force approach to solving this problem is to simply iterate through\n  every valid choice of <span>a</span>, <span>b</span>, <span>c</span>, and\n  <span>d</span> and to evaluate the expression at each iteration. While doing\n  this, you can keep track of the maximum value that you find and return it\n  after considering all possibilities. This solution runs in\n  <span>O(n^4)</span> time; can you think of a way to solve this faster?\n</p>\n',
      "\n<p>\n  You can solve this problem using dynamic programming with a time complexity of\n  <span>O(n)</span>; however, you'll need to use external space.\n</p>\n",
      '\n<p>\n  If you know what the maximum possible value of <span>a</span> is at each index\n  in the array, you can find the maximum possible value of <span>a - b</span> at\n  each individual index in the array in <span>O(1)</span> time (or in\n  <span>O(n)</span> time for all indices). The same thing holds for finding the\n  maximum possible value of <span>a - b + c</span> if you know the maximum\n  possible value of <span>a - b</span> at each index. How does this fact help\n  you solve the entire problem in <span>O(n)</span> time?\n</p>\n',
      "\n<p>\n  Start by finding the maximum possible value of <span>a</span> at each index in\n  the array, meaning the maximum value of <span>a</span> that you can obtain at\n  each index <span>i</span> if <span>a</span> is chosen from an index between\n  <span>0</span> and <span>i</span>, inclusive. Store all of these values in an\n  array, and use them to help you determine the maximum possible value of\n  <span>a - b</span> at each index. Do the same for\n  <span>a - b + c</span> (using the results from <span>a - b</span>) and\n  <span>a - b + c - d</span> (using the results from <span>a - b + c</span>).\n  Once you make it to <span>a - b + c - d</span>, you'll be able to determine\n  the maximum value of the expression.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [3, 6, 1, -3, 2, 7],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function maximizeExpression(array) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.maximizeExpression = maximizeExpression;\n',
      solutions: [
        '// O(n^4) time | O(1) space - where n is the length of the array\nfunction maximizeExpression(array) {\n  if (array.length < 4) return 0;\n\n  let maximumValueFound = -Infinity;\n\n  for (let a = 0; a < array.length; a++) {\n    const aValue = array[a];\n    for (let b = a + 1; b < array.length; b++) {\n      const bValue = array[b];\n      for (let c = b + 1; c < array.length; c++) {\n        const cValue = array[c];\n        for (let d = c + 1; d < array.length; d++) {\n          const dValue = array[d];\n          const expressionValue = evaluateExpression(aValue, bValue, cValue, dValue);\n          maximumValueFound = Math.max(expressionValue, maximumValueFound);\n        }\n      }\n    }\n  }\n\n  return maximumValueFound;\n}\n\nfunction evaluateExpression(a, b, c, d) {\n  return a - b + c - d;\n}\n\n// Do not edit the line below.\nexports.maximizeExpression = maximizeExpression;\n',
        '// O(n) time | O(n) space - where n is the length of the array\nfunction maximizeExpression(array) {\n  if (array.length < 4) return 0;\n\n  const maxOfA = new Array(1).fill(array[0]);\n  const maxOfAMinusB = new Array(1).fill(-Infinity);\n  const maxOfAMinusBPlusC = new Array(2).fill(-Infinity);\n  const maxOfAMinusBPlusCMinusD = new Array(3).fill(-Infinity);\n\n  for (let idx = 1; idx < array.length; idx++) {\n    const currentMax = Math.max(maxOfA[idx - 1], array[idx]);\n    maxOfA.push(currentMax);\n  }\n\n  for (let idx = 1; idx < array.length; idx++) {\n    const currentMax = Math.max(maxOfAMinusB[idx - 1], maxOfA[idx - 1] - array[idx]);\n    maxOfAMinusB.push(currentMax);\n  }\n\n  for (let idx = 2; idx < array.length; idx++) {\n    const currentMax = Math.max(maxOfAMinusBPlusC[idx - 1], maxOfAMinusB[idx - 1] + array[idx]);\n    maxOfAMinusBPlusC.push(currentMax);\n  }\n\n  for (let idx = 3; idx < array.length; idx++) {\n    const currentMax = Math.max(\n      maxOfAMinusBPlusCMinusD[idx - 1],\n      maxOfAMinusBPlusC[idx - 1] - array[idx],\n    );\n    maxOfAMinusBPlusCMinusD.push(currentMax);\n  }\n\n  return maxOfAMinusBPlusCMinusD[maxOfAMinusBPlusCMinusD.length - 1];\n}\n\n// Do not edit the line below.\nexports.maximizeExpression = maximizeExpression;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [3, 6, 1, -3, 2, 7];\n  const expected = 4;\n  const actual = program.maximizeExpression(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [3, 6, 1, -3, 2, 7];\n  const expected = 4;\n  const actual = program.maximizeExpression(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of the array',
    tests: [
      { array: [3, 6, 1, -3, 2, 7] },
      { array: [3, 9, 10, 1, 30, 40] },
      { array: [40, 30, 1, 10, 9, 3] },
      { array: [-1, 2, -1, -2, -2, 1, -1] },
      { array: [10, 5, 10, 5] },
      { array: [0, 0, 0, 0, 0, 0, 0, 1, 1, 0] },
      { array: [34, 21, 22, 0, -98, -72, 100, 23] },
      { array: [5, 2, 2, 1, -2, 2, -9, 0] },
      { array: [1, 1, 1, 1] },
      { array: [1, -1, 1, -1] },
      { array: [3, 6, 1, 2, -9, -2, 1, 3, 4, -3, 2] },
      { array: [1, -1, 1, -1, -2] },
      { array: [3, -1, 1, -1, -2, 4, 5, -4] },
      { array: [-1, 2, -3, -3, 2, -1] },
      { array: [6, 2, 3, 4, 1, -1, -2, 3, 1, 7, 8, -8, 2, 5, 1] },
      { array: [5, 10, 5, 10] },
      { array: [2, 3] },
      { array: [2, 3, 4] },
      { array: [1] },
      { array: [] },
    ],
  },
  {
    id: 'binary-search',
    name: 'Binary Search',
    category: 'Searching',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a sorted array of integers as well as a target\n  integer. The function should use the Binary Search algorithm to determine if\n  the target integer is contained in the array and should return its index if it\n  is, otherwise <span>-1</span>.\n</p>\n<p>\n  If you\'re unfamiliar with Binary Search, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [0, 1, 21, 33, 45, 45, 61, 71, 72, 73]\n<span class="CodeEditor-promptParameter">target</span> = 33\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3\n</pre>\n</div>',
    hints: [
      '<p>\nThe Binary Search algorithm works by finding the number in the middle of the input array and comparing it to the target number. Given that the array is sorted, if this middle number is smaller than the target number, then the entire left part of the array is no longer worth exploring since the target number can no longer be in it; similarly, if the middle number is greater than the target number, then the entire right part of the array is no longer worth exploring. Applying this logic recursively eliminates half of the array until the number is found or until the array runs out of numbers.\n</p>\n',
      '\n<p>\nWrite a helper function that takes in two additional arguments: a left pointer and a right pointer representing the indices at the extremities of the array (or subarray) that you are applying Binary Search on. The first time this helper function is called, the left pointer should be zero and the right pointer should be the final index of the input array. To find the index of the middle number mentioned in Hint #1, simply round down the number obtained from: (left + right) / 2. Apply this logic recursively until you find the target number or until the left pointer becomes greater than the right pointer.\n</p>\n',
      '\n<p>\nCan you implement this algorithm iteratively? Are there any advantages to doing so?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      { name: 'target', example: 33, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function binarySearch(array, target) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.binarySearch = binarySearch;\n',
      solutions: [
        '// O(log(n)) time | O(log(n)) space\nfunction binarySearch(array, target) {\n  return binarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction binarySearchHelper(array, target, left, right) {\n  if (left > right) return -1;\n  const middle = Math.floor((left + right) / 2);\n  const potentialMatch = array[middle];\n  if (target === potentialMatch) {\n    return middle;\n  } else if (target < potentialMatch) {\n    return binarySearchHelper(array, target, left, middle - 1);\n  } else {\n    return binarySearchHelper(array, target, middle + 1, right);\n  }\n}\n\nexports.binarySearch = binarySearch;\n',
        '// O(log(n)) time | O(1) space\nfunction binarySearch(array, target) {\n  return binarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction binarySearchHelper(array, target, left, right) {\n  while (left <= right) {\n    const middle = Math.floor((left + right) / 2);\n    const potentialMatch = array[middle];\n    if (target === potentialMatch) {\n      return middle;\n    } else if (target < potentialMatch) {\n      right = middle - 1;\n    } else {\n      left = middle + 1;\n    }\n  }\n  return -1;\n}\n\nexports.binarySearch = binarySearch;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.binarySearch([0, 1, 21, 33, 45, 45, 61, 71, 72, 73], 33)).to.deep.equal(3);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.binarySearch([0, 1, 21, 33, 45, 45, 61, 71, 72, 73], 33)).to.deep.equal(3);\n});\n",
    },
    bigO: 'O(log(n)) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 33 },
      { array: [1, 5, 23, 111], target: 111 },
      { array: [1, 5, 23, 111], target: 5 },
      { array: [1, 5, 23, 111], target: 35 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 0 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 1 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 21 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 45 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 61 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 71 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 72 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 73 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73], target: 70 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73, 355], target: 355 },
      { array: [0, 1, 21, 33, 45, 45, 61, 71, 72, 73, 355], target: 354 },
      { array: [1, 5, 23, 111], target: 120 },
      { array: [5, 23, 111], target: 3 },
    ],
  },
  {
    id: 'find-three-largest-numbers',
    name: 'Find Three Largest Numbers',
    category: 'Searching',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of at least three integers and,\n  without sorting the input array, returns a sorted array of the three largest\n  integers in the input array.\n</p>\n<p>\n  The function should return duplicate integers if necessary; for example, it\n  should return <span>[10, 10, 12]</span> for an input array of\n  <span>[10, 5, 9, 10, 12]</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [141, 1, 17, -7, -17, -27, 18, 541, 8, 7, 7]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[18, 141, 541]\n</pre>\n</div>',
    hints: [
      '<p>\nCan you keep track of the three largest numbers in an array as you traverse the input array?\n</p>\n',
      '\n<p>\nFollowing the suggestion in Hint #1, try traversing the input array and updating the three largest numbers if necessary by shifting them accordingly.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [141, 1, 17, -7, -17, -27, 18, 541, 8, 7, 7],
        schema: { items: { type: 'integer' }, minItems: 3, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function findThreeLargestNumbers(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.findThreeLargestNumbers = findThreeLargestNumbers;\n',
      solutions: [
        '// O(n) time | O(1) space\nfunction findThreeLargestNumbers(array) {\n  const threeLargest = [null, null, null];\n  for (const num of array) {\n    updateLargest(threeLargest, num);\n  }\n  return threeLargest;\n}\n\nfunction updateLargest(threeLargest, num) {\n  if (threeLargest[2] === null || num > threeLargest[2]) {\n    shiftAndUpdate(threeLargest, num, 2);\n  } else if (threeLargest[1] === null || num > threeLargest[1]) {\n    shiftAndUpdate(threeLargest, num, 1);\n  } else if (threeLargest[0] === null || num > threeLargest[0]) {\n    shiftAndUpdate(threeLargest, num, 0);\n  }\n}\n\nfunction shiftAndUpdate(array, num, idx) {\n  for (let i = 0; i <= idx; i++) {\n    if (i === idx) {\n      array[i] = num;\n    } else {\n      array[i] = array[i + 1];\n    }\n  }\n}\n\nexports.findThreeLargestNumbers = findThreeLargestNumbers;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.findThreeLargestNumbers([141, 1, 17, -7, -17, -27, 18, 541, 8, 7, 7]))\n    .to.deep.equal([18, 141, 541]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.findThreeLargestNumbers([141, 1, 17, -7, -17, -27, 18, 541, 8, 7, 7]))\n    .to.deep.equal([18, 141, 541]);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [141, 1, 17, -7, -17, -27, 18, 541, 8, 7, 7] },
      { array: [55, 7, 8] },
      { array: [55, 43, 11, 3, -3, 10] },
      { array: [7, 8, 3, 11, 43, 55] },
      { array: [55, 7, 8, 3, 43, 11] },
      { array: [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7] },
      { array: [7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7] },
      { array: [-1, -2, -3, -7, -17, -27, -18, -541, -8, -7, 7] },
    ],
  },
  {
    id: 'search-in-sorted-matrix',
    name: 'Search In Sorted Matrix',
    category: 'Searching',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array (a matrix) of distinct integers and a\n  target integer. Each row in the matrix is sorted, and each column is also sorted; the\n  matrix doesn\'t necessarily have the same height and width.\n</p>\n<p>\n  Write a function that returns an array of the row and column indices of the\n  target integer if it\'s contained in the matrix, otherwise\n  <span>[-1, -1]</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">matrix</span> = [\n  [1, 4, 7, 12, 15, 1000],\n  [2, 5, 19, 31, 32, 1001],\n  [3, 8, 24, 33, 35, 1002],\n  [40, 41, 42, 44, 45, 1003],\n  [99, 100, 103, 106, 128, 1004],\n]\n<span class="CodeEditor-promptParameter">target</span> = 44\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[3, 3]\n</pre>\n</div>',
    hints: [
      "<p>\nPick any number in the matrix and compare it to the target number. If this number is bigger than the target number, what does that tell you about all of the other numbers in this number's row and this number's column? What about if this number is smaller than the target number?\n</p>\n",
      "\n<p>\nTry starting at the top right corner of the matrix, comparing the number there to the target number, and using whatever you gathered from Hint #1 to figure out what number to compare next if the top right number isn't equal to the target number. Continue until you find the target number or until you get past the extremities of the matrix.\n</p>",
    ],
    customInputVars: [
      {
        name: 'matrix',
        example: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        schema: {
          items: {
            items: { type: 'integer', uniqueItems: true },
            type: 'array',
          },
          type: 'array',
        },
      },
      { name: 'target', example: 44, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function searchInSortedMatrix(matrix, target) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.searchInSortedMatrix = searchInSortedMatrix;\n',
      solutions: [
        '// O(n + m) time | O(1) space\nfunction searchInSortedMatrix(matrix, target) {\n  let row = 0;\n  let col = matrix[0].length - 1;\n  while (row < matrix.length && col >= 0) {\n    if (matrix[row][col] > target) {\n      col--;\n    } else if (matrix[row][col] < target) {\n      row++;\n    } else {\n      return [row, col];\n    }\n  }\n  return [-1, -1];\n}\n\nexports.searchInSortedMatrix = searchInSortedMatrix;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 4, 7, 12, 15, 1000],\n    [2, 5, 19, 31, 32, 1001],\n    [3, 8, 24, 33, 35, 1002],\n    [40, 41, 42, 44, 45, 1003],\n    [99, 100, 103, 106, 128, 1004],\n  ];\n  chai.expect(program.searchInSortedMatrix(matrix, 44)).to.deep.equal([3, 3]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const matrix = [\n    [1, 4, 7, 12, 15, 1000],\n    [2, 5, 19, 31, 32, 1001],\n    [3, 8, 24, 33, 35, 1002],\n    [40, 41, 42, 44, 45, 1003],\n    [99, 100, 103, 106, 128, 1004],\n  ];\n  chai.expect(program.searchInSortedMatrix(matrix, 44)).to.deep.equal([3, 3]);\n});\n",
    },
    bigO: "O(n + m) time | O(1) space - where n is the length of the matrix's rows and m is the length of the matrix's columns",
    tests: [
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 44,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 1,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 2,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 4,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 15,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 12,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 32,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 99,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 100,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 40,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 128,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 106,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 45,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 24,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 43,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: -1,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 1000,
      },
      {
        matrix: [
          [1, 4, 7, 12, 15, 1000],
          [2, 5, 19, 31, 32, 1001],
          [3, 8, 24, 33, 35, 1002],
          [40, 41, 42, 44, 45, 1003],
          [99, 100, 103, 106, 128, 1004],
        ],
        target: 1004,
      },
    ],
  },
  {
    id: 'shifted-binary-search',
    name: 'Shifted Binary Search',
    category: 'Searching',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a sorted array of distinct integers as well as a target\n  integer. The caveat is that the integers in the array have been shifted by\n  some amount; in other words, they\'ve been moved to the left or to the right by\n  one or more positions. For example, <span>[1, 2, 3, 4]</span> might have\n  turned into <span>[3, 4, 1, 2]</span>.\n</p>\n<p>\n  The function should use a variation of the Binary Search algorithm to\n  determine if the target integer is contained in the array and should return\n  its index if it is, otherwise <span>-1</span>.\n</p>\n<p>\n  If you\'re unfamiliar with Binary Search, we recommend watching the Conceptual\n  Overview section of the Binary Search question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [45, 61, 71, 72, 73, 0, 1, 21, 33, 37]\n<span class="CodeEditor-promptParameter">target</span> = 33\n</pre>\n<h3>Sample Output</h3>\n<pre>8</pre>\n</div>',
    hints: [
      "<p>\nThe Binary Search algorithm involves a left pointer and a right pointer and using those pointers to find the middle number in an array. Unlike with a normal sorted array however, you cannot simply find the middle number of the array and compare it to the target here, because the shift could lead you in the wrong direction. Instead, realize that whenever you find the middle number in the array, the following two scenarios are possible (assuming the middle number is not equal to the target number, in which case you're done): either the left-pointer number is smaller than or equal to the middle number, or it is bigger. Figure out a way to eliminate half of the array depending on the scenario.\n</p>\n",
      "\n<p>\nIn the scenario where the left-pointer number is smaller than or equal to the middle number, two other scenarios can arise: either the target number is smaller than the middle number and greater than or equal to the left-pointer number, or it's not. In the first scenario, the right half of the array can be eliminated; in the second scenario, the left half can be eliminated. Figure out the scenarios that can arise if the left-pointer number is greater than the middle number and apply whatever logic you come up with recursively until you find the target number or until you run out of numbers in the array.\n</p>\n",
      '\n<p>\nCan you implement this algorithm iteratively? Are there any advantages to doing so?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37],
        schema: {
          items: { type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
      { name: 'target', example: 33, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function shiftedBinarySearch(array, target) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.shiftedBinarySearch = shiftedBinarySearch;\n',
      solutions: [
        '// O(log(n)) time | O(log(n)) space\nfunction shiftedBinarySearch(array, target) {\n  return shiftedBinarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction shiftedBinarySearchHelper(array, target, left, right) {\n  if (left > right) return -1;\n  const middle = Math.floor((left + right) / 2);\n  const potentialMatch = array[middle];\n  const leftNum = array[left];\n  const rightNum = array[right];\n  if (target === potentialMatch) {\n    return middle;\n  } else if (leftNum <= potentialMatch) {\n    if (target < potentialMatch && target >= leftNum) {\n      return shiftedBinarySearchHelper(array, target, left, middle - 1);\n    } else {\n      return shiftedBinarySearchHelper(array, target, middle + 1, right);\n    }\n  } else {\n    if (target > potentialMatch && target <= rightNum) {\n      return shiftedBinarySearchHelper(array, target, middle + 1, right);\n    } else {\n      return shiftedBinarySearchHelper(array, target, left, middle - 1);\n    }\n  }\n}\n\nexports.shiftedBinarySearch = shiftedBinarySearch;\n',
        '// O(log(n)) time | O(1) space\nfunction shiftedBinarySearch(array, target) {\n  return shiftedBinarySearchHelper(array, target, 0, array.length - 1);\n}\n\nfunction shiftedBinarySearchHelper(array, target, left, right) {\n  while (left <= right) {\n    const middle = Math.floor((left + right) / 2);\n    const potentialMatch = array[middle];\n    const leftNum = array[left];\n    const rightNum = array[right];\n    if (target === potentialMatch) {\n      return middle;\n    } else if (leftNum <= potentialMatch) {\n      if (target < potentialMatch && target >= leftNum) {\n        right = middle - 1;\n      } else {\n        left = middle + 1;\n      }\n    } else {\n      if (target > potentialMatch && target <= rightNum) {\n        left = middle + 1;\n      } else {\n        right = middle - 1;\n      }\n    }\n  }\n  return -1;\n}\n\nexports.shiftedBinarySearch = shiftedBinarySearch;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33))\n    .to.deep.equal(8);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.shiftedBinarySearch([45, 61, 71, 72, 73, 0, 1, 21, 33, 37], 33))\n    .to.deep.equal(8);\n});\n",
    },
    bigO: 'O(log(n)) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 33 },
      { array: [5, 23, 111, 1], target: 111 },
      { array: [111, 1, 5, 23], target: 5 },
      { array: [23, 111, 1, 5], target: 35 },
      { array: [61, 71, 72, 73, 0, 1, 21, 33, 37, 45], target: 33 },
      { array: [72, 73, 0, 1, 21, 33, 37, 45, 61, 71], target: 72 },
      { array: [71, 72, 73, 0, 1, 21, 33, 37, 45, 61], target: 73 },
      { array: [73, 0, 1, 21, 33, 37, 45, 61, 71, 72], target: 70 },
      { array: [33, 37, 45, 61, 71, 72, 73, 355, 0, 1, 21], target: 355 },
      { array: [33, 37, 45, 61, 71, 72, 73, 355, 0, 1, 21], target: 354 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 45 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 61 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 71 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 72 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 73 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 0 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 1 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 21 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 37 },
      { array: [45, 61, 71, 72, 73, 0, 1, 21, 33, 37], target: 38 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 0 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 1 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 21 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 33 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 37 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 45 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 61 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 71 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 72 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 73 },
      { array: [0, 1, 21, 33, 37, 45, 61, 71, 72, 73], target: 38 },
    ],
  },
  {
    id: 'search-for-range',
    name: 'Search For Range',
    category: 'Searching',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a sorted array of integers as well as a target\n  integer. The function should use a variation of the Binary Search algorithm to\n  find a range of indices in between which the target number is contained in the\n  array and should return this range in the form of an array.\n</p>\n<p>\n  The first number in the output array should represent the first index at which\n  the target number is located, while the second number should represent the\n  last index at which the target number is located. The function should return\n  <span>[-1, -1]</span> if the integer isn\'t contained in the array.\n</p>\n<p>\n  If you\'re unfamiliar with Binary Search, we recommend watching the Conceptual\n  Overview section of the Binary Search question\'s video explanation before\n  starting to code.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [0, 1, 21, 33, 45, 45, 45, 45, 45, 45, 61, 71, 73]\n<span class="CodeEditor-promptParameter">target</span> = 45\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[4, 9]\n</pre>\n</div>',
    hints: [
      '<p>\nThe Binary Search algorithm involves a left pointer and a right pointer and using those pointers to find the middle number in an array in an effort to find a target number. Unlike with normal Binary Search however, here you cannot simply find the middle number of the array, compare it to the target, and stop once you find it because you are looking for a range rather than a single number. Instead, realize that whenever you find the middle number in the array, the following two scenarios are possible: either the middle number is not equal to the target number, in which case you must proceed with normal Binary Search, or the middle number is equal to the target number, in which case you must figure out if this middle number is an extremity of the range or not.\n</p>\n',
      '\n<p>\nTry applying an altered version of Binary Search twice: once to find the left extremity of the range and once to find the right extremity of the range. How can you accomplish this? What are the time complexity implications of this approach?\n</p>\n',
      '\n<p>\nCan you implement this algorithm iteratively? Are there any advantages to doing so?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [0, 1, 21, 33, 45, 45, 45, 45, 45, 45, 61, 71, 73],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      { name: 'target', example: 45, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function searchForRange(array, target) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.searchForRange = searchForRange;\n',
      solutions: [
        '// O(log(n)) time | O(log(n)) space\nfunction searchForRange(array, target) {\n  const finalRange = [-1, -1];\n  alteredBinarySearch(array, target, 0, array.length - 1, finalRange, true);\n  alteredBinarySearch(array, target, 0, array.length - 1, finalRange, false);\n  return finalRange;\n}\n\nfunction alteredBinarySearch(array, target, left, right, finalRange, goLeft) {\n  if (left > right) return;\n  const mid = Math.floor((left + right) / 2);\n  if (array[mid] < target) {\n    alteredBinarySearch(array, target, mid + 1, right, finalRange, goLeft);\n  } else if (array[mid] > target) {\n    alteredBinarySearch(array, target, left, mid - 1, finalRange, goLeft);\n  } else {\n    if (goLeft) {\n      if (mid === 0 || array[mid - 1] !== target) {\n        finalRange[0] = mid;\n      } else {\n        alteredBinarySearch(array, target, left, mid - 1, finalRange, goLeft);\n      }\n    } else {\n      if (mid === array.length - 1 || array[mid + 1] !== target) {\n        finalRange[1] = mid;\n      } else {\n        alteredBinarySearch(array, target, mid + 1, right, finalRange, goLeft);\n      }\n    }\n  }\n}\n\nexports.searchForRange = searchForRange;\n',
        '// O(log(n)) time | O(1) space\nfunction searchForRange(array, target) {\n  const finalRange = [-1, -1];\n  alteredBinarySearch(array, target, 0, array.length - 1, finalRange, true);\n  alteredBinarySearch(array, target, 0, array.length - 1, finalRange, false);\n  return finalRange;\n}\n\nfunction alteredBinarySearch(array, target, left, right, finalRange, goLeft) {\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (array[mid] < target) {\n      left = mid + 1;\n    } else if (array[mid] > target) {\n      right = mid - 1;\n    } else {\n      if (goLeft) {\n        if (mid === 0 || array[mid - 1] !== target) {\n          finalRange[0] = mid;\n          return;\n        } else {\n          right = mid - 1;\n        }\n      } else {\n        if (mid === array.length - 1 || array[mid + 1] !== target) {\n          finalRange[1] = mid;\n          return;\n        } else {\n          left = mid + 1;\n        }\n      }\n    }\n  }\n}\n\nexports.searchForRange = searchForRange;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.searchForRange([0, 1, 21, 33, 45, 45, 45, 45, 45, 45, 61, 71, 73], 45))\n    .to.deep.equal([4, 9]);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.searchForRange([0, 1, 21, 33, 45, 45, 45, 45, 45, 45, 61, 71, 73], 45))\n    .to.deep.equal([4, 9]);\n});\n",
    },
    bigO: 'O(log(n)) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [0, 1, 21, 33, 45, 45, 45, 45, 45, 45, 61, 71, 73], target: 45 },
      { array: [5, 7, 7, 8, 8, 10], target: 5 },
      { array: [5, 7, 7, 8, 8, 10], target: 7 },
      { array: [5, 7, 7, 8, 8, 10], target: 8 },
      { array: [5, 7, 7, 8, 8, 10], target: 10 },
      { array: [5, 7, 7, 8, 8, 10], target: 9 },
      { array: [0, 1, 21, 33, 45, 45, 45, 45, 45, 45, 61, 71, 73], target: 47 },
      { array: [0, 1, 21, 33, 45, 45, 45, 45, 45, 45, 61, 71, 73], target: -1 },
      { array: [0, 1, 21, 33, 45, 45, 45, 45, 45, 45, 45, 45, 45], target: 45 },
    ],
  },
  {
    id: 'quickselect',
    name: 'Quickselect',
    category: 'Searching',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in an array of distinct integers as well as an\n  integer <span>k</span> and that returns the kth smallest integer in that array.\n</p>\n<p>The function should do this in linear time, on average.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [8, 5, 2, 9, 7, 6, 3]\n<span class="CodeEditor-promptParameter">k</span> = 3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5\n</pre>\n</div>',
    hints: [
      "<p>\nThe Quick Sort sorting algorithm works by picking a \"pivot\" number from an array, positioning every other number in the array in sorted order with respect to the pivot (all smaller numbers to the pivot's left; all bigger numbers to the pivot's right), and then repeating the same two steps on both sides of the pivot until the entire array is sorted. Apply the technique used in Quick Sort until the pivot element gets positioned in the kth place in the array, at which point you'll have found the answer to the problem.\n</p>\n",
      "\n<p>\nPick a random number from the input array (the first number, for instance) and let that number be the pivot. Iterate through the rest of the array using two pointers, one starting at the left extremity of the array and progressively moving to the right, and the other one starting at the right extremity of the array and progressively moving to the left. As you iterate through the array, compare the left and right pointer numbers to the pivot. If the left number is greater than the pivot and the right number is less than the pivot, swap them; this will effectively sort these numbers with respect to the pivot at the end of the iteration. If the left number is ever less than or equal to the pivot, increment the left pointer; similarly, if the right number is ever greater than or equal to the pivot, decrement the right pointer. Do this until the pointers pass each other, at which point swapping the pivot with the right number should position the pivot in its final, sorted position, where every number to its left is smaller and every number to its right is greater. If the pivot is in the kth position, you're done; if it isn't, figure out if the kth smallest number is located to the left or to the right of the pivot.\n</p>\n",
      '\n<p>\nRepeat the process mentioned in Hint #2 on the side of the kth smallest number, and keep on repeating the process thereafter until you find the answer. What is the time complexity of this algorithm?\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [8, 5, 2, 9, 7, 6, 3],
        schema: {
          items: { type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
      { name: 'k', example: 3, schema: { minimum: 1, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function quickselect(array, k) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.quickselect = quickselect;\n',
      solutions: [
        "// Best: O(n) time | O(1) space\n// Average: O(n) time | O(1) space\n// Worst: O(n^2) time | O(1) space\nfunction quickselect(array, k) {\n  const position = k - 1;\n  return quickselectHelper(array, 0, array.length - 1, position);\n}\n\nfunction quickselectHelper(array, startIdx, endIdx, position) {\n  while (true) {\n    if (startIdx > endIdx) {\n      throw new Error('Your algorithm should never arrive here!');\n    }\n    const pivotIdx = startIdx;\n    let leftIdx = startIdx + 1;\n    let rightIdx = endIdx;\n    while (leftIdx <= rightIdx) {\n      if (array[leftIdx] > array[pivotIdx] && array[rightIdx] < array[pivotIdx]) {\n        swap(leftIdx, rightIdx, array);\n      }\n      if (array[leftIdx] <= array[pivotIdx]) {\n        leftIdx++;\n      }\n      if (array[rightIdx] >= array[pivotIdx]) {\n        rightIdx--;\n      }\n    }\n    swap(pivotIdx, rightIdx, array);\n    if (rightIdx === position) {\n      return array[rightIdx];\n    } else if (rightIdx < position) {\n      startIdx = rightIdx + 1;\n    } else {\n      endIdx = rightIdx - 1;\n    }\n  }\n}\n\nfunction swap(i, j, array) {\n  const temp = array[j];\n  array[j] = array[i];\n  array[i] = temp;\n}\n\nexports.quickselect = quickselect;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.quickselect([8, 5, 2, 9, 7, 6, 3], 3)).to.deep.equal(5);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai.expect(program.quickselect([8, 5, 2, 9, 7, 6, 3], 3)).to.deep.equal(5);\n});\n",
    },
    bigO: 'Best: O(n) time | O(1) space - where n is the length of the input array\nAverage: O(n) time | O(1) space - where n is the length of the input array\nWorst: O(n^2) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [8, 5, 2, 9, 7, 6, 3], k: 3 },
      { array: [1], k: 1 },
      { array: [43, 24, 37], k: 1 },
      { array: [43, 24, 37], k: 2 },
      { array: [43, 24, 37], k: 3 },
      { array: [8, 3, 2, 5, 1, 7, 4, 6], k: 1 },
      { array: [8, 3, 2, 5, 1, 7, 4, 6], k: 2 },
      { array: [8, 3, 2, 5, 1, 7, 4, 6], k: 3 },
      { array: [8, 3, 2, 5, 1, 7, 4, 6], k: 4 },
      { array: [8, 3, 2, 5, 1, 7, 4, 6], k: 5 },
      { array: [8, 3, 2, 5, 1, 7, 4, 6], k: 6 },
      { array: [8, 3, 2, 5, 1, 7, 4, 6], k: 7 },
      { array: [8, 3, 2, 5, 1, 7, 4, 6], k: 8 },
      {
        array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
        k: 5,
      },
      {
        array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
        k: 4,
      },
      {
        array: [102, 41, 58, 81, 2, -5, 1000, 10021, 181, -14515, 25, 15],
        k: 9,
      },
      {
        array: [
          1, 3, 71, 123, 124, 156, 814, 1294, 10024, 110000, 985181, 55516151,
        ],
        k: 12,
      },
      {
        array: [
          1, 3, 71, 123, 124, 156, 814, 1294, 10024, 110000, 985181, 55516151,
        ],
        k: 4,
      },
    ],
  },
  {
    id: 'index-equals-value',
    name: 'Index Equals Value',
    category: 'Searching',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a sorted array of distinct integers and returns\n  the first index in the array that is equal to the value at that index. In\n  other words, your function should return the minimum index where\n  <span>index == array[index]</span>.\n</p>\n<p>If there is no such index, your function should return <span>-1</span>.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">array</span> = [-5, -3, 0, 3, 4, 5, 9]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// 3 == array[3]</span>\n</pre>\n</div>',
    hints: [
      '<p>\nFirst think about a simple brute-force approach to solve this problem. What is the time complexity of this approach and what improvements could be made to this time complexity?\n</p>\n',
      '\n<p>\nIf the brute force solution runs in linear time complexity, then a better solution would have to run in O(log(n)) time. Which algorithm has an O(log(n)) time complexity?\n</p>\n',
      '\n<p>\nImplement a variation of binary search to solve this problem. Think about what conditions or checks must be added to search for the desired index-value pair.\n</p>\n',
      "\n<p>\nAs you perform a variation of binary search on the input array, if the value that you're looking at is smaller than its index, cut the left half of the array from the search space, because all values to the left will be smaller than their corresponding indices; this is guaranteed to be true, since left indices will naturally decrement by 1 each and left values will decrement by at least 1 each due to the array being sorted. Similar logic applies to the right side of the array when the value that you're looking at is greater than its index.\n</p>\n",
      "\n<p>\nWhen you encounter a value that's equal to its index, you'll have to perform some additional logic to make sure that you're not potentially missing other values in the array that are equal to their index and that come before the value that you're looking at.\n</p>",
    ],
    customInputVars: [
      {
        name: 'array',
        example: [-5, -3, 0, 3, 4, 5, 9],
        schema: {
          items: { type: 'integer' },
          type: 'array',
          uniqueItems: true,
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function indexEqualsValue(array) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.indexEqualsValue = indexEqualsValue;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction indexEqualsValue(array) {\n  for (let index = 0; index < array.length; index++) {\n    const value = array[index];\n    if (index === value) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nexports.indexEqualsValue = indexEqualsValue;\n',
        '// O(log(n)) time | O(log(n)) space - where n is the length of the input array\nfunction indexEqualsValue(array) {\n  return indexEqualsValueHelper(array, 0, array.length - 1);\n}\n\nfunction indexEqualsValueHelper(array, leftIndex, rightIndex) {\n  if (leftIndex > rightIndex) return -1;\n\n  const middleIndex = leftIndex + Math.floor((rightIndex - leftIndex) / 2);\n  const middleValue = array[middleIndex];\n\n  if (middleValue < middleIndex) {\n    return indexEqualsValueHelper(array, middleIndex + 1, rightIndex);\n  } else if (middleValue === middleIndex && middleIndex === 0) {\n    return middleIndex;\n  } else if (middleValue === middleIndex && array[middleIndex - 1] < middleIndex - 1) {\n    return middleIndex;\n  } else {\n    return indexEqualsValueHelper(array, leftIndex, middleIndex - 1);\n  }\n}\n\nexports.indexEqualsValue = indexEqualsValue;\n',
        '// O(log(n)) time | O(1) space - where n is the length of the input array\nfunction indexEqualsValue(array) {\n  let leftIndex = 0;\n  let rightIndex = array.length - 1;\n\n  while (leftIndex <= rightIndex) {\n    const middleIndex = leftIndex + Math.floor((rightIndex - leftIndex) / 2);\n    const middleValue = array[middleIndex];\n\n    if (middleValue < middleIndex) {\n      leftIndex = middleIndex + 1;\n    } else if (middleValue === middleIndex && middleIndex === 0) {\n      return middleIndex;\n    } else if (middleValue === middleIndex && array[middleIndex - 1] < middleIndex - 1) {\n      return middleIndex;\n    } else {\n      rightIndex = middleIndex - 1;\n    }\n  }\n\n  return -1;\n}\n\nexports.indexEqualsValue = indexEqualsValue;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [-5, -3, 0, 3, 4, 5, 9];\n  const expected = 3;\n  const actual = program.indexEqualsValue(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const array = [-5, -3, 0, 3, 4, 5, 9];\n  const expected = 3;\n  const actual = program.indexEqualsValue(array);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(log(n)) time | O(1) space - where n is the length of the input array',
    tests: [
      { array: [-5, -3, 0, 3, 4, 5, 9] },
      { array: [-12, 1, 2, 3, 12] },
      { array: [-5, -4, -3, -2, -1, 0, 1, 3, 5, 6, 7, 11, 12, 14, 19, 20] },
      { array: [-3, -1, 1, 3, 5, 7, 9] },
      { array: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5] },
      { array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] },
      { array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] },
      { array: [0] },
      { array: [0, 1] },
      { array: [1, 2] },
      { array: [-50, 1, 2, 3, 4] },
      { array: [-40, -20, 0, 2, 4, 6, 8, 10] },
      { array: [-1000, 0, 1, 5000, 5001, 5002, 5005] },
      { array: [-1000, 0, 1, 2, 3, 4, 6, 5000, 5001, 5002, 5005] },
      { array: [-999, 0, 2, 500, 1000, 1500, 2000, 2500, 3000, 3500] },
      {
        array: [
          -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 18,
        ],
      },
      { array: [] },
    ],
  },
  {
    id: 'airport-connections',
    name: 'Airport Connections',
    category: 'Graphs',
    complexity: 3,
    prompt:
      '<div class="html">\n<p>\n  <i\n    >For the purpose of this question, the phrases "airport route" and "airport\n    connection" are used interchangeably.</i\n  >\n</p>\n<p>\n  You\'re given a list of airports (three-letter codes like <span>"JFK"</span>),\n  a list of routes (one-way flights from one airport to another like\n  <span>["JFK", "SFO"]</span>), and a starting airport.\n</p>\n<p>\n  Write a function that returns the minimum number of airport connections\n  (one-way flights) that need to be added in order for someone to be able to\n  reach any airport in the list, starting at the starting airport.\n</p>\n<p>\n  Note that routes only allow you to fly in one direction; for instance,\n  the route\n  <span>["JFK", "SFO"]</span> only allows you to fly from <span>"JFK"</span> to\n  <span>"SFO"</span>.\n</p>\n<p>\n  Also note that the connections don\'t have to be direct; it\'s okay if an\n  airport can only be reached from the starting airport by stopping at other\n  airports first.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">airports</span> = [\n  "BGI", "CDG", "DEL", "DOH", "DSM", "EWR", "EYW", "HND", "ICN",\n  "JFK", "LGA", "LHR", "ORD", "SAN", "SFO", "SIN", "TLV", "BUD",\n]\n<span class="CodeEditor-promptParameter">routes</span> = [\n  ["DSM", "ORD"],\n  ["ORD", "BGI"],\n  ["BGI", "LGA"],\n  ["SIN", "CDG"],\n  ["CDG", "SIN"],\n  ["CDG", "BUD"],\n  ["DEL", "DOH"],\n  ["DEL", "CDG"],\n  ["TLV", "DEL"],\n  ["EWR", "HND"],\n  ["HND", "ICN"],\n  ["HND", "JFK"],\n  ["ICN", "JFK"],\n  ["JFK", "LGA"],\n  ["EYW", "LHR"],\n  ["LHR", "SFO"],\n  ["SFO", "SAN"],\n  ["SFO", "DSM"],\n  ["SAN", "EYW"],\n]\n<span class="CodeEditor-promptParameter">startingAirport</span> = "LGA"\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// ["LGA", "TLV"], ["LGA", "SFO"], and ["LGA", "EWR"]</span>\n</pre>\n</div>',
    hints: [
      "<p>\nStart by creating a graph out of the inputs. Each airport should be a vertex in the graph, and each route should be an edge. The graph should be directed with potential cycles, since it's possible for there to be round-trip flights between airports or for some series of flights to eventually lead back to an arbitrary starting point. How can this graph be useful?\n</p>\n",
      '\n<p>\nUsing the graph mentioned in Hint #1, try getting all of the airports that are unreachable from the starting airport. This can be done using depth-first search. Is the number of unreachable airports the answer? If not, what extra information do you need to get to the answer?\n</p>\n',
      '\n<p>\nA single unreachable airport could have connections to a bunch of other unreachable airports, potentially making it more "valuable", since adding one connection to it would make many other airports reachable.\n</p>\n',
      "\n<p>\nCalculate the number of unreachable airports that are reachable from each unreachable airport (this can be done using depth-first search), sort them in descending order according to this number, and count the minimum number of connections that need to be added by iterating through this sorted list of unreachable airports, removing every unreachable airport's unreachable connections as you go through the list.\n</p>",
    ],
    customInputVars: [
      {
        name: 'airports',
        example: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        schema: { items: { type: 'string' }, type: 'array', uniqueItems: true },
      },
      {
        name: 'routes',
        example: [
          ['DSM', 'ORD'],
          ['ORD', 'BGI'],
          ['BGI', 'LGA'],
          ['SIN', 'CDG'],
          ['CDG', 'SIN'],
          ['CDG', 'BUD'],
          ['DEL', 'DOH'],
          ['DEL', 'CDG'],
          ['TLV', 'DEL'],
          ['EWR', 'HND'],
          ['HND', 'ICN'],
          ['HND', 'JFK'],
          ['ICN', 'JFK'],
          ['JFK', 'LGA'],
          ['EYW', 'LHR'],
          ['LHR', 'SFO'],
          ['SFO', 'SAN'],
          ['SFO', 'DSM'],
          ['SAN', 'EYW'],
        ],
        schema: {
          items: {
            items: { type: 'string' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
            uniqueItems: true,
          },
          type: 'array',
        },
      },
      { name: 'startingAirport', example: 'LGA', schema: { type: 'string' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function airportConnections(airports, routes, startingAirport) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.airportConnections = airportConnections;\n',
      solutions: [
        '// O(a * (a + r) + a + r + alog(a)) time | O(a + r) space - where a is the number of airports and r is the number of routes\nfunction airportConnections(airports, routes, startingAirport) {\n  const airportGraph = createAirportGraph(airports, routes);\n  const unreachableAirportNodes = getUnreachableAirportNodes(\n    airportGraph,\n    airports,\n    startingAirport,\n  );\n  markUnreachableConnections(airportGraph, unreachableAirportNodes);\n  return getMinNumberOfNewConnections(airportGraph, unreachableAirportNodes);\n}\n\n// O(a + r) time | O(a + r) space\nfunction createAirportGraph(airports, routes) {\n  const airportGraph = {};\n  for (const airport of airports) {\n    airportGraph[airport] = new AirportNode(airport);\n  }\n  for (const route of routes) {\n    const [airport, connection] = route;\n    airportGraph[airport].connections.push(connection);\n  }\n  return airportGraph;\n}\n\n// O(a + r) time | O(a) space\nfunction getUnreachableAirportNodes(airportGraph, airports, startingAirport) {\n  const visitedAirports = {};\n  depthFirstTraverseAirports(airportGraph, startingAirport, visitedAirports);\n\n  const unreachableAirportNodes = [];\n  for (const airport of airports) {\n    if (airport in visitedAirports) continue;\n    const airportNode = airportGraph[airport];\n    airportNode.isReachable = false;\n    unreachableAirportNodes.push(airportNode);\n  }\n  return unreachableAirportNodes;\n}\n\nfunction depthFirstTraverseAirports(airportGraph, airport, visitedAirports) {\n  if (airport in visitedAirports) return;\n  visitedAirports[airport] = true;\n  const {connections} = airportGraph[airport];\n  for (const connection of connections) {\n    depthFirstTraverseAirports(airportGraph, connection, visitedAirports);\n  }\n}\n\n// O(a * (a + r)) time | O(a) space\nfunction markUnreachableConnections(airportGraph, unreachableAirportNodes) {\n  for (const airportNode of unreachableAirportNodes) {\n    const {airport} = airportNode;\n    const unreachableConnections = [];\n    depthFirstAddUnreachableConnections(airportGraph, airport, unreachableConnections, {});\n    airportNode.unreachableConnections = unreachableConnections;\n  }\n}\n\nfunction depthFirstAddUnreachableConnections(\n  airportGraph,\n  airport,\n  unreachableConnections,\n  visitedAirports,\n) {\n  if (airportGraph[airport].isReachable) return;\n  if (airport in visitedAirports) return;\n  visitedAirports[airport] = true;\n  unreachableConnections.push(airport);\n  const {connections} = airportGraph[airport];\n  for (const connection of connections) {\n    depthFirstAddUnreachableConnections(\n      airportGraph,\n      connection,\n      unreachableConnections,\n      visitedAirports,\n    );\n  }\n}\n\n// O(alog(a) + a + r) time | O(1) space\nfunction getMinNumberOfNewConnections(airportGraph, unreachableAirportNodes) {\n  unreachableAirportNodes.sort(\n    (a1, a2) => a2.unreachableConnections.length - a1.unreachableConnections.length,\n  );\n\n  let numberOfNewConnections = 0;\n  for (const airportNode of unreachableAirportNodes) {\n    if (airportNode.isReachable) continue;\n    numberOfNewConnections++;\n    for (const connection of airportNode.unreachableConnections) {\n      airportGraph[connection].isReachable = true;\n    }\n  }\n  return numberOfNewConnections;\n}\n\nclass AirportNode {\n  constructor(airport) {\n    this.airport = airport;\n    this.connections = [];\n    this.isReachable = true;\n    this.unreachableConnections = [];\n  }\n}\n\nexports.airportConnections = airportConnections;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nconst AIRPORTS = [\n  'BGI',\n  'CDG',\n  'DEL',\n  'DOH',\n  'DSM',\n  'EWR',\n  'EYW',\n  'HND',\n  'ICN',\n  'JFK',\n  'LGA',\n  'LHR',\n  'ORD',\n  'SAN',\n  'SFO',\n  'SIN',\n  'TLV',\n  'BUD',\n];\n\nconst STARTING_AIRPORT = 'LGA';\n\nit('Test Case #1', function () {\n  const routes = [\n    ['DSM', 'ORD'],\n    ['ORD', 'BGI'],\n    ['BGI', 'LGA'],\n    ['SIN', 'CDG'],\n    ['CDG', 'SIN'],\n    ['CDG', 'BUD'],\n    ['DEL', 'DOH'],\n    ['DEL', 'CDG'],\n    ['TLV', 'DEL'],\n    ['EWR', 'HND'],\n    ['HND', 'ICN'],\n    ['HND', 'JFK'],\n    ['ICN', 'JFK'],\n    ['JFK', 'LGA'],\n    ['EYW', 'LHR'],\n    ['LHR', 'SFO'],\n    ['SFO', 'SAN'],\n    ['SFO', 'DSM'],\n    ['SAN', 'EYW'],\n  ];\n  chai.expect(program.airportConnections(AIRPORTS, routes, STARTING_AIRPORT)).to.deep.equal(3);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nconst AIRPORTS = [\n  'BGI',\n  'CDG',\n  'DEL',\n  'DOH',\n  'DSM',\n  'EWR',\n  'EYW',\n  'HND',\n  'ICN',\n  'JFK',\n  'LGA',\n  'LHR',\n  'ORD',\n  'SAN',\n  'SFO',\n  'SIN',\n  'TLV',\n  'BUD',\n];\n\nconst STARTING_AIRPORT = 'LGA';\n\nit('Test Case #1', function () {\n  const routes = [\n    ['DSM', 'ORD'],\n    ['ORD', 'BGI'],\n    ['BGI', 'LGA'],\n    ['SIN', 'CDG'],\n    ['CDG', 'SIN'],\n    ['CDG', 'BUD'],\n    ['DEL', 'DOH'],\n    ['DEL', 'CDG'],\n    ['TLV', 'DEL'],\n    ['EWR', 'HND'],\n    ['HND', 'ICN'],\n    ['HND', 'JFK'],\n    ['ICN', 'JFK'],\n    ['JFK', 'LGA'],\n    ['EYW', 'LHR'],\n    ['LHR', 'SFO'],\n    ['SFO', 'SAN'],\n    ['SFO', 'DSM'],\n    ['SAN', 'EYW'],\n  ];\n  chai.expect(program.airportConnections(AIRPORTS, routes, STARTING_AIRPORT)).to.deep.equal(3);\n});\n",
    },
    bigO: 'O(a * (a + r) + a + r + alog(a)) time | O(a + r) space - where a is the number of airports and r is the number of routes',
    tests: [
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['DSM', 'ORD'],
          ['ORD', 'BGI'],
          ['BGI', 'LGA'],
          ['SIN', 'CDG'],
          ['CDG', 'SIN'],
          ['CDG', 'BUD'],
          ['DEL', 'DOH'],
          ['DEL', 'CDG'],
          ['TLV', 'DEL'],
          ['EWR', 'HND'],
          ['HND', 'ICN'],
          ['HND', 'JFK'],
          ['ICN', 'JFK'],
          ['JFK', 'LGA'],
          ['EYW', 'LHR'],
          ['LHR', 'SFO'],
          ['SFO', 'SAN'],
          ['SFO', 'DSM'],
          ['SAN', 'EYW'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['LGA', 'ORD'],
          ['LGA', 'EYW'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['DSM', 'ORD'],
          ['LGA', 'EYW'],
          ['EYW', 'JFK'],
          ['EYW', 'EWR'],
          ['JFK', 'ICN'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['DSM', 'ORD'],
          ['LGA', 'EYW'],
          ['EYW', 'JFK'],
          ['EYW', 'EWR'],
          ['JFK', 'ICN'],
          ['LGA', 'ICN'],
          ['ICN', 'ORD'],
          ['ICN', 'EWR'],
          ['JFK', 'DSM'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['DSM', 'ORD'],
          ['LGA', 'EYW'],
          ['EYW', 'JFK'],
          ['EYW', 'EWR'],
          ['JFK', 'ICN'],
          ['LGA', 'ICN'],
          ['ICN', 'ORD'],
          ['ICN', 'EWR'],
          ['JFK', 'DSM'],
          ['ICN', 'JFK'],
          ['ORD', 'DSM'],
          ['DSM', 'LGA'],
          ['JFK', 'LGA'],
          ['JFK', 'HND'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['DSM', 'ORD'],
          ['LGA', 'EYW'],
          ['EYW', 'JFK'],
          ['EYW', 'EWR'],
          ['JFK', 'ICN'],
          ['LGA', 'ICN'],
          ['ICN', 'ORD'],
          ['ICN', 'EWR'],
          ['JFK', 'DSM'],
          ['ICN', 'JFK'],
          ['ORD', 'DSM'],
          ['DSM', 'LGA'],
          ['JFK', 'LGA'],
          ['JFK', 'HND'],
          ['SFO', 'SIN'],
          ['SFO', 'CDG'],
          ['SFO', 'LHR'],
          ['LHR', 'DEL'],
          ['DEL', 'BGI'],
          ['DEL', 'DOH'],
          ['DOH', 'SAN'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['DSM', 'ORD'],
          ['EYW', 'JFK'],
          ['EYW', 'EWR'],
          ['JFK', 'ICN'],
          ['LGA', 'ICN'],
          ['ICN', 'ORD'],
          ['ICN', 'EWR'],
          ['JFK', 'DSM'],
          ['ICN', 'JFK'],
          ['ORD', 'DSM'],
          ['DSM', 'LGA'],
          ['JFK', 'LGA'],
          ['JFK', 'HND'],
          ['SFO', 'SIN'],
          ['SFO', 'CDG'],
          ['SFO', 'LHR'],
          ['LHR', 'DEL'],
          ['DEL', 'BGI'],
          ['DEL', 'DOH'],
          ['DOH', 'SAN'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['SIN', 'BGI'],
          ['SIN', 'CDG'],
          ['SIN', 'DEL'],
          ['SIN', 'DOH'],
          ['SIN', 'DSM'],
          ['SIN', 'EWR'],
          ['SIN', 'EYW'],
          ['SIN', 'HND'],
          ['SIN', 'ICN'],
          ['SIN', 'JFK'],
          ['SIN', 'LHR'],
          ['SIN', 'ORD'],
          ['SFO', 'SIN'],
          ['SFO', 'SAN'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['DSM', 'ORD'],
          ['SIN', 'BGI'],
          ['SIN', 'CDG'],
          ['CDG', 'DEL'],
          ['DEL', 'DOH'],
          ['DEL', 'CDG'],
          ['DEL', 'EWR'],
          ['HND', 'ICN'],
          ['ICN', 'JFK'],
          ['JFK', 'LGA'],
          ['JFK', 'SFO'],
          ['EYW', 'LHR'],
          ['SFO', 'ORD'],
          ['SFO', 'LGA'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['DSM', 'ORD'],
          ['SIN', 'BGI'],
          ['SIN', 'CDG'],
          ['CDG', 'DEL'],
          ['DEL', 'DOH'],
          ['DEL', 'CDG'],
          ['DEL', 'EWR'],
          ['HND', 'ICN'],
          ['ICN', 'JFK'],
          ['JFK', 'LGA'],
          ['JFK', 'SFO'],
          ['EYW', 'LHR'],
          ['SFO', 'ORD'],
          ['SFO', 'LGA'],
          ['SFO', 'SIN'],
          ['CDG', 'EYW'],
          ['LGA', 'SAN'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['LGA', 'DSM'],
          ['DSM', 'ORD'],
          ['SIN', 'BGI'],
          ['SIN', 'CDG'],
          ['CDG', 'DEL'],
          ['DEL', 'DOH'],
          ['DEL', 'CDG'],
          ['DEL', 'EWR'],
          ['HND', 'ICN'],
          ['ICN', 'JFK'],
          ['JFK', 'LGA'],
          ['JFK', 'SFO'],
          ['EYW', 'LHR'],
          ['SFO', 'ORD'],
          ['SFO', 'LGA'],
          ['SFO', 'SIN'],
          ['CDG', 'EYW'],
          ['ORD', 'HND'],
          ['HND', 'SAN'],
          ['LGA', 'TLV'],
          ['LGA', 'BUD'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['DSM', 'ORD'],
          ['ORD', 'BGI'],
          ['BGI', 'LGA'],
          ['SIN', 'CDG'],
          ['CDG', 'DEL'],
          ['DEL', 'DOH'],
          ['DOH', 'SIN'],
          ['EWR', 'HND'],
          ['HND', 'ICN'],
          ['ICN', 'JFK'],
          ['JFK', 'LGA'],
          ['EYW', 'LHR'],
          ['LHR', 'SFO'],
          ['SFO', 'SAN'],
          ['SAN', 'EYW'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['DSM', 'ORD'],
          ['ORD', 'BGI'],
          ['BGI', 'LGA'],
          ['SIN', 'CDG'],
          ['CDG', 'DEL'],
          ['DEL', 'DOH'],
          ['DOH', 'SIN'],
          ['EWR', 'HND'],
          ['HND', 'ICN'],
          ['ICN', 'JFK'],
          ['JFK', 'LGA'],
          ['EYW', 'LHR'],
          ['LHR', 'SFO'],
          ['SFO', 'SAN'],
          ['SFO', 'ORD'],
          ['SAN', 'EYW'],
        ],
        startingAirport: 'LGA',
      },
      {
        airports: [
          'BGI',
          'CDG',
          'DEL',
          'DOH',
          'DSM',
          'EWR',
          'EYW',
          'HND',
          'ICN',
          'JFK',
          'LGA',
          'LHR',
          'ORD',
          'SAN',
          'SFO',
          'SIN',
          'TLV',
          'BUD',
        ],
        routes: [
          ['DSM', 'ORD'],
          ['ORD', 'BGI'],
          ['BGI', 'LGA'],
          ['SIN', 'CDG'],
          ['CDG', 'DEL'],
          ['DEL', 'DOH'],
          ['DOH', 'SIN'],
          ['EWR', 'HND'],
          ['HND', 'ICN'],
          ['ICN', 'JFK'],
          ['JFK', 'LGA'],
          ['EYW', 'LHR'],
          ['LHR', 'SFO'],
          ['SFO', 'SAN'],
          ['SFO', 'DSM'],
          ['SAN', 'EYW'],
        ],
        startingAirport: 'LGA',
      },
    ],
  },
  {
    id: 'stable-internships',
    name: 'Stable internships',
    category: 'Famous Algorithms',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  A company has hired N interns to each join one of N different teams. Each\n  intern has ranked their preferences for which teams they wish to join, and\n  each team has ranked their preferences for which interns they prefer.\n</p>\n<p>\n  Given these preferences, assign 1 intern to each team. These assignments\n  should be "stable," meaning that there is no unmatched pair of an intern and a\n  team such that both that intern and that team would prefer they be matched\n  with each other.\n</p>\n<p>\n  In the case there are multiple valid stable matchings, the solution that is\n  most optimal for the interns should be chosen (i.e. every intern should be\n  matched with the best team possible for them).\n</p>\n<p>\n  Your function should take in 2 2-dimensional lists, one for interns and\n  one for teams. Each inner list represents a single intern or team\'s preferences,\n  ranked from most preferable to least preferable. These lists will always be\n  of length N, with integers as elements. Each of these integers corresponds\n  to the index of the team/intern being ranked. Your function should return a\n  2-dimensional list of matchings in no particular order. Each matching should\n  be in the format [internIndex, teamIndex].\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">interns</span> = [\n  [0, 1, 2],\n  [1, 0, 2],\n  [1, 2, 0]\n]\n</pre>\n<pre>\n<span class="CodeEditor-promptParameter">teams</span> = [\n  [2, 1, 0],\n  [1, 2, 0],\n  [0, 2, 1]\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n<span class="CodeEditor-promptComment">// This is the most optimal solution for interns</span>\n[\n  [0, 0],\n  [1, 1],\n  [2, 2]\n]\n</pre>\n\n<pre>\n<span class="CodeEditor-promptComment">// This is also a stable matching, but it is suboptimal for the interns\n// because interns 0 and 2 could have been given better team matchings</span>\n[\n  [2, 0],\n  [1, 1],\n  [0, 2]\n]\n</pre>\n</div>',
    hints: [
      '<p>\n  Try starting out by solving the most basic version of this problem. What would\n  you do if every intern had a unique first choice?\n</p>\n',
      '\n<p>\n  If two interns had the same first choice, how can you decide which intern\n  gets that team to keep the matchings stable?\n</p>\n',
      '\n<p>\n  To optimize performance, it might be helpful to first convert the input into\n  a different data structure.\n</p>',
    ],
    customInputVars: [
      {
        name: 'interns',
        example: [],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          type: 'array',
        },
      },
      {
        name: 'teams',
        example: [],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function stableInternships(interns, teams) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.stableInternships = stableInternships;\n',
      solutions: [
        '// O(n^2) time | O(n^2) space - where n is the number of interns and teams\nfunction stableInternships(interns, teams) {\n  const chosenInterns = {};\n  const freeInterns = interns.map((_, i) => i);\n  const currentInternChoices = new Array(interns.length).fill(0);\n\n  const teamMaps = [];\n  for (const team of teams) {\n    const rank = {};\n    team.forEach((internNum, i) => {\n      rank[internNum] = i;\n    });\n    teamMaps.push(rank);\n  }\n\n  while (freeInterns.length > 0) {\n    const internNum = freeInterns.pop();\n\n    const intern = interns[internNum];\n    const teamPreference = intern[currentInternChoices[internNum]];\n    currentInternChoices[internNum] += 1;\n\n    if (!(teamPreference in chosenInterns)) {\n      chosenInterns[teamPreference] = internNum;\n      continue;\n    }\n\n    const previousIntern = chosenInterns[teamPreference];\n    const previousInternRank = teamMaps[teamPreference][previousIntern];\n    const currentInternRank = teamMaps[teamPreference][internNum];\n\n    if (currentInternRank < previousInternRank) {\n      freeInterns.push(previousIntern);\n      chosenInterns[teamPreference] = internNum;\n    } else {\n      freeInterns.push(internNum);\n    }\n  }\n\n  const matches = Object.entries(chosenInterns).map(([teamNum, internNum]) => [\n    internNum,\n    parseInt(teamNum),\n  ]);\n  return matches;\n}\n\n// Do not edit the line below.\nexports.stableInternships = stableInternships;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const interns = [\n    [0, 1],\n    [1, 0],\n  ];\n  const teams = [\n    [1, 0],\n    [1, 0],\n  ];\n  const expected = [\n    [0, 0],\n    [1, 1],\n  ];\n  const actual = program.stableInternships(interns, teams);\n  chai.expect(actual.length).to.deep.equal(expected.length);\n\n  for (const match of expected) {\n    let containsMatch = false;\n    for (const actualMatch of actual) {\n      if (actualMatch[0] === match[0] && actualMatch[1] === match[1]) {\n        containsMatch = true;\n      }\n    }\n    chai.expect(containsMatch).to.deep.equal(true);\n  }\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const interns = [\n    [0, 1],\n    [1, 0],\n  ];\n  const teams = [\n    [1, 0],\n    [1, 0],\n  ];\n  const expected = [\n    [0, 0],\n    [1, 1],\n  ];\n  const actual = program.stableInternships(interns, teams);\n  chai.expect(actual.length).to.deep.equal(expected.length);\n\n  for (const match of expected) {\n    let containsMatch = false;\n    for (const actualMatch of actual) {\n      if (actualMatch[0] === match[0] && actualMatch[1] === match[1]) {\n        containsMatch = true;\n      }\n    }\n    chai.expect(containsMatch).to.deep.equal(true);\n  }\n});\n",
    },
    bigO: 'O(n^2) time | O(n^2) space - where n is the number of interns',
    tests: [
      { interns: [], teams: [] },
      { interns: [[0]], teams: [[0]] },
      {
        interns: [
          [0, 1],
          [1, 0],
        ],
        teams: [
          [0, 1],
          [1, 0],
        ],
      },
      {
        interns: [
          [0, 1],
          [0, 1],
        ],
        teams: [
          [0, 1],
          [0, 1],
        ],
      },
      {
        interns: [
          [0, 1],
          [0, 1],
        ],
        teams: [
          [0, 1],
          [1, 0],
        ],
      },
      {
        interns: [
          [0, 1],
          [1, 0],
        ],
        teams: [
          [0, 1],
          [0, 1],
        ],
      },
      {
        interns: [
          [1, 0],
          [0, 1],
        ],
        teams: [
          [0, 1],
          [1, 0],
        ],
      },
      {
        interns: [
          [0, 1, 2],
          [2, 1, 0],
          [1, 2, 0],
        ],
        teams: [
          [2, 1, 0],
          [0, 1, 2],
          [0, 2, 1],
        ],
      },
      {
        interns: [
          [0, 1, 2],
          [0, 2, 1],
          [1, 2, 0],
        ],
        teams: [
          [2, 1, 0],
          [0, 1, 2],
          [0, 2, 1],
        ],
      },
      {
        interns: [
          [0, 1, 2],
          [0, 1, 2],
          [0, 1, 2],
        ],
        teams: [
          [2, 1, 0],
          [2, 1, 0],
          [2, 1, 0],
        ],
      },
      {
        interns: [
          [0, 1, 2, 3],
          [2, 1, 3, 0],
          [0, 2, 3, 1],
          [3, 1, 0, 2],
        ],
        teams: [
          [1, 3, 2, 0],
          [0, 1, 2, 3],
          [1, 2, 3, 0],
          [3, 0, 2, 1],
        ],
      },
      {
        interns: [
          [0, 1, 2, 3],
          [0, 1, 3, 2],
          [0, 2, 3, 1],
          [0, 2, 3, 1],
        ],
        teams: [
          [1, 3, 2, 0],
          [0, 1, 2, 3],
          [1, 2, 3, 0],
          [3, 0, 2, 1],
        ],
      },
      {
        interns: [
          [0, 1, 2, 3],
          [0, 1, 3, 2],
          [0, 2, 3, 1],
          [0, 2, 3, 1],
        ],
        teams: [
          [1, 3, 2, 0],
          [0, 1, 2, 3],
          [1, 3, 2, 0],
          [3, 0, 2, 1],
        ],
      },
    ],
  },
  {
    id: 'two-colorable',
    name: 'Two-Colorable',
    category: 'Graphs',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a list of <span>edges</span> representing a connected,\n    unweighted, undirected graph with at least one node. Write a function that\n    returns a boolean representing whether the given graph is two-colorable.\n  </p>\n\n  <p>\n    A graph is two-colorable (also called bipartite) if all of the nodes can\n    be assigned one of two colors such that no nodes of the same color are\n    connected by an edge.\n  </p>\n\n  <p>\n    The given list is what\'s called an adjacency list, and it represents a graph.\n    The number of vertices in the graph is equal to the length of\n    <span>edges</span>, where each index <span>i</span> in\n    <span>edges</span> contains vertex <span>i</span>\'s siblings, in no\n    particular order. Each individual edge is represented by a positive integer\n    that denotes an index in the list that this vertex is connected to. Note that\n    this graph is undirected, meaning that if a vertex appears in the edge list\n    of another vertex, then the inverse will also be true.\n  </p>\n  <p>\n    Also note that this graph may contain self-loops. A self-loop is an edge that\n    has the same destination and origin; in other words, it\'s an edge that\n    connects a vertex to itself. Any self-loop should make a graph not\n    2-colorable.\n  </p>\n<h3>Sample Input</h3>\n<pre><span class="CodeEditor-promptParameter">edges</span> = [\n  [1, 2],\n  [0, 2],\n  [0, 1]\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\nFalse <span class="CodeEditor-promptComment">// Nodes 1 and 2 must be different colors than node 0.\n// However, nodes 1 and 2 are also connected, meaning they must also have different colors,\n// which is impossible with only 2 available colors.\n</span>\n</pre>',
    hints: [
      '<p>\n  Try starting by choosing a random node and assigning it a color. From here,\n  can you tell what colors any other nodes must have?\n</p>\n',
      '\n<p>\n  From a given node, assign each sibling node the opposite color, then continue\n  through the graph using BFS or DFS.\n</p>\n',
      '\n<p>\n  If you ever encounter a sibling that is already marked as the wrong color, then\n  there cannot be a solution.\n</p>',
    ],
    customInputVars: [
      {
        name: 'edges',
        example: [[1], [0]],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function twoColorable(edges) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.twoColorable = twoColorable;\n',
      solutions: [
        '// O(v + e) time | O(v) space - where v is the number of\n// vertices and e is the number of edges in the graph\nfunction twoColorable(edges) {\n  const colors = edges.map(_ => null);\n  colors[0] = true;\n  const stack = [0];\n\n  while (stack.length > 0) {\n    const node = stack.pop();\n    for (const connection of edges[node]) {\n      if (colors[connection] === null) {\n        colors[connection] = !colors[node];\n        stack.push(connection);\n      } else if (colors[connection] === colors[node]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.twoColorable = twoColorable;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[1], [0]];\n  const expected = true;\n  const actual = program.twoColorable(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[1], [0]];\n  const expected = true;\n  const actual = program.twoColorable(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(v + e) time | O(v) space - where v is the number of vertices and e is the number of edges in the graph',
    tests: [
      { edges: [[1], [0]] },
      { edges: [[0]] },
      {
        edges: [
          [1, 2],
          [0, 2],
          [0, 1],
        ],
      },
      { edges: [[1], [0, 2], [1]] },
      { edges: [[1, 2, 3], [0], [0], [0]] },
      { edges: [[1, 2, 3], [0, 2], [0, 1], [0]] },
      {
        edges: [
          [1, 2, 3],
          [0, 2, 3],
          [0, 1],
          [0, 1],
        ],
      },
      { edges: [[2], [2, 3], [0, 1], [1]] },
      {
        edges: [
          [1, 2],
          [0, 2, 3],
          [0, 1, 3],
          [1, 2],
        ],
      },
      {
        edges: [
          [1, 4],
          [0, 2, 3],
          [1, 3, 4],
          [1, 2],
          [0, 2],
        ],
      },
      { edges: [[1, 4], [0, 2, 3], [1, 4], [1], [0, 2]] },
    ],
  },
  {
    id: 'kruskals-algorithm',
    name: "Kruskal's Algorithm",
    category: 'Famous Algorithms',
    complexity: 2,
    prompt:
      "<div class=\"html\">\n  <p>\n    You're given a list of <span>edges</span> representing a weighted,\n    undirected graph with at least one node.\n  </p>\n\n  <p>\n    The given list is what's called an adjacency list, and it represents a graph.\n    The number of vertices in the graph is equal to the length of\n    <span>edges</span>, where each index <span>i</span> in\n    <span>edges</span> contains vertex <span>i</span>'s siblings, in no\n    particular order. Each of these siblings is an array of length two, with\n    the first value denoting the index in the list that this vertex is connected\n    to, and and the second value denoting the weight of the edge. Note that\n    this graph is undirected, meaning that if a vertex appears in the edge list\n    of another vertex, then the inverse will also be true (along with the same\n    weight).\n  </p>\n\n  <p>\n    Write a function implementing Kruskal's Algorithm to return a new\n    <span>edges</span> array that represents a minimum spanning tree. A\n    minimum spanning tree is a tree containing all of the vertices of the original\n    graph and a subset of the edges. These edges should connect all of the vertices\n    with the minimum total edge weight and without generating any cycles.\n  </p>\n\n  <p>\n    If the graph is not connected, your function should return the minimum spanning\n    forest (i.e. all of the nodes should be able to reach the same nodes as they\n    could in the initial edge list).\n  </p>\n\n  <p>\n    Note that the graph represented by <span>edges</span> won't contain any\n    self-loops (vertices that have an outbound edge to themselves) and will only\n    have positively weighted edges (i.e., no negative distances).\n  </p>\n\n  <p>\n    If you're unfamiliar with Kruskal's algorithm, we recommend watching the\n    Conceptual Overview section of this question's video explanation before\n    starting to code. If you're unfamiliar with the Union Find data structure,\n    we recommend completing that problem before attempting this one.\n  </p>\n  <h3>Sample Input</h3>\n  <pre><span class=\"CodeEditor-promptParameter\">edges</span> = [\n  [[1, 3], [2, 5]],\n  [[0, 3], [2, 10], [3, 12]],\n  [[0, 5], [1, 10]],\n  [[1, 12]]\n]</pre>\n  <h3>Sample Output</h3>\n  <pre>[\n  [[1, 3], [2, 5]],\n  [[0, 3], [3, 12]],\n  [[0, 5]],\n  [[1, 12]]\n]</pre>\n</div>",
    hints: [
      '<p>\n  A good place to start is to transform the adjacency list into a list of\n  all of the edges, sorted by weight.\n</p>\n',
      '\n<p>\n  To check if adding a given edge creates a cycle, try using a disjoint set.\n  Start by thinking of each node as its own set. Then with each added edge,\n  combine the sets of the connected nodes.\n</p>',
    ],
    customInputVars: [
      {
        name: 'edges',
        example: [[[1, 1]], [[0, 1]]],
        schema: {
          items: {
            items: {
              items: { items: { maxItems: 2, minItems: 2 }, type: 'integer' },
              type: 'array',
            },
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function kruskalsAlgorithm(edges) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.kruskalsAlgorithm = kruskalsAlgorithm;\n',
      solutions: [
        '// O(e * log(e)) time | O(e + v) space - where e is the number\n// of edges in the input edges and v is the number of vertices\nfunction kruskalsAlgorithm(edges) {\n  const edgeList = [];\n  for (let sourceIndex = 0; sourceIndex < edges.length; sourceIndex++) {\n    const vertex = edges[sourceIndex];\n    for (const edge of vertex) {\n      if (edge[0] > sourceIndex) {\n        edgeList.push([sourceIndex, edge[0], edge[1]]);\n      }\n    }\n  }\n  const sortedEdges = edgeList.sort((edgeA, edgeB) => {\n    if (edgeA[2] > edgeB[2]) return 1;\n    if (edgeA[2] < edgeB[2]) return -1;\n    return 0;\n  });\n\n  const parents = edges.map((_, i) => i);\n  const ranks = edges.map(_ => 0);\n  const mst = edges.map(_ => []);\n  for (const edge of sortedEdges) {\n    const vertex1Root = find(edge[0], parents);\n    const vertex2Root = find(edge[1], parents);\n    if (vertex1Root !== vertex2Root) {\n      mst[edge[0]].push([edge[1], edge[2]]);\n      mst[edge[1]].push([edge[0], edge[2]]);\n      union(vertex1Root, vertex2Root, parents, ranks);\n    }\n  }\n\n  return mst;\n}\n\nfunction find(vertex, parents) {\n  if (vertex !== parents[vertex]) {\n    parents[vertex] = find(parents[vertex], parents);\n  }\n\n  return parents[vertex];\n}\n\nfunction union(vertex1Root, vertex2Root, parents, ranks) {\n  if (ranks[vertex1Root] < ranks[vertex2Root]) {\n    parents[vertex1Root] = vertex2Root;\n  } else if (ranks[vertex1Root] > ranks[vertex2Root]) {\n    parents[vertex2Root] = vertex1Root;\n  } else {\n    parents[vertex2Root] = vertex1Root;\n    ranks[vertex1Root] += 1;\n  }\n}\n\n// Do not edit the line below.\nexports.kruskalsAlgorithm = kruskalsAlgorithm;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[[1, 1]], [[0, 1]]];\n  const expected = [[[1, 1]], [[0, 1]]];\n  const actual = program.kruskalsAlgorithm(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[[1, 1]], [[0, 1]]];\n  const expected = [[[1, 1]], [[0, 1]]];\n  const actual = program.kruskalsAlgorithm(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(e * log(e)) time | O(e + v) space - where e is the number of edges in the input edges and v is the number of vertices',
    tests: [
      { edges: [[[1, 1]], [[0, 1]]] },
      {
        edges: [
          [[1, 1]],
          [
            [0, 1],
            [2, 2],
          ],
          [[1, 2]],
        ],
      },
      {
        edges: [
          [
            [1, 3],
            [2, 5],
          ],
          [
            [0, 3],
            [2, 10],
            [3, 12],
          ],
          [
            [0, 5],
            [1, 10],
          ],
          [[1, 12]],
        ],
      },
      {
        edges: [
          [
            [1, 3],
            [2, 5],
          ],
          [
            [0, 3],
            [2, 10],
            [3, 12],
            [4, 1],
          ],
          [
            [0, 5],
            [1, 10],
            [4, 7],
          ],
          [[1, 12]],
          [
            [1, 1],
            [2, 7],
          ],
        ],
      },
      {
        edges: [
          [
            [1, 3],
            [2, 5],
          ],
          [
            [0, 3],
            [2, 10],
            [3, 12],
            [4, 1],
          ],
          [
            [0, 5],
            [1, 10],
            [4, 7],
          ],
          [
            [1, 12],
            [4, 11],
          ],
          [
            [1, 1],
            [2, 7],
            [3, 11],
          ],
        ],
      },
      {
        edges: [
          [[1, 7]],
          [
            [0, 7],
            [2, 6],
            [4, 3],
          ],
          [[1, 6]],
          [[4, 2]],
          [
            [1, 3],
            [3, 2],
          ],
        ],
      },
      {
        edges: [
          [[1, 7]],
          [
            [0, 7],
            [2, 6],
            [4, 3],
          ],
          [
            [1, 6],
            [3, 14],
          ],
          [
            [2, 14],
            [4, 2],
          ],
          [
            [1, 3],
            [3, 2],
          ],
        ],
      },
      {
        edges: [
          [[1, 7]],
          [
            [0, 7],
            [2, 6],
            [3, 20],
            [4, 3],
          ],
          [
            [1, 6],
            [3, 14],
          ],
          [
            [1, 20],
            [2, 14],
            [4, 2],
          ],
          [
            [1, 3],
            [3, 2],
          ],
        ],
      },
      {
        edges: [
          [
            [1, 7],
            [2, 5],
          ],
          [
            [0, 7],
            [2, 6],
            [3, 20],
            [4, 3],
          ],
          [
            [0, 5],
            [1, 6],
            [3, 14],
          ],
          [
            [1, 20],
            [2, 14],
            [4, 2],
          ],
          [
            [1, 3],
            [3, 2],
          ],
        ],
      },
      { edges: [[[1, 1]], [[0, 1]], [[3, 1]], [[2, 1]]] },
      { edges: [[[1, 1]], [[0, 1]], [[3, 3]], [[2, 3]], [[5, 5]], [[4, 5]]] },
      {
        edges: [
          [[1, 3]],
          [
            [0, 3],
            [3, 12],
          ],
          [
            [4, 10],
            [5, 20],
          ],
          [[1, 12]],
          [
            [2, 10],
            [5, 15],
          ],
          [
            [2, 20],
            [4, 15],
          ],
        ],
      },
      {
        edges: [
          [
            [1, 3],
            [2, 5],
          ],
          [
            [0, 3],
            [2, 12],
            [3, 20],
            [4, 3],
          ],
          [
            [0, 5],
            [1, 12],
            [3, 14],
            [6, 10],
          ],
          [
            [1, 20],
            [2, 14],
            [4, 2],
          ],
          [
            [1, 3],
            [3, 2],
            [5, 11],
          ],
          [
            [4, 11],
            [6, 2],
          ],
          [
            [2, 10],
            [5, 2],
            [7, 100],
          ],
          [[6, 100]],
        ],
      },
    ],
  },
  {
    id: 'optimal-freelancing',
    name: 'Optimal Freelancing',
    category: 'Greedy Algorithms',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  <p>\n    You recently started freelance software development and have been offered\n    a variety of job opportunities. Each job has a deadline, meaning there is no\n    value in completing the work after the deadline. Additionally, each job\n    has an associated payment representing the profit for completing that job.\n    Given this information, write a function that returns the maximum profit that\n    can be obtained in a 7-day period.\n  </p>\n\n  <p>\n    Each job will take 1 full day to complete, and the deadline will be given\n    as the number of days left to complete the job. For example, if a job has a\n    deadline of 1, then it can only be completed if it is the first job worked\n    on. If a job has a deadline of 2, then it could be started on the first or\n    second day.\n  </p>\n\n  <p>\n    Note: There is no requirement to complete all of the jobs. Only one job can\n    be worked on at a time, meaning that in some scenarios it will be impossible\n    to complete them all.\n  </p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">jobs</span> = [\n  {"deadline": 1, "payment": 1},\n  {"deadline": 2, "payment": 1},\n  {"deadline": 2, "payment": 2}\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3 <span class="CodeEditor-promptComment">// Job 0 would be completed first, followed by job 2. Job 1 is not completed.</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  A good approach to this problem is to first think about which jobs you know\n  you want to try to complete, and start by fitting them into a schedule. Next\n  you can consider the lower priority jobs.\n</p>\n',
      '\n<p>\n  The jobs with the highest payments should be considered the highest priority\n  to fit into the schedule.\n</p>\n',
      '\n<p>\n  When placing the next highest priority job in the schedule, always schedule\n  it for as late as possible in order to avoid gaps in the schedule.\n</p>',
    ],
    customInputVars: [
      {
        name: 'jobs',
        example: [],
        schema: {
          items: {
            properties: {
              deadline: { type: 'integer' },
              payment: { type: 'integer' },
            },
            required: ['deadline', 'payment'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function optimalFreelancing(jobs) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.optimalFreelancing = optimalFreelancing;\n',
      solutions: [
        '// O(n * log(n)) time | O(1) space - where n is the number of jobs\nfunction optimalFreelancing(jobs) {\n  const LENGTH_OF_WEEK = 7;\n  let profit = 0;\n  jobs.sort((jobA, jobB) => jobB.payment - jobA.payment);\n  const timeline = new Array(LENGTH_OF_WEEK).fill(false);\n  for (const job of jobs) {\n    const maxTime = Math.min(job.deadline, LENGTH_OF_WEEK);\n    for (let time = maxTime - 1; time >= 0; time--) {\n      if (timeline[time] === false) {\n        timeline[time] = true;\n        profit += job.payment;\n        break;\n      }\n    }\n  }\n  return profit;\n}\n\n// Do not edit the line below.\nexports.optimalFreelancing = optimalFreelancing;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [{deadline: 1, payment: 1}];\n  const expected = 1;\n  const actual = program.optimalFreelancing(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [{deadline: 1, payment: 1}];\n  const expected = 1;\n  const actual = program.optimalFreelancing(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * log(n)) time | O(1) space - where n is the number of jobs',
    tests: [
      { jobs: [] },
      { jobs: [{ deadline: 1, payment: 1 }] },
      {
        jobs: [
          { deadline: 1, payment: 2 },
          { deadline: 1, payment: 1 },
        ],
      },
      {
        jobs: [
          { deadline: 1, payment: 1 },
          { deadline: 1, payment: 2 },
        ],
      },
      {
        jobs: [
          { deadline: 1, payment: 1 },
          { deadline: 2, payment: 1 },
        ],
      },
      {
        jobs: [
          { deadline: 1, payment: 1 },
          { deadline: 2, payment: 2 },
          { deadline: 2, payment: 1 },
        ],
      },
      {
        jobs: [
          { deadline: 8, payment: 3 },
          { deadline: 1, payment: 1 },
          { deadline: 1, payment: 2 },
        ],
      },
      {
        jobs: [
          { deadline: 2, payment: 2 },
          { deadline: 4, payment: 3 },
          { deadline: 5, payment: 1 },
          { deadline: 7, payment: 2 },
          { deadline: 3, payment: 1 },
          { deadline: 3, payment: 2 },
          { deadline: 1, payment: 3 },
        ],
      },
      {
        jobs: [
          { deadline: 2, payment: 1 },
          { deadline: 2, payment: 2 },
          { deadline: 2, payment: 3 },
          { deadline: 2, payment: 4 },
          { deadline: 2, payment: 5 },
          { deadline: 2, payment: 6 },
          { deadline: 2, payment: 7 },
        ],
      },
      {
        jobs: [
          { deadline: 8, payment: 1 },
          { deadline: 6, payment: 4 },
          { deadline: 1, payment: 2 },
          { deadline: 1, payment: 3 },
          { deadline: 2, payment: 3 },
          { deadline: 5, payment: 2 },
        ],
      },
      {
        jobs: [
          { deadline: 2, payment: 1 },
          { deadline: 1, payment: 4 },
          { deadline: 3, payment: 2 },
          { deadline: 1, payment: 3 },
          { deadline: 4, payment: 3 },
          { deadline: 4, payment: 2 },
          { deadline: 4, payment: 1 },
          { deadline: 5, payment: 4 },
          { deadline: 8, payment: 1 },
        ],
      },
      { jobs: [{ deadline: 10, payment: 1 }] },
      {
        jobs: [
          { deadline: 1, payment: 1 },
          { deadline: 2, payment: 1 },
          { deadline: 3, payment: 1 },
          { deadline: 4, payment: 1 },
          { deadline: 5, payment: 1 },
          { deadline: 6, payment: 1 },
          { deadline: 7, payment: 1 },
          { deadline: 8, payment: 1 },
          { deadline: 9, payment: 1 },
          { deadline: 10, payment: 1 },
        ],
      },
    ],
  },
  {
    id: 'zero-sum-subarray',
    name: 'Zero Sum Subarray',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a list of integers <span>nums</span>. Write a function that\n    returns a boolean representing whether there exists a zero-sum subarray of\n    <span>nums</span>.\n  </p>\n\n  <p>\n    A zero-sum subarray is any subarray where all of the values add up to zero.\n    A subarray is any contiguous section of the array. For the purposes of this\n    problem, a subarray can be as small as one element and as long as the\n    original array.\n  </p>\n<h3>Sample Input</h3>\n<pre><span class="CodeEditor-promptParameter">nums</span> = [-5, -5, 2, 3, -2]</pre>\n<h3>Sample Output</h3>\n<pre>\nTrue <span class="CodeEditor-promptComment">// The subarray [-5, 2, 3] has a sum of 0\n</span>\n</pre>',
    hints: [
      '<p>\n  A good way to approach this problem is to first think of a simpler version.\n  How would you check if the entire array sum is zero?\n</p>\n',
      '\n<p>\n  If the entire array does not sum to zero, then you need to check if there are\n  any smaller subarrays that sum to zero. For this, it can be helpful to keep\n  track of all of the sums from [0, i], where i is every index in the array.\n</p>\n',
      '\n<p>\n  After recording all sums from [0, i], what would it mean if a sum is repeated?\n</p>',
    ],
    customInputVars: [
      {
        name: 'nums',
        example: [],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function zeroSumSubarray(nums) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.zeroSumSubarray = zeroSumSubarray;\n',
      solutions: [
        '// O(n) time | O(n) space - where n is the length of nums\nfunction zeroSumSubarray(nums) {\n  const sums = new Set([0]);\n  let currentSum = 0;\n  for (const num of nums) {\n    currentSum += num;\n    if (sums.has(currentSum)) return true;\n    sums.add(currentSum);\n  }\n\n  return false;\n}\n\n// Do not edit the line below.\nexports.zeroSumSubarray = zeroSumSubarray;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [4, 2, -1, -1, 3];\n  const expected = true;\n  const actual = program.zeroSumSubarray(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [4, 2, -1, -1, 3];\n  const expected = true;\n  const actual = program.zeroSumSubarray(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the length of nums',
    tests: [
      { nums: [] },
      { nums: [0] },
      { nums: [1] },
      { nums: [1, 2, 3] },
      { nums: [1, 1, 1] },
      { nums: [-1, -1, -1] },
      { nums: [0, 0, 0] },
      { nums: [1, 2, -2, 3] },
      { nums: [2, -2] },
      { nums: [-1, 2, 3, 4, -5, -3, 1, 2] },
      { nums: [-2, -3, -1, 2, 3, 4, -5, -3, 1, 2] },
      { nums: [2, 3, 4, -5, -3, 4, 5] },
      { nums: [2, 3, 4, -5, -3, 5, 5] },
      { nums: [1, 2, 3, 4, 0, 5, 6, 7] },
      { nums: [1, 2, 3, -2, -1] },
      { nums: [-8, -22, 104, 73, -120, 53, 22, -12, 1, 14, -90, 13, -22] },
      {
        nums: [
          -8, -22, 104, 73, -120, 53, 22, 20, 25, -12, 1, 14, -90, 13, -22,
        ],
      },
    ],
  },
  {
    id: 'semordnilap',
    name: 'Semordnilap',
    category: 'Strings',
    complexity: 0,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a list of unique strings and returns a list of\n  semordnilap pairs.\n</p>\n<p>\n  A semordnilap pair is defined as a set of different strings where the reverse\n  of one word is the same as the forward version of the other. For example the\n  words "diaper" and "repaid" are a semordnilap pair, as are the words\n  "palindromes" and "semordnilap".\n</p>\n<p>\n  The order of the returned pairs and the order of the strings within each pair\n  does not matter.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">words</span> = ["diaper", "abc", "test", "cba", "repaid"]\n</pre>\n<h3>Sample Output</h3>\n<pre>[["diaper", "repaid"], ["abc", "cba"]]</pre>\n</div>',
    hints: [
      '<p>\n  It can be helpful to convert the input array into a set, so that you can\n  check if a word exists in the list in constant time.\n</p>\n',
      '\n<p>\n  After creating the set of words, try iterating through the original array. For\n  each word, can you check if its semordnilap pair is in the word list?\n</p>',
    ],
    customInputVars: [
      {
        name: 'words',
        example: [],
        schema: { items: { type: 'string' }, minItems: 0, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function semordnilap(words) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.semordnilap = semordnilap;\n',
      solutions: [
        "// O(n * m) time | O(n * m) space - where n is the number of words and\n// m is the length of the longest word\nfunction semordnilap(words) {\n  const wordsSet = new Set(words);\n  const semordnilapPairs = [];\n\n  for (const word of words) {\n    const reverse = word.split('').reverse().join('');\n    if (wordsSet.has(reverse) && reverse !== word) {\n      semordnilapPairs.push([word, reverse]);\n      wordsSet.delete(word);\n      wordsSet.delete(reverse);\n    }\n  }\n\n  return semordnilapPairs;\n}\n\n// Do not edit the line below.\nexports.semordnilap = semordnilap;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['desserts', 'stressed', 'hello'];\n  const expected = [['desserts', 'stressed']];\n  const actual = program.semordnilap(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['desserts', 'stressed', 'hello'];\n  const expected = [['desserts', 'stressed']];\n  const actual = program.semordnilap(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * m) time | O(n * m) space - where n is the number of words and m is the length of the longest word',
    tests: [
      { words: [] },
      { words: ['aaa', 'bbbb'] },
      { words: ['dog', 'god'] },
      { words: ['dog', 'hello', 'god'] },
      { words: ['dog', 'desserts', 'god', 'stressed'] },
      { words: ['dog', 'hello', 'desserts', 'test', 'god', 'stressed'] },
      { words: ['abcde', 'edcba', 'edbc', 'edb', 'cbde', 'abc'] },
      { words: ['abcde', 'bcd', 'dcb', 'edcba', 'aaa'] },
      { words: ['abcdefghijk', 'aaa', 'hello', 'racecar', 'kjihgfedcba'] },
      {
        words: [
          'liver',
          'dog',
          'hello',
          'desserts',
          'evil',
          'test',
          'god',
          'stressed',
          'racecar',
          'palindromes',
          'semordnilap',
          'abcd',
          'live',
        ],
      },
    ],
  },
  {
    id: 'merging-linked-lists',
    name: 'Merging Linked Lists',
    category: 'Linked Lists',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given two Linked Lists of potentially unequal length. These Linked\n    Lists potentially merge at a shared intersection node. Write a function\n    that returns the intersection node or returns <span>None</span> /\n    <span>null</span> if there is no intersection.\n  </p>\n  <p>\n    Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n    a <span>next</span> node pointing to the next node in the list or to\n    <span>None</span> / <span>null</span> if it\'s the tail of the list.\n  </p>\n  <p>\n    Note: Your function should return an existing node. It should not modify\n    either Linked List, and it should not create any new Linked Lists.\n  </p>\n  <h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">linkedListOne</span> = 2 -> 3 -> 1 -> 4\n<span class="CodeEditor-promptParameter">linkedListTwo</span> = 8 -> 7 -> 1 -> 4\n</pre>\n  <h3>Sample Output</h3>\n<pre>\n1 -> 4 <span class="CodeEditor-promptComment">// The lists intersect at the node with value 1</span>\n</pre>\n  </div>',
    hints: [
      '<p>\n  All of the nodes after the intersection point of two Linked Lists will be the\n  same.\n</p>\n',
      '\n<p>\n  If the two Linked Lists are of different lengths, then none of the extra nodes\n  of the longer list at the beginning can be the intersection point, since the\n  ends must be the same.\n</p>\n',
      '\n<p>\n  The length of the first list + the distance of the second head from the\n  intersection point will be equal to the length of the second list + the\n  distance of the first head from the intersection point. This can be proven\n  using the information from hints 1 and 2.\n</p>',
    ],
    customInputVars: [
      {
        name: 'linkedListOne',
        example: { head: '1', nodes: [{ id: '1', next: null, value: 1 }] },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
      {
        name: 'linkedListTwo',
        example: { head: '2', nodes: [{ id: '2', next: null, value: 2 }] },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexports.LinkedList = LinkedList;\n\nfunction mergingLinkedLists(linkedListOne, linkedListTwo) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the line below.\nexports.mergingLinkedLists = mergingLinkedLists;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(n) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunction mergingLinkedLists(linkedListOne, linkedListTwo) {\n  const listOneNodes = new Set();\n  let currentNodeOne = linkedListOne;\n  while (currentNodeOne !== null) {\n    listOneNodes.add(currentNodeOne);\n    currentNodeOne = currentNodeOne.next;\n  }\n\n  let currentNodeTwo = linkedListTwo;\n  while (currentNodeTwo !== null) {\n    if (listOneNodes.has(currentNodeTwo)) return currentNodeTwo;\n    currentNodeTwo = currentNodeTwo.next;\n  }\n\n  return null;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.mergingLinkedLists = mergingLinkedLists;\n',
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunction mergingLinkedLists(linkedListOne, linkedListTwo) {\n  let currentNodeOne = linkedListOne;\n  let countOne = 0;\n  while (currentNodeOne !== null) {\n    countOne++;\n    currentNodeOne = currentNodeOne.next;\n  }\n\n  let currentNodeTwo = linkedListTwo;\n  let countTwo = 0;\n  while (currentNodeTwo !== null) {\n    countTwo++;\n    currentNodeTwo = currentNodeTwo.next;\n  }\n\n  const difference = Math.abs(countTwo - countOne);\n  let biggerCurrentNode = countOne > countTwo ? linkedListOne : linkedListTwo;\n  let smallerCurrentNode = countOne > countTwo ? linkedListTwo : linkedListOne;\n\n  for (let i = 0; i < difference; i++) {\n    biggerCurrentNode = biggerCurrentNode.next;\n  }\n\n  while (biggerCurrentNode !== smallerCurrentNode) {\n    biggerCurrentNode = biggerCurrentNode.next;\n    smallerCurrentNode = smallerCurrentNode.next;\n  }\n\n  return biggerCurrentNode;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.mergingLinkedLists = mergingLinkedLists;\n',
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n + m) time | O(1) space - where n is the length of the\n// first Linked List and m is the length of the second Linked List\nfunction mergingLinkedLists(linkedListOne, linkedListTwo) {\n  let currentNodeOne = linkedListOne;\n  let currentNodeTwo = linkedListTwo;\n\n  while (currentNodeOne !== currentNodeTwo) {\n    if (currentNodeOne === null) {\n      currentNodeOne = linkedListTwo;\n    } else {\n      currentNodeOne = currentNodeOne.next;\n    }\n\n    if (currentNodeTwo === null) {\n      currentNodeTwo = linkedListOne;\n    } else {\n      currentNodeTwo = currentNodeTwo.next;\n    }\n  }\n\n  return currentNodeOne;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.mergingLinkedLists = mergingLinkedLists;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const l1 = new program.LinkedList(1);\n  l1.next = new program.LinkedList(2);\n  const l2 = new program.LinkedList(3);\n  l2.next = l1.next;\n\n  const expected = l1.next;\n  const actual = program.mergingLinkedLists(l1, l2);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const l1 = new program.LinkedList(1);\n  l1.next = new program.LinkedList(2);\n  const l2 = new program.LinkedList(3);\n  l2.next = l1.next;\n\n  const expected = l1.next;\n  const actual = program.mergingLinkedLists(l1, l2);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n + m) time | O(1) space - where n is the length of the first Linked List and m is the length of the second Linked List',
    tests: [
      {
        linkedListOne: {
          head: '1',
          nodes: [{ id: '1', next: null, value: 1 }],
        },
        linkedListTwo: {
          head: '2',
          nodes: [{ id: '2', next: null, value: 2 }],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [{ id: '1', next: null, value: 1 }],
        },
        linkedListTwo: {
          head: '1',
          nodes: [{ id: '1', next: null, value: 1 }],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: null, value: 2 },
          ],
        },
        linkedListTwo: {
          head: '4',
          nodes: [
            { id: '4', next: '2', value: 4 },
            { id: '2', next: null, value: 2 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: null, value: 3 },
          ],
        },
        linkedListTwo: {
          head: '4',
          nodes: [
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '3', value: 5 },
            { id: '3', next: null, value: 3 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: null, value: 4 },
          ],
        },
        linkedListTwo: {
          head: '5',
          nodes: [
            { id: '5', next: '3', value: 5 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: null, value: 4 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [{ id: '1', next: null, value: 1 }],
        },
        linkedListTwo: {
          head: '2',
          nodes: [
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '1', value: 4 },
            { id: '1', next: null, value: 1 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '5',
          nodes: [
            { id: '5', next: '12', value: 5 },
            { id: '12', next: '14', value: 12 },
            { id: '14', next: '2', value: 14 },
            { id: '2', next: '13', value: 2 },
            { id: '13', next: '21', value: 13 },
            { id: '21', next: '33', value: 21 },
            { id: '33', next: '9', value: 33 },
            { id: '9', next: null, value: 9 },
          ],
        },
        linkedListTwo: {
          head: '10',
          nodes: [
            { id: '10', next: '3', value: 10 },
            { id: '3', next: '48', value: 3 },
            { id: '48', next: '0', value: 48 },
            { id: '0', next: '13', value: 0 },
            { id: '13', next: '21', value: 13 },
            { id: '21', next: '33', value: 21 },
            { id: '33', next: '9', value: 33 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: null, value: 2 },
          ],
        },
        linkedListTwo: {
          head: '3',
          nodes: [
            { id: '3', next: '4', value: 3 },
            { id: '4', next: null, value: 4 },
          ],
        },
      },
      {
        linkedListOne: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: null, value: 2 },
          ],
        },
        linkedListTwo: {
          head: '3',
          nodes: [
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: null, value: 6 },
          ],
        },
      },
    ],
  },
  {
    id: 'symmetrical-tree',
    name: 'Symmetrical Tree',
    category: 'Binary Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree and returns if that tree is\n  symmetrical. A tree is symmetrical if the left and right subtrees are\n  mirror images of each other.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =    1\n       /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      2       2\n    /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   3     4 4     3\n /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\          /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n5     6        6    5\n</pre>\n<h3>Sample Output</h3>\n<pre>True</pre>\n</div>',
    hints: [
      "<p>\n  It's important to first think about what it means for a binary tree to be\n  symmetrical. The left and right subtrees do not need to be the same, but\n  rather they need to be mirror images of each other (i.e. the same if one\n  is inverted).\n</p>\n",
      '\n<p>\n  It can be helpful to think about this problem one step at a time. Looking at\n  just the first node, how can you ensure its children are symmetrical? Then\n  looking at those children, how can you make sure they are symmetrical of each\n  other?\n</p>\n',
      '\n<p>\n  This problem can be solved either recursively or iteratively. Either way, try\n  traversing through the tree, uses a mirrored traversal on one side, and check\n  that the values of each node are the same.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.BinaryTree = BinaryTree;\n\nfunction symmetricalTree(tree) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.symmetricalTree = symmetricalTree;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nfunction symmetricalTree(tree) {\n  const stackLeft = [tree.left];\n  const stackRight = [tree.right];\n\n  while (stackLeft.length > 0) {\n    const left = stackLeft.pop();\n    const right = stackRight.pop();\n\n    if (left === null && right === null) continue;\n\n    if (left === null || right === null || left.value != right.value) {\n      return false;\n    }\n\n    stackLeft.push(left.left);\n    stackLeft.push(left.right);\n    stackRight.push(right.right);\n    stackRight.push(right.left);\n  }\n\n  return true;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.symmetricalTree = symmetricalTree;\n',
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree\n// and h is the height of the tree.\nfunction symmetricalTree(tree) {\n  return treesAreMirrored(tree.left, tree.right);\n}\n\nfunction treesAreMirrored(left, right) {\n  if (left !== null && right !== null && left.value === right.value) {\n    return treesAreMirrored(left.left, right.right) && treesAreMirrored(left.right, right.left);\n  }\n\n  return left === right;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.symmetricalTree = symmetricalTree;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(6);\n  tree.left = new BinaryTree(5);\n  tree.right = new BinaryTree(5);\n  tree.left.left = new BinaryTree(7);\n  tree.left.right = new BinaryTree(9);\n  tree.right.left = new BinaryTree(9);\n  tree.right.right = new BinaryTree(7);\n  const expected = true;\n  const actual = program.symmetricalTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nit('Test Case #1', function () {\n  const tree = new BinaryTree(6);\n  tree.left = new BinaryTree(5);\n  tree.right = new BinaryTree(5);\n  tree.left.left = new BinaryTree(7);\n  tree.left.right = new BinaryTree(9);\n  tree.right.left = new BinaryTree(9);\n  tree.right.right = new BinaryTree(7);\n  const expected = true;\n  const actual = program.symmetricalTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(h) space - where n is the number of nodes in the tree and h is the height of the tree.',
    tests: [
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: null, value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '2-2', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '2-2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '2-2', value: 1 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '2-2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '2-2', value: 1 },
            { id: '2', left: '3', right: '3-2', value: 2 },
            { id: '2-2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '3-2', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '2-2', value: 1 },
            { id: '2', left: '3', right: '3-2', value: 2 },
            { id: '2-2', left: '3-3', right: '3-4', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '3-2', left: null, right: null, value: 3 },
            { id: '3-3', left: null, right: null, value: 3 },
            { id: '3-4', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '2-2', value: 1 },
            { id: '2', left: '3', right: '4', value: 2 },
            { id: '2-2', left: '4-2', right: '3-2', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '3-2', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '4-2', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '2-2', value: 1 },
            { id: '2', left: '3', right: '4', value: 2 },
            { id: '2-2', left: '3-2', right: '4-2', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '3-2', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '4-2', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '5', value: 1 },
            { id: '2', left: '3', right: '4', value: 2 },
            { id: '5', left: '4-2', right: '3-2', value: 5 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '3-2', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '4-2', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '2-2', value: 1 },
            { id: '2', left: '3', right: '4', value: 2 },
            { id: '2-2', left: '4-2', right: '3-2', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '3-2', left: null, right: null, value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '4-2', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '2-2', value: 1 },
            { id: '2', left: '3', right: '4', value: 2 },
            { id: '2-2', left: '4-2', right: '3-2', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '3-2', left: null, right: null, value: 3 },
            { id: '4', left: '5-2', right: null, value: 4 },
            { id: '4-2', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'knight-connection',
    name: 'Knight Connection',
    category: 'Arrays',
    complexity: 2,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given the position of two knight pieces on an infinite chess board.\n    Write a function that returns the minimum number of turns required before\n    one of the knights is able to capture the other knight, assuming the knights\n    are working together to achieve this goal.\n  </p>\n\n  <p>\n    The position of each knight is given as a list of 2 values, the x and y\n    coordinates. A knight can make 1 of 8 possible moves on any given turn. Each\n    of these moves involves moving in an "L" shape. This means they can either\n    move 2 squares horizontally and 1 square vertically, or they can move 1\n    square horizontally and 2 squares vertically. For example, if a knight is\n    currently at position [0, 0], then it can move to any of these 8 locations\n    on its next move:\n  </p>\n\n  <pre>\n[\n  [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2], [-2, -1]\n]</pre\n  >\n\n  <p>\n    A knight is able to capture the other knight when it is able to move onto\n    the square currently occupied by the other knight.\n  </p>\n\n  <p>\n    Each turn allows each knight to move up to one time. For example, if both\n    knights moved towards each other once, and then knightA captures knightB on\n    its next move, two turns would have been used (even though knightB never\n    made its second move).\n  </p>\n  <h3>Sample Input</h3>\n  <pre><span class="CodeEditor-promptParameter">knightA</span> = [0, 0]\n<span class="CodeEditor-promptParameter">knightB</span> = [4, 2]</pre>\n  <h3>Sample Output</h3>\n  <pre>\n1 <span class="CodeEditor-promptComment">// knightA moves to [2, 1], knightB captures knightA on [2, 1]\n</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  The number of turns needed for two knights to meet on a common square is the\n  same as the number of moves needed for a single knight to reach the other knight\n  divided by two (and rounded up to account for odd numbers of moves).\n</p>\n',
      '\n<p>\n  Rather than thinking of this problem in terms of chess, try thinking about\n  it as a graph problem. What are the nodes and what are the edges?\n</p>\n',
      '\n<p>\n  As a graph problem, you can consider each square on the board as a node, and\n  each possible knight move as an edge. Then you can find the distance between\n  those nodes using standard graph algorithms, such as BFS.\n</p>',
    ],
    customInputVars: [
      {
        name: 'knightA',
        example: [0, 0],
        schema: {
          items: { type: 'integer' },
          maxItems: 2,
          minItems: 2,
          type: 'array',
        },
      },
      {
        name: 'knightB',
        example: [0, 0],
        schema: {
          items: { type: 'integer' },
          maxItems: 2,
          minItems: 2,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function knightConnection(knightA, knightB) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.knightConnection = knightConnection;\n',
      solutions: [
        "// O(n * m) time | O(n * m) space - where n is horizontal distance between\n// the knights and m is the vertical distance between the knights\nfunction knightConnection(knightA, knightB) {\n  const possibleMoves = [\n    [-2, 1],\n    [-1, 2],\n    [1, 2],\n    [2, 1],\n    [2, -1],\n    [1, -2],\n    [-1, -2],\n    [-2, -1],\n  ];\n\n  const queue = [[knightA[0], knightA[1], 0]];\n  const visited = new Set(positionToString(knightA));\n\n  while (true) {\n    // In JavaScript, shifting elements from the start of an array is an O(n)-time operation.\n    // To make this an O(1)-time operation, we could use a more legitimate queue structure.\n    // For our time complexity analysis, we'll assume this runs in O(1) time.\n    const currentPosition = queue.shift();\n\n    if (currentPosition[0] === knightB[0] && currentPosition[1] === knightB[1]) {\n      return Math.ceil(currentPosition[2] / 2);\n    }\n\n    for (const possibleMove of possibleMoves) {\n      const position = [currentPosition[0] + possibleMove[0], currentPosition[1] + possibleMove[1]];\n      const positionString = positionToString(position);\n      if (!visited.has(positionString)) {\n        position.push(currentPosition[2] + 1);\n        queue.push(position);\n        visited.add(positionString);\n      }\n    }\n  }\n}\n\nfunction positionToString(position) {\n  return position.join(',');\n}\n\n// Do not edit the line below.\nexports.knightConnection = knightConnection;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const knightA = [0, 0];\n  const knightB = [2, 1];\n  const expected = 1;\n  const actual = program.knightConnection(knightA, knightB);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const knightA = [0, 0];\n  const knightB = [2, 1];\n  const expected = 1;\n  const actual = program.knightConnection(knightA, knightB);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * m) time | O(n * m) space - where n is horizontal distance between the knights and m is the vertical distance between the knights',
    tests: [
      { knightA: [0, 0], knightB: [0, 0] },
      { knightA: [15, -12], knightB: [15, -12] },
      { knightA: [1, 0], knightB: [0, 0] },
      { knightA: [0, 0], knightB: [1, 0] },
      { knightA: [1, 1], knightB: [0, 0] },
      { knightA: [0, 0], knightB: [-1, -1] },
      { knightA: [2, 1], knightB: [0, 0] },
      { knightA: [3, 3], knightB: [0, 0] },
      { knightA: [2, 1], knightB: [-1, -2] },
      { knightA: [2, 1], knightB: [-2, -4] },
      { knightA: [5, 2], knightB: [-2, -4] },
      { knightA: [10, 10], knightB: [-10, -10] },
      { knightA: [15, 15], knightB: [-10, -10] },
      { knightA: [-15, 2], knightB: [-3, 20] },
      { knightA: [20, 20], knightB: [0, 0] },
      { knightA: [18, -13], knightB: [0, 12] },
    ],
  },
  {
    id: 'dice-throws',
    name: 'Dice Throws',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a set of <span>numDice</span> dice, each with\n    <span>numSides</span> sides, and a <span>target</span> integer, which\n    represents a target sum to obtain when rolling all of the dice and summing\n    their values. Write a function that returns the total number of dice-roll\n    permutations that sum up to exactly that target value.\n  </p>\n  <p>\n    All three input values will always be positive integers. Each of the dice\n    has an equal probability of landing on any number from 1 to\n    <span>numSides</span>. Identical total dice rolls obtained from different\n    individual dice rolls (for example, <span>[2, 3]</span> vs.\n    <span>[3, 2]</span>) count as different dice-roll permutations. If there\'s\n    no possible dice-roll combination that sums up to the\n    <span>target</span> given the input dice, your function should return 0.\n  </p>\n\n  <h3>Sample Input</h3>\n  <pre><span class="CodeEditor-promptParameter">numDice</span> = 2\n<span class="CodeEditor-promptParameter">numSides</span> = 6\n<span class="CodeEditor-promptParameter">target</span> = 7</pre>\n  <h3>Sample Output</h3>\n  <pre>\n6 <span class="CodeEditor-promptComment">// [1, 6], [2, 5], [3, 4], [4, 3], [5, 2], [6, 1]\n</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  It can be helpful to start by thinking about simple cases. When do you know the\n  answer will be 0 or -1?\n</p>\n',
      '\n<p>\n  If you had the solution of all simpler inputs, how would you find the solution\n  for the given input?\n</p>\n',
      '\n<p>\n  The solution to <span>diceThrows(numThrows, numSides, target)</span> can be\n  thought of as the sum of\n  <span>diceThrows(numThrows - 1, numSides, target)</span> for all possible\n  target values between <span>target - numSides</span> and <span>target</span>.\n</p>',
    ],
    customInputVars: [
      { name: 'numDice', example: 1, schema: { minimum: 0, type: 'integer' } },
      { name: 'numSides', example: 6, schema: { minimum: 1, type: 'integer' } },
      { name: 'target', example: 7, schema: { minimum: 0, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function diceThrows(numDice, numSides, target) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.diceThrows = diceThrows;\n',
      solutions: [
        '// O(d * s * t) time | O(d * t) space - where d is the number of dice, s is the\n// number of sides, and t is the target.\nfunction diceThrows(numDice, numSides, target) {\n  const storedResults = new Array(numDice + 1)\n    .fill(undefined)\n    .map(_ => new Array(target + 1).fill(-1));\n  return diceThrowsHelper(numDice, numSides, target, storedResults);\n}\n\nfunction diceThrowsHelper(numDice, numSides, target, storedResults) {\n  if (numDice === 0) return target === 0 ? 1 : 0;\n\n  if (storedResults[numDice][target] > -1) return storedResults[numDice][target];\n\n  let numWaysToReachTarget = 0;\n  for (\n    let currentTarget = Math.max(0, target - numSides);\n    currentTarget < target;\n    currentTarget++\n  ) {\n    numWaysToReachTarget += diceThrowsHelper(numDice - 1, numSides, currentTarget, storedResults);\n  }\n  storedResults[numDice][target] = numWaysToReachTarget;\n\n  return numWaysToReachTarget;\n}\n\n// Do not edit the line below.\nexports.diceThrows = diceThrows;\n',
        '// O(d * s * t) time | O(d * t) space - where d is the number of dice, s is the\n// number of sides, and t is the target.\nfunction diceThrows(numDice, numSides, target) {\n  const storedResults = new Array(numDice + 1)\n    .fill(undefined)\n    .map(_ => new Array(target + 1).fill(0));\n  storedResults[0][0] = 1;\n\n  for (let currentNumDice = 1; currentNumDice < numDice + 1; currentNumDice++) {\n    for (let currentTarget = 0; currentTarget < target + 1; currentTarget++) {\n      let numWaysToReachTarget = 0;\n      for (\n        let currentNumSides = 1;\n        currentNumSides < Math.min(currentTarget, numSides) + 1;\n        currentNumSides++\n      ) {\n        numWaysToReachTarget += storedResults[currentNumDice - 1][currentTarget - currentNumSides];\n      }\n      storedResults[currentNumDice][currentTarget] = numWaysToReachTarget;\n    }\n  }\n\n  return storedResults[numDice][target];\n}\n\n// Do not edit the line below.\nexports.diceThrows = diceThrows;\n',
        '// O(d * s * t) time | O(t) space - where d is the number of dice, s is the\n// number of sides, and t is the target.\nfunction diceThrows(numDice, numSides, target) {\n  const storedResults = [new Array(target + 1).fill(0), new Array(target + 1).fill(0)];\n  storedResults[0][0] = 1;\n\n  let previousNumDiceIndex = 0;\n  let newNumDiceIndex = 1;\n  for (let i = 0; i < numDice; i++) {\n    for (let currentTarget = 0; currentTarget < target + 1; currentTarget++) {\n      let numWaysToReachTarget = 0;\n      for (\n        let currentNumSides = 1;\n        currentNumSides < Math.min(currentTarget, numSides) + 1;\n        currentNumSides++\n      ) {\n        numWaysToReachTarget +=\n          storedResults[previousNumDiceIndex][currentTarget - currentNumSides];\n      }\n      storedResults[newNumDiceIndex][currentTarget] = numWaysToReachTarget;\n    }\n    const temp = previousNumDiceIndex;\n    previousNumDiceIndex = newNumDiceIndex;\n    newNumDiceIndex = temp;\n  }\n\n  return storedResults[previousNumDiceIndex][target];\n}\n\n// Do not edit the line below.\nexports.diceThrows = diceThrows;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const numDice = 2;\n  const numSides = 6;\n  const target = 7;\n  const expected = 6;\n  const actual = program.diceThrows(numDice, numSides, target);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const numDice = 2;\n  const numSides = 6;\n  const target = 7;\n  const expected = 6;\n  const actual = program.diceThrows(numDice, numSides, target);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(d * s * t) time | O(t) space - where d is the number of throws, s is the number of sides, and t is the target.',
    tests: [
      { numDice: 1, numSides: 6, target: 7 },
      { numDice: 2, numSides: 1, target: 3 },
      { numDice: 1, numSides: 6, target: 5 },
      { numDice: 2, numSides: 6, target: 12 },
      { numDice: 2, numSides: 6, target: 7 },
      { numDice: 3, numSides: 10, target: 12 },
      { numDice: 12, numSides: 9, target: 108 },
      { numDice: 12, numSides: 9, target: 12 },
      { numDice: 7, numSides: 5, target: 22 },
      { numDice: 4, numSides: 6, target: 15 },
      { numDice: 3, numSides: 9, target: 11 },
      { numDice: 6, numSides: 6, target: 20 },
      { numDice: 11, numSides: 9, target: 32 },
    ],
  },
  {
    id: 'count-squares',
    name: 'Count Squares',
    category: 'Arrays',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a list of Cartesian coordinates (i.e., (x, y)\n  coordinates) and returns the number of squares that can be formed by these\n  coordinates.\n</p>\n<p>\n  A square must have its four corners amongst the coordinates in order to be\n  counted. A single coordinate can be used as a corner for multiple different\n  squares.\n</p>\n<p>\n  You can also assume that no coordinate will be farther than 100 units from the\n  origin.\n</p>\n\n<h3>Sample Input</h3>\n<pre><span class="CodeEditor-promptParameter">points</span> = [\n  [1, 1],\n  [0, 0],\n  [-4, 2],\n  [-2, -1],\n  [0, 1],\n  [1, 0],\n  [-1, 4]\n]</pre>\n<h3>Sample Output</h3>\n<pre>2 <span class="CodeEditor-promptComment"> // [1, 1], [0, 0], [0, 1], and [1, 0] makes a square,\n// as does [1, 1], [-4, 2], [-2, -1], and [-1, 4]</span></pre>',
    hints: [
      '<p>\n  Given any two points, there are exactly three pairs of points that would make\n  a square.\n</p>\n',
      '\n<p>\n  If two points are assumed to be diagonally across from each other in a square,\n  there is only one pair of points that would complete the square.\n</p>\n',
      '\n<p>\n  All four points of a square will always be equidistant from the midpoint.\n</p>\n',
      '\n<p>\n  The slopes of the two diagonals of a square are always negative reciprocals of\n  each other.\n</p>',
    ],
    customInputVars: [
      {
        name: 'points',
        example: [],
        schema: {
          items: {
            items: { type: 'integer' },
            maxItems: 2,
            minItems: 2,
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function countSquares(points) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.countSquares = countSquares;\n',
      solutions: [
        "// O(n^2) time | O(n) space - where n is the number of points\nfunction countSquares(points) {\n  const pointsSet = new Set();\n  for (const point of points) {\n    pointsSet.add(pointToString(point));\n  }\n\n  let count = 0;\n  for (const pointA of points) {\n    for (const pointB of points) {\n      if (pointA === pointB) continue;\n\n      const midpoint = [(pointA[0] + pointB[0]) / 2, (pointA[1] + pointB[1]) / 2];\n      const xDistanceFromMid = pointA[0] - midpoint[0];\n      const yDistanceFromMid = pointA[1] - midpoint[1];\n\n      const pointC = [midpoint[0] + yDistanceFromMid, midpoint[1] - xDistanceFromMid];\n      const pointD = [midpoint[0] - yDistanceFromMid, midpoint[1] + xDistanceFromMid];\n\n      if (pointsSet.has(pointToString(pointC)) && pointsSet.has(pointToString(pointD))) {\n        count++;\n      }\n    }\n  }\n\n  return count / 4;\n}\n\nfunction pointToString(point) {\n  return point.join(',');\n}\n\n// Do not edit the line below.\nexports.countSquares = countSquares;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [0, 0],\n    [0, 1],\n    [1, 0],\n  ];\n  const expected = 1;\n  const actual = program.countSquares(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 1],\n    [0, 0],\n    [0, 1],\n    [1, 0],\n  ];\n  const expected = 1;\n  const actual = program.countSquares(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n^2) time | O(n) space - where n is the number of points',
    tests: [
      { points: [] },
      { points: [[1, 0]] },
      {
        points: [
          [0, 1],
          [1, 0],
        ],
      },
      {
        points: [
          [0, 0],
          [0, 1],
          [1, 0],
        ],
      },
      {
        points: [
          [1, 1],
          [0, 0],
          [0, 1],
          [1, 0],
        ],
      },
      {
        points: [
          [1, 1],
          [0, 0],
          [-4, 2],
          [-2, -1],
          [0, 1],
          [1, 0],
          [-1, 4],
        ],
      },
      {
        points: [
          [1, 1],
          [3, -3],
          [0, 0],
          [0, 1],
          [-1, 3],
          [6, 2],
          [0, -2],
          [1, 0],
          [4, 0],
          [5, 1],
          [1, 5],
          [-2, 0],
        ],
      },
      {
        points: [
          [1, 1],
          [0, 0],
          [0, 1],
          [2, 0],
        ],
      },
      {
        points: [
          [-1, -1],
          [1, 1],
          [-1, 1],
          [1, -1],
        ],
      },
      {
        points: [
          [-2, -2],
          [2, 2],
          [0, 0],
          [-2, 2],
          [2, -2],
        ],
      },
      {
        points: [
          [0, 0],
          [1, 1],
          [1, 0],
          [2, 1],
          [2, 0],
        ],
      },
      {
        points: [
          [1, -1],
          [-1, 3],
          [3, 5],
          [5, 1],
        ],
      },
      {
        points: [
          [1, 1],
          [0, 0],
          [0, 1],
          [1, 0],
          [2, 2],
          [1, 2],
          [2, 1],
        ],
      },
      {
        points: [
          [1, 1],
          [0, 0],
          [0, 1],
          [1, 0],
          [-1, 3],
          [3, 5],
          [5, 1],
          [1, -1],
        ],
      },
      {
        points: [
          [3, 1],
          [1, 1],
          [0, 0],
          [0, 1],
          [3, 7],
          [1, 0],
          [-1, 3],
          [3, 5],
          [5, 1],
          [9, 1],
          [1, -1],
          [9, 7],
        ],
      },
      {
        points: [
          [3, 1],
          [1, 1],
          [0, 0],
          [0, 1],
          [3, 7],
          [1, 0],
          [-4, -2],
          [27, -5],
          [-1, 3],
          [3, 5],
          [5, 1],
          [10, -19],
          [9, 1],
          [1, -1],
          [9, 7],
          [13, 12],
        ],
      },
      {
        points: [
          [3, 1],
          [1, 1],
          [21, 19],
          [0, 0],
          [0, 1],
          [3, 7],
          [1, 0],
          [12, -14],
          [-4, -2],
          [27, -5],
          [-1, 3],
          [3, 5],
          [5, 1],
          [10, -19],
          [9, 1],
          [1, -1],
          [9, 7],
          [13, 12],
          [0, 7],
          [33, -2],
        ],
      },
      {
        points: [
          [21, 1],
          [3, 1],
          [1, 1],
          [21, 19],
          [0, 0],
          [0, 1],
          [2, 3],
          [22, 2],
          [3, 7],
          [1, 0],
          [12, -14],
          [-4, -2],
          [-22, 22],
          [27, -5],
          [-1, 3],
          [3, 5],
          [5, 1],
          [10, -19],
          [9, 1],
          [1, -1],
          [9, 7],
          [13, 12],
          [0, 7],
          [3, 19],
          [33, -2],
        ],
      },
    ],
  },
  {
    id: 'juice-bottling',
    name: 'Juice Bottling',
    category: 'Dynamic Programming',
    complexity: 2,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given an array of integers <span>prices</span> of length\n    <span>n</span> with the retail prices of various quantities of juice. Each\n    index in this array corresponds to the price of that amount of juice. For\n    example, <span>prices[2]</span> would be the retail price of 2 units of\n    juice.\n  </p>\n\n  <p>\n    You have <span>n - 1</span> total units of juice. For example, if the length\n    of <span>prices</span> is 5, then you would have 4 total units of juice.\n    Write a function to determine the optimal way to bottle the juice such that\n    it maximizes revenue. This function should return a list of all of the\n    juice quantities required in ascending order.\n  </p>\n\n  <p>\n    Note that the first value in the <span>prices</span> array will always be 0,\n    because there is no value in no juice. All other values will be positive\n    integers. Additionally, a larger quantity of juice will not always be more\n    expensive than a smaller quantity. For simplicity, all of the test cases\n    only have one possible solution.\n  </p>\n\n  <h3>Sample Input</h3>\n  <pre><span class="CodeEditor-promptParameter">prices</span> = [0, 1, 3, 2]</pre>\n  <h3>Sample Output</h3>\n  <pre>[1, 2] <span class="CodeEditor-promptComment">// We have 3 total units of juice,\n// because the length of prices is 4.\n// To maximize revenue, we split the juice into\n// quantities of 1 and 2, giving a revenue of 1 + 3 = 4\n</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  If there were only 2 units of juice, how would you decide if it needs to be\n  broken up?\n</p>\n',
      '\n<p>\n  If we add a third unit of juice, can you use the price of that entire unit and\n  the solution for only 2 units to find the new solution?\n</p>\n',
      '\n<p>\n  The maximum profit at n can be modeled as the greater value of\n  <span>prices[n]</span> and <span>profit[size - m] + size[m]</span> for\n  every value m.\n</p>',
    ],
    customInputVars: [
      {
        name: 'prices',
        example: [0, 1],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function juiceBottling(prices) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.juiceBottling = juiceBottling;\n',
      solutions: [
        '// O(n^3) time | O(n^2) space - where n is the length of prices\nfunction juiceBottling(prices) {\n  const numSizes = prices.length;\n  const maxProfit = new Array(numSizes).fill(0);\n  const solutions = new Array(numSizes).fill(undefined).map(_ => []);\n\n  for (let size = 0; size < numSizes; size++) {\n    for (let dividingPoint = 0; dividingPoint < size + 1; dividingPoint++) {\n      const possibleProfit = maxProfit[size - dividingPoint] + prices[dividingPoint];\n\n      if (possibleProfit > maxProfit[size]) {\n        maxProfit[size] = possibleProfit;\n        solutions[size] = [dividingPoint].concat(solutions[size - dividingPoint]);\n      }\n    }\n  }\n\n  return solutions[numSizes - 1];\n}\n\n// Do not edit the line below.\nexports.juiceBottling = juiceBottling;\n',
        '// O(n^2) time | O(n) space - where n is the length of prices\nfunction juiceBottling(prices) {\n  const numSizes = prices.length;\n  const maxProfit = new Array(numSizes).fill(0);\n  const dividingPoints = new Array(numSizes).fill(0);\n\n  for (let size = 0; size < numSizes; size++) {\n    for (let dividingPoint = 0; dividingPoint < size + 1; dividingPoint++) {\n      const possibleProfit = maxProfit[size - dividingPoint] + prices[dividingPoint];\n\n      if (possibleProfit > maxProfit[size]) {\n        maxProfit[size] = possibleProfit;\n        dividingPoints[size] = dividingPoint;\n      }\n    }\n  }\n\n  const solution = [];\n  let currentDividingPoint = numSizes - 1;\n  while (currentDividingPoint > 0) {\n    solution.push(dividingPoints[currentDividingPoint]);\n    currentDividingPoint -= dividingPoints[currentDividingPoint];\n  }\n\n  return solution;\n}\n\n// Do not edit the line below.\nexports.juiceBottling = juiceBottling;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [0, 2, 5, 6];\n  const expected = [1, 2];\n  const actual = program.juiceBottling(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [0, 2, 5, 6];\n  const expected = [1, 2];\n  const actual = program.juiceBottling(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: '(n^2) time | O(n) space - where n is the length of prices',
    tests: [
      { prices: [0, 1] },
      { prices: [0, 1, 3] },
      { prices: [0, 2, 3] },
      { prices: [0, 2, 3, 4] },
      { prices: [0, 2, 5, 6] },
      { prices: [0, 2, 5, 6, 7] },
      { prices: [0, 2, 5, 6, 11] },
      { prices: [0, 2, 5, 10, 11] },
      { prices: [0, 5, 6, 7, 8, 9, 10] },
      { prices: [0, 2, 5, 4, 4] },
      { prices: [0, 1, 3, 2] },
      { prices: [0, 1, 3, 2, 4] },
      { prices: [0, 3, 5, 10, 8, 4, 12, 15, 20, 18, 25] },
      { prices: [0, 1, 3, 7, 5, 4, 12, 15, 20, 18, 25] },
      { prices: [0, 1, 3, 6, 5, 4, 17, 15, 20, 18, 21] },
      { prices: [0, 1, 3, 5, 4, 8, 7, 12, 15, 13, 16] },
      { prices: [0, 1, 3, 5, 4, 10, 7, 12, 15, 13, 16] },
    ],
  },
  {
    id: 'middle-node',
    name: 'Middle Node',
    category: 'Linked Lists',
    complexity: 0,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a Linked List with at least one node. Write a function\n    that returns the middle node of the Linked List. If there are two middle\n    nodes (i.e. an even length list), your function should return the second\n    of these nodes.\n  </p>\n\n  <p>\n    Each <span>LinkedList</span> node has an integer <span>value</span> as well as\n    a <span>next</span> node pointing to the next node in the list or to\n    <span>None</span> / <span>null</span> if it\'s the tail of the list.\n  </p>\n\n  <h3>Sample Input</h3>\n<pre><span class="CodeEditor-promptParameter">linkedList</span> = 2 -> 7 -> 3 -> 5</pre>\n  <h3>Sample Output</h3>\n<pre>3 -> 5 <span class="CodeEditor-promptComment">// The middle could be 7 or 3,\n// we return the second middle node</span></pre>\n</div>',
    hints: [
      '<p>\n  The middle node of a Linked List will always be at index <span>length / 2</span>.\n</p>\n',
      '\n<p>\n  While the LinkedList class has no length, you can calculate it by simply\n  iterating through the entire list.\n</p>\n',
      '\n<p>\n  If you create a slow and a fast pointer, with the fast one iterating at twice\n  the speed, the slow one will be in the middle when the fast one reaches the\n  end.\n</p>',
    ],
    customInputVars: [
      {
        name: 'linkedList',
        example: { head: '1', nodes: [{ id: '1', next: null, value: 1 }] },
        schema: {
          description:
            "A Singly Linked List is represented by a list of <span>nodes</span> and a <span>head</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>next</span> pointers and by the <span>head</span>.\n",
          properties: {
            head: { type: 'string' },
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  next: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'next'],
                type: 'object',
              },
              type: 'array',
            },
          },
          required: ['head', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nexports.LinkedList = LinkedList;\n\nfunction middleNode(linkedList) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the line below.\nexports.middleNode = middleNode;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the linked list\nfunction middleNode(linkedList) {\n  let count = 0;\n  let currentNode = linkedList;\n  while (currentNode !== null) {\n    count++;\n    currentNode = currentNode.next;\n  }\n\n  let middleNode = linkedList;\n  for (let i = 0; i < Math.floor(count / 2); i++) {\n    middleNode = middleNode.next;\n  }\n  return middleNode;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.middleNode = middleNode;\n',
        '// This is an input class. Do not edit.\nclass LinkedList {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\n// O(n) time | O(1) space - where n is the number of nodes in the linked list\nfunction middleNode(linkedList) {\n  let slowNode = linkedList;\n  let fastNode = linkedList;\n  while (fastNode !== null && fastNode.next !== null) {\n    slowNode = slowNode.next;\n    fastNode = fastNode.next.next;\n  }\n\n  return slowNode;\n}\n\n// Do not edit the lines below.\nexports.LinkedList = LinkedList;\nexports.middleNode = middleNode;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const linkedList = new program.LinkedList(0);\n  linkedList.next = new program.LinkedList(1);\n  const expected = new program.LinkedList(2);\n  linkedList.next.next = expected;\n  expected.next = new program.LinkedList(3);\n  const actual = program.middleNode(linkedList);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const linkedList = new program.LinkedList(0);\n  linkedList.next = new program.LinkedList(1);\n  const expected = new program.LinkedList(2);\n  linkedList.next.next = expected;\n  expected.next = new program.LinkedList(3);\n  const actual = program.middleNode(linkedList);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of nodes in the linked list',
    tests: [
      { linkedList: { head: '1', nodes: [{ id: '1', next: null, value: 1 }] } },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: null, value: 3 },
          ],
        },
      },
      {
        linkedList: {
          head: '5',
          nodes: [
            { id: '5', next: '7', value: 5 },
            { id: '7', next: '9', value: 7 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: null, value: 4 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: null, value: 9 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '6', value: 5 },
            { id: '6', next: '7', value: 6 },
            { id: '7', next: '8', value: 7 },
            { id: '8', next: '9', value: 8 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '3', value: 1 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '9', value: 5 },
            { id: '9', next: '10', value: 9 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '1-3', value: 1 },
            { id: '1-3', next: '3', value: 1 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '5-2', value: 5 },
            { id: '5-2', next: '5-3', value: 5 },
            { id: '5-3', next: '5-4', value: 5 },
            { id: '5-4', next: '10', value: 5 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '2', value: 1 },
            { id: '2', next: '1-2', value: 2 },
            { id: '1-2', next: '4', value: 1 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '5-2', value: 5 },
            { id: '5-2', next: '7', value: 5 },
            { id: '7', next: '10', value: 7 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
      {
        linkedList: {
          head: '1',
          nodes: [
            { id: '1', next: '1-2', value: 1 },
            { id: '1-2', next: '1-3', value: 1 },
            { id: '1-3', next: '1-4', value: 1 },
            { id: '1-4', next: '2', value: 1 },
            { id: '2', next: '3', value: 2 },
            { id: '3', next: '4', value: 3 },
            { id: '4', next: '5', value: 4 },
            { id: '5', next: '5-2', value: 5 },
            { id: '5-2', next: '7', value: 5 },
            { id: '7', next: '10', value: 7 },
            { id: '10', next: null, value: 10 },
          ],
        },
      },
    ],
  },
  {
    id: 'missingNumbers',
    name: 'Missing Numbers',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given an unordered list of unique integers <span>nums</span> in the\n    range <span>[1, n]</span>, where <span>n</span> represents the length of\n    <span>nums + 2</span>. This means that two numbers in this range are missing\n    from the list.\n  </p>\n\n  <p>\n    Write a function that takes in this list and returns a new list with the two\n    missing numbers, sorted numerically.\n  </p>\n\n  <h3>Sample Input</h3>\n  <pre><span class="CodeEditor-promptParameter">nums</span> = [1, 4, 3]</pre>\n  <h3>Sample Output</h3>\n  <pre>[2, 5] <span class="CodeEditor-promptComment"> // n is 5, meaning the completed list should be [1, 2, 3, 4, 5]</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  How would you solve this problem if there was only one missing number? Can\n  that solution be applied to this problem with two missing numbers?\n</p>\n',
      '\n<p>\n  To efficiently find a single missing number, you can sum up all of the values\n  in the array as well as sum up all of the values in the expected array (i.e.\n  in the range [1, n]). The difference between these values is the missing\n  number.\n</p>\n',
      '\n<p>\n  Using the same logic as for a single missing number, you can find the total\n  of the two missing numbers. How can you then find which numbers these are?\n</p>\n',
      '\n<p>\n  If you take an average of the two missing numbers, one of the missing numbers\n  must be less than that average, and one must be greater than the average.\n</p>\n',
      '\n<p>\n  Since we know there is one missing number on each side of the average, we can\n  treat each side of the list as its own problem to find one missing number in\n  that list.\n</p>',
    ],
    customInputVars: [
      {
        name: 'nums',
        example: [],
        schema: {
          items: { type: 'integer' },
          minimum: 1,
          type: 'array',
          uniqueItems: true,
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function missingNumbers(nums) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.missingNumbers = missingNumbers;\n',
      solutions: [
        '// O(n) time | O(n) space - where n is the length of the input array\nfunction missingNumbers(nums) {\n  const includedNums = new Set(nums);\n\n  const solution = [];\n  for (let num = 1; num < nums.length + 3; num++) {\n    if (!includedNums.has(num)) {\n      solution.push(num);\n    }\n  }\n\n  return solution;\n}\n\n// Do not edit the line below.\nexports.missingNumbers = missingNumbers;\n',
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction missingNumbers(nums) {\n  let total = sum(arrayFromAToB(1, nums.length + 3));\n\n  for (const num of nums) {\n    total -= num;\n  }\n\n  const averageMissingValue = Math.floor(total / 2);\n  let foundFirstHalf = 0;\n  let foundSecondHalf = 0;\n  for (const num of nums) {\n    if (num <= averageMissingValue) {\n      foundFirstHalf += num;\n    } else {\n      foundSecondHalf += num;\n    }\n  }\n\n  const expectedFirstHalf = sum(arrayFromAToB(1, averageMissingValue + 1));\n  const expectedSecondHalf = sum(arrayFromAToB(averageMissingValue + 1, nums.length + 3));\n\n  return [expectedFirstHalf - foundFirstHalf, expectedSecondHalf - foundSecondHalf];\n}\n\nconst arrayFromAToB = (a, b) => {\n  const array = [];\n  for (let num = a; num < b; num++) {\n    array.push(num);\n  }\n  return array;\n};\n\nconst sum = array => array.reduce((a, b) => a + b);\n\n// Do not edit the line below.\nexports.missingNumbers = missingNumbers;\n',
        '// O(n) time | O(1) space - where n is the length of the input array\nfunction missingNumbers(nums) {\n  let solutionXOR = 0;\n  for (let i = 0; i < nums.length + 3; i++) {\n    solutionXOR ^= i;\n    if (i < nums.length) {\n      solutionXOR ^= nums[i];\n    }\n  }\n\n  const solution = [0, 0];\n  const setBit = solutionXOR & -solutionXOR;\n  for (let i = 0; i < nums.length + 3; i++) {\n    if ((i & setBit) === 0) {\n      solution[0] ^= i;\n    } else {\n      solution[1] ^= i;\n    }\n\n    if (i < nums.length) {\n      if ((nums[i] & setBit) === 0) {\n        solution[0] ^= nums[i];\n      } else {\n        solution[1] ^= nums[i];\n      }\n    }\n  }\n\n  solution.sort((a, b) => a - b);\n  return solution;\n}\n\n// Do not edit the line below.\nexports.missingNumbers = missingNumbers;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [4, 5, 1, 3];\n  const expected = [2, 6];\n  const actual = program.missingNumbers(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [4, 5, 1, 3];\n  const expected = [2, 6];\n  const actual = program.missingNumbers(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the input array',
    tests: [
      { nums: [] },
      { nums: [1] },
      { nums: [2] },
      { nums: [3] },
      { nums: [1, 3] },
      { nums: [3, 1] },
      { nums: [1, 2, 3] },
      { nums: [3, 2, 1] },
      { nums: [3, 1, 2] },
      { nums: [3, 4, 5] },
      { nums: [4, 5, 3] },
      { nums: [1, 3, 4, 5] },
      { nums: [4, 5, 1, 3] },
      { nums: [1, 2, 4, 5, 7] },
      { nums: [1, 2, 7, 5, 4] },
      { nums: [1, 2, 3, 4, 5, 6, 7] },
      { nums: [7, 6, 5, 4, 3, 2, 1] },
      { nums: [3, 5, 1, 2, 4, 7, 6] },
      {
        nums: [
          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 20, 21, 22,
        ],
      },
      {
        nums: [
          3, 5, 7, 8, 1, 10, 11, 2, 4, 13, 17, 22, 18, 21, 16, 20, 6, 9, 15, 12,
        ],
      },
      {
        nums: [
          3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
          22,
        ],
      },
      {
        nums: [
          14, 15, 16, 17, 18, 19, 20, 21, 22, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
          13,
        ],
      },
      {
        nums: [
          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
          21, 22,
        ],
      },
      {
        nums: [
          11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 1, 2, 3, 4, 5, 6, 7,
          8, 9, 10,
        ],
      },
    ],
  },
  {
    id: 'one-edit',
    name: 'One Edit',
    category: 'Strings',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given two strings <span>stringOne</span> and <span>stringTwo</span>.\n    Write a function that determines if these two strings can be made equal\n    using only one edit.\n  </p>\n\n  <p>\n    There are 3 possible edits:\n    <ul>\n      <li>\n        <b>Replace</b>: One character in one string is swapped for a different\n        character.\n      </li>\n      <li>\n        <b>Add</b>: One character is added at any index in one string.\n      </li>\n      <li>\n        <b>Remove</b>: One character is removed at any index in one string.\n      </li>\n    </ul>\n  </p>\n\n  <p>\n    Note that both strings will contain at least one character. If the strings\n    are the same, your function should return true.\n  </p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">stringOne</span> = "hello"\n<span class="CodeEditor-promptParameter">stringTwo</span> = "hollo"\n</pre>\n<h3>Sample Output</h3>\n<pre>\nTrue <span class="CodeEditor-promptComment">// A single replace at index 1 of either string can make the strings equal</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  If the difference in lengths of the strings is greater than 1, then there\n  is no way to make them equal with a single edit.\n</p>\n',
      '\n<p>\n  If the lengths of the strings are the same, then the only possible edit is a\n  replace, because adding or removing a character would make the strings different\n  lengths.\n</p>\n',
      '\n<p>\n  If the strings are different lengths, the only possible moves are adding\n  and removing a character. These are essentially the same operation, because\n  they represent the case where one string has a character that another does\n  not.\n</p>',
    ],
    customInputVars: [
      {
        name: 'stringOne',
        example: 'a',
        schema: { minLength: 1, type: 'string' },
      },
      {
        name: 'stringTwo',
        example: 'a',
        schema: { minLength: 1, type: 'string' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function oneEdit(stringOne, stringTwo) {\n  // Write your code here.\n  return false;\n}\n\n// Do not edit the line below.\nexports.oneEdit = oneEdit;\n',
      solutions: [
        '// O(n + m) time | O(n + m) space - where n is the length of stringOne, and\n// m is the length of stringTwo\nfunction oneEdit(stringOne, stringTwo) {\n  const lengthOne = stringOne.length;\n  const lengthTwo = stringTwo.length;\n  if (Math.abs(lengthOne - lengthTwo) > 1) return false;\n\n  for (let i = 0; i < Math.min(lengthOne, lengthTwo); i++) {\n    if (stringOne[i] !== stringTwo[i]) {\n      if (lengthOne > lengthTwo) {\n        return stringOne.slice(i + 1) === stringTwo.slice(i);\n      } else if (lengthTwo > lengthOne) {\n        return stringOne.slice(i) === stringTwo.slice(i + 1);\n      } else {\n        return stringOne.slice(i + 1) === stringTwo.slice(i + 1);\n      }\n    }\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.oneEdit = oneEdit;\n',
        '// O(n) time | O(1) space - where n is the length of the shorter string\nfunction oneEdit(stringOne, stringTwo) {\n  const lengthOne = stringOne.length;\n  const lengthTwo = stringTwo.length;\n  if (Math.abs(lengthOne - lengthTwo) > 1) return false;\n\n  let madeEdit = false;\n  let indexOne = 0;\n  let indexTwo = 0;\n\n  while (indexOne < lengthOne && indexTwo < lengthTwo) {\n    if (stringOne[indexOne] !== stringTwo[indexTwo]) {\n      if (madeEdit) return false;\n      madeEdit = true;\n\n      if (lengthOne > lengthTwo) {\n        indexOne++;\n      } else if (lengthTwo > lengthOne) {\n        indexTwo++;\n      } else {\n        indexOne++;\n        indexTwo++;\n      }\n    } else {\n      indexOne++;\n      indexTwo++;\n    }\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.oneEdit = oneEdit;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const stringOne = 'hello';\n  const stringTwo = 'helo';\n  const expected = true;\n  const actual = program.oneEdit(stringOne, stringTwo);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const stringOne = 'hello';\n  const stringTwo = 'helo';\n  const expected = true;\n  const actual = program.oneEdit(stringOne, stringTwo);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the length of the shorter string',
    tests: [
      { stringOne: 'a', stringTwo: 'a' },
      { stringOne: 'aaa', stringTwo: 'aaa' },
      { stringOne: 'a', stringTwo: 'b' },
      { stringOne: 'ab', stringTwo: 'b' },
      { stringOne: 'abc', stringTwo: 'b' },
      { stringOne: 'ab', stringTwo: 'a' },
      { stringOne: 'b', stringTwo: 'ab' },
      { stringOne: 'bb', stringTwo: 'a' },
      { stringOne: 'a', stringTwo: 'ab' },
      { stringOne: 'bb', stringTwo: 'ab' },
      { stringOne: 'ab', stringTwo: 'bb' },
      { stringOne: 'hello', stringTwo: 'helo' },
      { stringOne: 'hello', stringTwo: 'heo' },
      { stringOne: 'hello', stringTwo: 'heloo' },
      { stringOne: 'hello', stringTwo: 'heloos' },
      { stringOne: 'hello', stringTwo: 'heloos' },
      { stringOne: 'hello', stringTwo: 'helllo' },
      { stringOne: 'hello', stringTwo: 'helllos' },
      { stringOne: 'hello', stringTwo: 'ello' },
      { stringOne: 'hello', stringTwo: 'llo' },
      { stringOne: 'hello', stringTwo: 'ellos' },
      { stringOne: 'hello', stringTwo: 'elllos' },
      { stringOne: 'helo', stringTwo: 'helle' },
      {
        stringOne: 'abcdefghijklmnopqrstuvwxyz',
        stringTwo: 'abcdefghijklmnopqrstuvwxyz',
      },
      {
        stringOne: 'bcdefghijklmnopqrstuvwxyz',
        stringTwo: 'abcdefghijklmnopqrstuvwxyz',
      },
      {
        stringOne: 'bcdefgijklmnopqrstuvwxyz',
        stringTwo: 'abcdefghijklmnopqrstuvwxyz',
      },
      {
        stringOne: 'bcdefghijklmnopqrstuvwxyz',
        stringTwo: 'acdefghijklmnopqrstuvwxyz',
      },
      {
        stringOne: 'bcdefghijklmnopqrstuvwxyz',
        stringTwo: 'abdefghijklmnopqrstuvwxyz',
      },
      {
        stringOne: 'bcdefghijklmnopqrstuvwxyz',
        stringTwo: 'abcdefghijklmnopqrstuvwxy',
      },
      {
        stringOne: 'bcdefghijklmnopqrstuvwxyz',
        stringTwo: 'abcdefghijklmnopqrstuvwxyza',
      },
      {
        stringOne: 'abcdefghijklmnopqrstuvwxyz',
        stringTwo: 'abcdefghijklnopqrstuvwxyz',
      },
      {
        stringOne: 'abcdefghijklmnopqrstuvwxyz',
        stringTwo: 'abcdefghijklmmnopqrstuvwxyz',
      },
      {
        stringOne: 'abcdefghijklmnopqrstuvwxyz',
        stringTwo: 'abcdefghijklnnopqrstuvwxyz',
      },
    ],
  },
  {
    id: 'reversePolishNotation',
    name: 'Reverse Polish Notation',
    category: 'Stacks',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a list of string <span>tokens</span> representing a mathematical\n    expression using Reverse Polish Notation. Reverse Polish Notation is a\n    notation where operators come after operands, instead of between them. For\n    example <span>2 4 +</span> would evaluate to <span>6</span>.\n  </p>\n\n  <p>\n    Parenthesis are always implicit in Reverse Polish Notation, meaning an\n    expression is evaluated from left to right. All of the operators for this\n    problem take two operands, which will always be the two values immediately\n    preceding the operator. For example, <span>18 4 - 7 /</span> would\n    evaluate to <span>((18 - 4) / 7)</span> or <span>2</span>.\n  </p>\n\n  <p>\n    Write a function that takes this list of <span>tokens</span> and returns\n    the result. Your function should support four operators: <span>+</span>,\n    <span>-</span>, <span>*</span>, and <span>/</span> for addition,\n    subtraction, multiplication, and division respectively.\n  </p>\n\n  <p>\n    Division should always be treated as integer division, rounding towards\n    zero. For example, <span>3 / 2</span> evaluates to <span>1</span> and\n    <span>-3 / 2</span> evaluates to <span>-1</span>. You can assume the\n    input will always be valid Reverse Polish Notation, and it will always\n    result in a valid number. Your code should not edit this input list.\n  </p>\n<h3>Sample Input</h3>\n<pre><span class="CodeEditor-promptParameter">tokens</span> = ["50", "3", "17", "+", "2", "-", "/"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n2 <span class="CodeEditor-promptComment">// (50 / ((3 + 17) - 2)))</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  Operators always operate on the two previous values. Is there a data\n  structure that would assist in finding the two most recent values?\n</p>\n',
      '\n<p>\n  It can be helpful to create a stack that contains all of the previously\n  found or calculated values.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tokens',
        example: ['10'],
        schema: { items: { type: 'string' }, minimum: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function reversePolishNotation(tokens) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.reversePolishNotation = reversePolishNotation;\n',
      solutions: [
        "// O(n) time | O(n) space - where n is the number of tokens\nfunction reversePolishNotation(tokens) {\n  const stack = [];\n\n  for (const token of tokens) {\n    if (token === '+') {\n      stack.push(stack.pop() + stack.pop());\n    } else if (token === '-') {\n      const firstNum = stack.pop();\n      stack.push(stack.pop() - firstNum);\n    } else if (token === '*') {\n      stack.push(stack.pop() * stack.pop());\n    } else if (token === '/') {\n      const firstNum = stack.pop();\n      stack.push(Math.trunc(stack.pop() / firstNum));\n    } else {\n      stack.push(parseInt(token));\n    }\n  }\n\n  return stack.pop();\n}\n\n// Do not edit the line below.\nexports.reversePolishNotation = reversePolishNotation;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['3', '2', '+', '7', '*'];\n  const expected = 35;\n  const actual = program.reversePolishNotation(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = ['3', '2', '+', '7', '*'];\n  const expected = 35;\n  const actual = program.reversePolishNotation(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the number of tokens',
    tests: [
      { tokens: ['10'] },
      { tokens: ['10', '5', '+'] },
      { tokens: ['10', '5', '-'] },
      { tokens: ['10', '5', '/'] },
      { tokens: ['10', '5', '*'] },
      { tokens: ['10', '-5', '*'] },
      { tokens: ['-10', '5', '*'] },
      { tokens: ['-10', '-5', '*'] },
      { tokens: ['10', '-5', '/'] },
      { tokens: ['-10', '5', '/'] },
      { tokens: ['-10', '-5', '/'] },
      { tokens: ['10', '3', '/'] },
      { tokens: ['10', '-3', '/'] },
      { tokens: ['10', '-5', '+'] },
      { tokens: ['-10', '5', '+'] },
      { tokens: ['-10', '-5', '+'] },
      { tokens: ['10', '-5', '-'] },
      { tokens: ['-10', '5', '-'] },
      { tokens: ['-10', '-5', '-'] },
      { tokens: ['3', '2', '+', '7', '*'] },
      { tokens: ['4', '2', '/', '7', '-'] },
      { tokens: ['3', '4', '+', '2', '/', '4', '-'] },
      {
        tokens: [
          '4',
          '-7',
          '2',
          '6',
          '+',
          '10',
          '-',
          '/',
          '*',
          '2',
          '+',
          '3',
          '*',
        ],
      },
      {
        tokens: [
          '4',
          '-7',
          '2',
          '6',
          '+',
          '10',
          '-',
          '/',
          '*',
          '2',
          '+',
          '3',
          '*',
          '0',
          '*',
        ],
      },
      { tokens: ['50', '3', '17', '+', '2', '-', '/'] },
      { tokens: ['0', '3', '17', '+', '2', '-', '/'] },
      {
        tokens: [
          '0',
          '3',
          '17',
          '+',
          '2',
          '-',
          '/',
          '2',
          '-',
          '7',
          '10',
          '+',
          '*',
        ],
      },
    ],
  },
  {
    id: 'union-find',
    name: 'Union Find',
    category: 'Famous Algorithms',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  The union-find data structure is similar to a traditional set data structure\n  in that it contains a collection of unique values. However, these values are\n  spread out amongst a variety of distinct disjoint sets, meaning that no set\n  can have duplicate values, and no two sets can contain the same value.\n</p>\n\n<p>\n  Write a <span>UnionFind</span> class that implements the union-find (also\n  called a disjoint set) data structure. This class should support three methods:\n</p>\n\n<ul>\n  <li>\n    <span>createSet(value)</span>: Adds a given value in a new set containing\n    only that value.\n  </li>\n  <li>\n    <span>union(valueOne, valueTwo)</span>: Takes in two values and determines\n    which sets they are in. If they are in different sets, the sets are combined\n    into a single set. If either value is not in a set or they are in the same\n    set, the function should have no effect.\n  </li>\n  <li>\n    <span>find(value)</span>: Returns the "representative" value of the set for\n    which a value belongs to. This can be any value in the set, but it should\n    always be the same value, regardless of which value in the set\n    <span>find</span> is passed. If the value is not in a set, the function\n    should return <span>null</span> / <span>None</span>. Note that after a set\n    is part of a union, its representative can potentially change.\n  </li>\n</ul>\n<p>\n  You can assume <span>createSet</span> will never be called with the same\n  value twice.\n</p>\n\n<p>\n  If you\'re unfamiliar with Union Find, we recommend watching the Conceptual\n  Overview section of this question\'s video explanation before starting to code.\n</p>\n\n<h3>Sample Usage</h3>\n<pre>\n<span class="CodeEditor-promptParameter">createSet</span>(5): null\n<span class="CodeEditor-promptParameter">createSet</span>(10): null\n<span class="CodeEditor-promptParameter">find</span>(5): 5\n<span class="CodeEditor-promptParameter">find</span>(10): 10\n<span class="CodeEditor-promptParameter">union</span>(5, 10): null\n<span class="CodeEditor-promptParameter">find</span>(5): 5\n<span class="CodeEditor-promptParameter">find</span>(10): 5\n<span class="CodeEditor-promptParameter">createSet</span>(20): null\n<span class="CodeEditor-promptParameter">find</span>(20): 20\n<span class="CodeEditor-promptParameter">union</span>(20, 10): null\n<span class="CodeEditor-promptParameter">find</span>(5): 5\n<span class="CodeEditor-promptParameter">find</span>(10): 5\n<span class="CodeEditor-promptParameter">find</span>(20): 5\n</pre>\n</div>',
    hints: [
      '<p>\n  Disjoint sets traditionally use a tree-like data structure for each set, with\n  the root node being the "representative" node returned by <span>find</span>.\n</p>\n',
      '\n<p>\n  When combining two trees with <span>union</span>, make sure to keep the height\n  of the combined tree as small as possible in order to keep a logarithmic\n  time complexity.\n</p>\n',
      '\n<p>\n  The larger the tree is, the slower the time complexity will be. This can\n  be improved by making all nodes in the trees point directly to the root,\n  keeping a minimal height. A good time to make these updates is while running\n  the <span>find</span> method. This is known as path compression.\n</p>',
    ],
    customInputVars: [
      {
        name: 'classMethodsToCall',
        example: [
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
        ],
        schema: {
          description:
            'These methods will be called on an instantiated UnionFind.\n',
          items: {
            properties: {
              arguments: {
                items: { type: 'integer' },
                maxItems: 2,
                minItems: 0,
                type: 'array',
              },
              method: { enum: ['createSet', 'union', 'find'], type: 'string' },
            },
            required: ['method', 'arguments'],
            type: 'object',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// Do not edit the class below except for\n// the constructor and the createSet, find,\n// and union methods. Feel free to add new\n// properties and methods to the class.\nclass UnionFind {\n  constructor() {\n    // Write your code here.\n  }\n\n  createSet(value) {\n    // Write your code here.\n  }\n\n  find(value) {\n    // Write your code here.\n  }\n\n  union(valueOne, valueTwo) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.UnionFind = UnionFind;\n',
      solutions: [
        'class UnionFind {\n  constructor() {\n    this.parents = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value) {\n    this.parents[value] = value;\n  }\n\n  // O(n) time | O(1) space - where n is the total number of values\n  find(value) {\n    if (!(value in this.parents)) return null;\n\n    let currentParent = value;\n    while (currentParent !== this.parents[currentParent]) {\n      currentParent = this.parents[currentParent];\n    }\n    return currentParent;\n  }\n\n  // O(n) time | O(1) space - where n is the total number of values\n  union(valueOne, valueTwo) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne);\n    const valueTwoRoot = this.find(valueTwo);\n    this.parents[valueTwoRoot] = valueOneRoot;\n  }\n}\n\nexports.UnionFind = UnionFind;\n',
        'class UnionFind {\n  constructor() {\n    this.parents = {};\n    this.ranks = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value) {\n    this.parents[value] = value;\n    this.ranks[value] = 0;\n  }\n\n  // O(log(n)) time | O(1) space - where n is the total number of values\n  find(value) {\n    if (!(value in this.parents)) return null;\n\n    let currentParent = value;\n    while (currentParent !== this.parents[currentParent]) {\n      currentParent = this.parents[currentParent];\n    }\n    return currentParent;\n  }\n\n  // O(log(n)) time | O(1) space - where n is the total number of values\n  union(valueOne, valueTwo) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne);\n    const valueTwoRoot = this.find(valueTwo);\n    if (this.ranks[valueOneRoot] < this.ranks[valueTwoRoot]) {\n      this.parents[valueOneRoot] = valueTwoRoot;\n    } else if (this.ranks[valueOneRoot] > this.ranks[valueTwoRoot]) {\n      this.parents[valueTwoRoot] = valueOneRoot;\n    } else {\n      this.parents[valueTwoRoot] = valueOneRoot;\n      this.ranks[valueOneRoot] += 1;\n    }\n  }\n}\n\nexports.UnionFind = UnionFind;\n',
        'class UnionFind {\n  constructor() {\n    this.parents = {};\n    this.ranks = {};\n  }\n\n  // O(1) time | O(1) space\n  createSet(value) {\n    this.parents[value] = value;\n    this.ranks[value] = 0;\n  }\n\n  // O((n)), approximately O(1) time | O((n)), approximately O(1) space - where n is the total number of values\n  find(value) {\n    if (!(value in this.parents)) return null;\n\n    if (value !== this.parents[value]) {\n      this.parents[value] = this.find(this.parents[value]);\n    }\n\n    return this.parents[value];\n  }\n\n  // O((n)), approximately O(1) time | O((n)), approximately O(1) space - where n is the total number of values\n  union(valueOne, valueTwo) {\n    if (!(valueOne in this.parents) || !(valueTwo in this.parents)) return;\n\n    const valueOneRoot = this.find(valueOne);\n    const valueTwoRoot = this.find(valueTwo);\n    if (this.ranks[valueOneRoot] < this.ranks[valueTwoRoot]) {\n      this.parents[valueOneRoot] = valueTwoRoot;\n    } else if (this.ranks[valueOneRoot] > this.ranks[valueTwoRoot]) {\n      this.parents[valueTwoRoot] = valueOneRoot;\n    } else {\n      this.parents[valueTwoRoot] = valueOneRoot;\n      this.ranks[valueOneRoot] += 1;\n    }\n  }\n}\n\nexports.UnionFind = UnionFind;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const unionFind = new program.UnionFind();\n  chai.expect(unionFind.find(1)).to.deep.equal(null);\n  unionFind.createSet(1);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  unionFind.createSet(5);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  chai.expect(unionFind.find(5)).to.deep.equal(5);\n  unionFind.union(5, 1);\n  chai.expect(unionFind.find(5)).to.deep.equal(unionFind.find(1));\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const unionFind = new program.UnionFind();\n  chai.expect(unionFind.find(1)).to.deep.equal(null);\n  unionFind.createSet(1);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  unionFind.createSet(5);\n  chai.expect(unionFind.find(1)).to.deep.equal(1);\n  chai.expect(unionFind.find(5)).to.deep.equal(5);\n  unionFind.union(5, 1);\n  chai.expect(unionFind.find(5)).to.deep.equal(unionFind.find(1));\n});\n",
    },
    bigO: 'createSet method: O(1) time | O(1) space\nunion and find methods: O((n)), approximately O(1) time | O((n)), approximately O(1) space - where n is the total number of values',
    tests: [
      {
        classMethodsToCall: [
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
          { arguments: [0, 1], method: 'union' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [0], method: 'createSet' },
          { arguments: [0], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [0], method: 'createSet' },
          { arguments: [1], method: 'createSet' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [10], method: 'createSet' },
          { arguments: [5], method: 'createSet' },
          { arguments: [10], method: 'find' },
          { arguments: [5], method: 'find' },
          { arguments: [10, 5], method: 'union' },
          { arguments: [10], method: 'find' },
          { arguments: [5], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [0], method: 'createSet' },
          { arguments: [1], method: 'createSet' },
          { arguments: [2], method: 'createSet' },
          { arguments: [3], method: 'createSet' },
          { arguments: [0, 2], method: 'union' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
          { arguments: [2], method: 'find' },
          { arguments: [3], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [0], method: 'createSet' },
          { arguments: [2], method: 'createSet' },
          { arguments: [0, 2], method: 'union' },
          { arguments: [3], method: 'createSet' },
          { arguments: [1], method: 'createSet' },
          { arguments: [1, 3], method: 'union' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
          { arguments: [2], method: 'find' },
          { arguments: [3], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [0], method: 'createSet' },
          { arguments: [2], method: 'createSet' },
          { arguments: [0, 2], method: 'union' },
          { arguments: [3], method: 'createSet' },
          { arguments: [1], method: 'createSet' },
          { arguments: [1, 3], method: 'union' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
          { arguments: [2], method: 'find' },
          { arguments: [3], method: 'find' },
          { arguments: [3, 0], method: 'union' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
          { arguments: [2], method: 'find' },
          { arguments: [3], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [0], method: 'createSet' },
          { arguments: [1], method: 'createSet' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
          { arguments: [0, 2], method: 'union' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
          { arguments: [0, 1], method: 'union' },
          { arguments: [1, 0], method: 'union' },
          { arguments: [0], method: 'find' },
          { arguments: [1], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [3], method: 'createSet' },
          { arguments: [12], method: 'createSet' },
          { arguments: [5], method: 'find' },
          { arguments: [2], method: 'createSet' },
          { arguments: [1000], method: 'createSet' },
          { arguments: [1000, 2], method: 'union' },
          { arguments: [1000, 5], method: 'union' },
          { arguments: [1, 12], method: 'union' },
          { arguments: [7], method: 'createSet' },
          { arguments: [3, 5], method: 'union' },
          { arguments: [7, 3], method: 'union' },
          { arguments: [1], method: 'find' },
          { arguments: [3], method: 'find' },
          { arguments: [12], method: 'find' },
          { arguments: [5], method: 'find' },
          { arguments: [2], method: 'find' },
          { arguments: [1000], method: 'find' },
          { arguments: [7], method: 'find' },
          { arguments: [3, 12], method: 'union' },
          { arguments: [12], method: 'find' },
        ],
      },
      {
        classMethodsToCall: [
          { arguments: [0], method: 'createSet' },
          { arguments: [2], method: 'createSet' },
          { arguments: [2, 0], method: 'union' },
          { arguments: [3], method: 'createSet' },
          { arguments: [3, 0], method: 'union' },
          { arguments: [0], method: 'find' },
          { arguments: [2], method: 'find' },
        ],
      },
    ],
  },
  {
    id: 'largest-island',
    name: 'Largest Island',
    category: 'Graphs',
    complexity: 2,
    prompt:
      '<div class="html">\n<p>\n  You\'re given a two-dimensional array (a matrix) of potentially unequal height\n  and width containing only <span>0</span>s and <span>1</span>s. Each\n  <span>1</span> represents water, and each <span>0</span> represents part of a\n  land mass. A land mass consists of any number of <span>0</span>s that are either\n  horizontally or vertically adjacent (but not diagonally adjacent). The number\n  of adjacent <span>0</span>s forming a land mass determine its size.\n</p>\n<p>\n  Note that a land mass can twist. In other words, it doesn\'t have to be a straight\n  vertical line or a straight horizontal line; it can be L-shaped, for example.\n</p>\n<p>\n  Write a function that returns the largest possible land mass size after\n  changing exactly one <span>1</span> to a <span>0</span>. Note that the given\n  matrix will always contain at least one <span>1</span>, and you may mutate\n  the matrix.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">matrix</span> = [\n  [0, 1, 1],\n  [0, 0, 1],\n  [1, 1, 0]\n]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n5 <span class="CodeEditor-promptComment">// Switching either matrix[1][2] or matrix[2][1]\n<span class="CodeEditor-promptComment">// creates a land mass of size 5</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  A brute force approach to this problem would be to try changing every\n  <span>1</span> into a <span>0</span>. From there, you can check what the\n  largest land mass size is from the newly changed index.\n</p>\n',
      '\n<p>\n  The brute force approach potentially calculates the size of the same land mass\n  multiple times. Can you try to optimize this?\n</p>\n',
      '\n<p>\n  You can change values in the <span>matrix</span> to help keep track of\n  additional useful information about a given index.\n</p>\n',
      '\n<p>\n  Try first precomputing the sizes of each land mass. Changing any\n  <span>1</span> would then create a new land mass of the combined sizes of\n  all its adjacent land masses plus one to account for the newly changed value.\n</p>\n',
      "\n<p>\n  To avoid double counting land masses, try updating the matrix with unique\n  identifiers for each land mass to know which <span>0</span>'s are from the\n  same land mass.\n</p>",
    ],
    customInputVars: [
      {
        name: 'matrix',
        example: [[1]],
        schema: {
          items: {
            items: { maximum: 1, minimum: 0, type: 'integer' },
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function largestIsland(matrix) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.largestIsland = largestIsland;\n',
      solutions: [
        '// O(w^2 * h^2) time | O(w * h) space - where w is the width of the matrix, and\n// h is the height of the matrix\nfunction largestIsland(matrix) {\n  let maxSize = 0;\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (matrix[row][col] === 0) continue;\n\n      maxSize = Math.max(maxSize, getSizeFromNode(row, col, matrix));\n    }\n  }\n\n  return maxSize;\n}\n\nfunction getSizeFromNode(row, col, matrix) {\n  let size = 1;\n  const visited = matrix.map(row => row.map(_ => false));\n  const nodesToExplore = getLandNeighbors(row, col, matrix);\n  while (nodesToExplore.length > 0) {\n    const currentNode = nodesToExplore.pop();\n    const [currentRow, currentCol] = currentNode;\n\n    if (visited[currentRow][currentCol]) continue;\n\n    visited[currentRow][currentCol] = true;\n    size += 1;\n    nodesToExplore.push(...getLandNeighbors(currentRow, currentCol, matrix));\n  }\n\n  return size;\n}\n\nfunction getLandNeighbors(row, col, matrix) {\n  const landNeighbors = [];\n  if (row > 0 && matrix[row - 1][col] !== 1) {\n    landNeighbors.push([row - 1, col]);\n  }\n  if (row < matrix.length - 1 && matrix[row + 1][col] !== 1) {\n    landNeighbors.push([row + 1, col]);\n  }\n  if (col > 0 && matrix[row][col - 1] !== 1) {\n    landNeighbors.push([row, col - 1]);\n  }\n  if (col < matrix[0].length - 1 && matrix[row][col + 1] !== 1) {\n    landNeighbors.push([row, col + 1]);\n  }\n\n  return landNeighbors;\n}\n\n// Do not edit the line below.\nexports.largestIsland = largestIsland;\n',
        '// O(w * h) time | O(w * h) space - where w is the width of the matrix, and\n// h is the height of the matrix\nfunction largestIsland(matrix) {\n  const islandSizes = [];\n  // islandNumber starts at 2 to avoid overwriting existing 0s and 1s\n  let islandNumber = 2;\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (matrix[row][col] === 0) {\n        islandSizes.push(getSizeFromNode(row, col, matrix, islandNumber));\n        islandNumber += 1;\n      }\n    }\n  }\n\n  let maxSize = 0;\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (matrix[row][col] !== 1) continue;\n\n      const landNeighbors = getLandNeighbors(row, col, matrix);\n      const islands = new Set();\n      for (const neighbor of landNeighbors) {\n        islands.add(matrix[neighbor[0]][neighbor[1]]);\n      }\n\n      let size = 1;\n      for (const island of islands) {\n        size += islandSizes[island - 2];\n      }\n      maxSize = Math.max(maxSize, size);\n    }\n  }\n\n  return maxSize;\n}\n\nfunction getSizeFromNode(row, col, matrix, islandNumber) {\n  let size = 0;\n  const nodesToExplore = [[row, col]];\n  while (nodesToExplore.length > 0) {\n    const currentNode = nodesToExplore.pop();\n    const [currentRow, currentCol] = currentNode;\n\n    if (matrix[currentRow][currentCol] !== 0) continue;\n\n    matrix[currentRow][currentCol] = islandNumber;\n    size += 1;\n    nodesToExplore.push(...getLandNeighbors(currentRow, currentCol, matrix));\n  }\n\n  return size;\n}\n\nfunction getLandNeighbors(row, col, matrix) {\n  const landNeighbors = [];\n  if (row > 0 && matrix[row - 1][col] !== 1) {\n    landNeighbors.push([row - 1, col]);\n  }\n  if (row < matrix.length - 1 && matrix[row + 1][col] !== 1) {\n    landNeighbors.push([row + 1, col]);\n  }\n  if (col > 0 && matrix[row][col - 1] !== 1) {\n    landNeighbors.push([row, col - 1]);\n  }\n  if (col < matrix[0].length - 1 && matrix[row][col + 1] !== 1) {\n    landNeighbors.push([row, col + 1]);\n  }\n\n  return landNeighbors;\n}\n\n// Do not edit the line below.\nexports.largestIsland = largestIsland;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, 1, 1],\n    [0, 0, 1],\n    [1, 1, 0],\n  ];\n  const expected = 5;\n  const actual = program.largestIsland(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [0, 1, 1],\n    [0, 0, 1],\n    [1, 1, 0],\n  ];\n  const expected = 5;\n  const actual = program.largestIsland(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(w * h) time | O(w * h) space - where w is the width of the matrix, and h is the height of the matrix',
    tests: [
      { matrix: [[1]] },
      { matrix: [[1, 1]] },
      { matrix: [[0, 1]] },
      {
        matrix: [
          [0, 0],
          [0, 1],
        ],
      },
      {
        matrix: [
          [1, 1],
          [1, 1],
        ],
      },
      {
        matrix: [
          [0, 1],
          [1, 0],
        ],
      },
      {
        matrix: [
          [0, 1, 0],
          [1, 0, 1],
          [1, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 1, 1],
          [0, 1, 0],
          [0, 1, 0],
        ],
      },
      {
        matrix: [
          [0, 1, 1],
          [1, 1, 0],
          [0, 1, 0],
        ],
      },
      {
        matrix: [
          [0, 1, 0],
          [1, 1, 1],
          [0, 1, 0],
        ],
      },
      {
        matrix: [
          [0, 0, 0],
          [0, 1, 0],
          [0, 0, 0],
        ],
      },
      {
        matrix: [
          [0, 0, 0],
          [0, 0, 0],
          [0, 0, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 1, 0, 0],
          [0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1],
          [0, 1, 1, 0, 0],
        ],
      },
      {
        matrix: [
          [1, 0, 1, 0, 0],
          [1, 1, 1, 1, 0],
          [0, 1, 1, 1, 1],
          [0, 1, 1, 0, 0],
        ],
      },
      {
        matrix: [
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 1, 0, 0, 1, 1, 0, 0, 1],
          [1, 1, 1, 1, 0, 0, 0, 0, 1, 1],
          [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
          [0, 1, 1, 0, 0, 0, 1, 0, 1, 0],
          [1, 1, 1, 0, 0, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 1, 0, 1, 0, 1],
          [1, 0, 1, 0, 0, 0, 0, 1, 1, 1],
        ],
      },
      {
        matrix: [
          [1, 0, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 0, 0, 0, 0, 1, 1],
          [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
          [0, 1, 1, 0, 0, 0, 1, 0, 1, 0],
          [1, 1, 1, 0, 1, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 1, 1, 0, 1, 0, 1],
          [1, 0, 1, 0, 0, 0, 0, 1, 1, 1],
        ],
      },
    ],
  },
  {
    id: 'prims-algorithm',
    name: "Prim's Algorithm",
    category: 'Famous Algorithms',
    complexity: 2,
    prompt:
      "<div class=\"html\">\n  <p>\n    You're given a list of <span>edges</span> representing a connected,\n    weighted, undirected graph with at least one node.\n  </p>\n\n  <p>\n    The given list is what's called an adjacency list, and it represents a graph.\n    The number of vertices in the graph is equal to the length of\n    <span>edges</span>, where each index <span>i</span> in\n    <span>edges</span> contains vertex <span>i</span>'s siblings, in no\n    particular order. Each of these siblings is an array of length two, with\n    the first value denoting the index in the list that this vertex is connected\n    to, and and the second value denoting the weight of the edge. Note that\n    this graph is undirected, meaning that if a vertex appears in the edge list\n    of another vertex, then the inverse will also be true (along with the same\n    weight).\n  </p>\n\n  <p>\n    Write a function implementing Prim's Algorithm to return a new\n    <span>edges</span> array that represents a minimum spanning tree. A\n    minimum spanning tree is a tree containing all of the vertices of the original\n    graph and a subset of the edges. These edges should connect all of the vertices\n    with the minimum total edge weight and without generating any cycles.\n  </p>\n\n  <p>\n    Note that the graph represented by <span>edges</span> won't contain any\n    self-loops (vertices that have an outbound edge to themselves) and will only\n    have positively weighted edges (i.e., no negative distances). The graph will\n    always have at least one node.\n  </p>\n\n  <p>\n    If you're unfamiliar with Prim's algorithm, we recommend watching the\n    Conceptual Overview section of this question's video explanation before\n    starting to code.\n  </p>\n  <h3>Sample Input</h3>\n  <pre><span class=\"CodeEditor-promptParameter\">edges</span> = [\n  [[1, 3], [2, 5]],\n  [[0, 3], [2, 10], [3, 12]],\n  [[0, 5], [1, 10]],\n  [[1, 12]]\n]</pre>\n  <h3>Sample Output</h3>\n  <pre>[\n  [[1, 3], [2, 5]],\n  [[0, 3], [3, 12]],\n  [[0, 5]],\n  [[1, 12]]\n]</pre>\n</div>",
    hints: [
      "<p>\n  Prim's requires keeping track of all of the edges that have been discovered\n  so far, with the ability to quickly retrieve the lowest distance edge. Is\n  there a data structure that can be helpful here? \n</p>\n",
      '\n<p>\n  A good place to start is to implement a Min-Heap to hold all of the edges that\n  have been found so far. This heap should prioritize edges based on their\n  distance.\n</p>\n',
      "\n<p>\n  Prim's can start at any node. Start by choosing any arbitrary node and add all\n  of its edges to the min heap.\n</p>\n",
      '\n<p>\n  Continue iterating through the heap until it is empty, meaning you have visited\n  all of the potential edges in the minimum spanning tree. For each edge, if it\n  connects to a previously unconnected vertex, add it to the output mst.\n  Additionally, add all of the edges connected to this newly discovered vertex\n  to the Min-Heap.\n</p>',
    ],
    customInputVars: [
      {
        name: 'edges',
        example: [[[1, 1]], [[0, 1]]],
        schema: {
          items: {
            items: {
              items: { items: { maxItems: 2, minItems: 2 }, type: 'integer' },
              type: 'array',
            },
            type: 'array',
          },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function primsAlgorithm(edges) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.primsAlgorithm = primsAlgorithm;\n',
      solutions: [
        '// O(e * log(v)) time | O(v + e) space - where e is the number\n// of edges in the input edges and v is the number of vertices\nfunction primsAlgorithm(edges) {\n  const intitialEdgeItems = edges[0].map(edge => [0, edge[0], edge[1]]);\n  const minHeap = new MinHeap(intitialEdgeItems);\n\n  const mst = edges.map(_ => []);\n  while (!minHeap.isEmpty()) {\n    const [vertex, discoveredVertex, distance] = minHeap.remove();\n\n    if (mst[discoveredVertex].length === 0) {\n      mst[vertex].push([discoveredVertex, distance]);\n      mst[discoveredVertex].push([vertex, distance]);\n    }\n\n    for (const [neighbor, neighborDistance] of edges[discoveredVertex]) {\n      if (mst[neighbor].length === 0) {\n        minHeap.insert([discoveredVertex, neighbor, neighborDistance]);\n      }\n    }\n  }\n\n  return mst;\n}\n\nclass MinHeap {\n  constructor(array) {\n    this.heap = this.buildHeap(array);\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  buildHeap(array) {\n    const firstParentIdx = Math.floor((array.length - 2) / 2);\n    for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\n      this.siftDown(currentIdx, array.length - 1, array);\n    }\n    return array;\n  }\n\n  siftDown(currentIdx, endIdx, heap) {\n    let childOneIdx = currentIdx * 2 + 1;\n    while (childOneIdx <= endIdx) {\n      const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1;\n      let idxToSwap;\n      if (childTwoIdx !== -1 && heap[childTwoIdx][2] < heap[childOneIdx][2]) {\n        idxToSwap = childTwoIdx;\n      } else {\n        idxToSwap = childOneIdx;\n      }\n      if (heap[idxToSwap][2] < heap[currentIdx][2]) {\n        this.swap(currentIdx, idxToSwap, heap);\n        currentIdx = idxToSwap;\n        childOneIdx = currentIdx * 2 + 1;\n      } else {\n        return;\n      }\n    }\n  }\n\n  siftUp(currentIdx, heap) {\n    let parentIdx = Math.floor((currentIdx - 1) / 2);\n    while (currentIdx > 0 && heap[currentIdx][2] < heap[parentIdx][2]) {\n      this.swap(currentIdx, parentIdx, heap);\n      currentIdx = parentIdx;\n      parentIdx = Math.floor((currentIdx - 1) / 2);\n    }\n  }\n\n  remove() {\n    this.swap(0, this.heap.length - 1, this.heap);\n    const valueToRemove = this.heap.pop();\n    this.siftDown(0, this.heap.length - 1, this.heap);\n    return valueToRemove;\n  }\n\n  insert(value) {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1, this.heap);\n  }\n\n  swap(i, j, heap) {\n    const temp = heap[j];\n    heap[j] = heap[i];\n    heap[i] = temp;\n  }\n}\n\n// Do not edit the line below.\nexports.primsAlgorithm = primsAlgorithm;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[[1, 1]], [[0, 1]]];\n  const expected = [[[1, 1]], [[0, 1]]];\n  const actual = program.primsAlgorithm(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [[[1, 1]], [[0, 1]]];\n  const expected = [[[1, 1]], [[0, 1]]];\n  const actual = program.primsAlgorithm(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(e * log(v)) time | O(e + v) space - where e is the number of edges in the input edges and v is the number of vertices',
    tests: [
      { edges: [[[1, 1]], [[0, 1]]] },
      {
        edges: [
          [[1, 1]],
          [
            [0, 1],
            [2, 2],
          ],
          [[1, 2]],
        ],
      },
      {
        edges: [
          [
            [1, 3],
            [2, 5],
          ],
          [
            [0, 3],
            [2, 10],
            [3, 12],
          ],
          [
            [0, 5],
            [1, 10],
          ],
          [[1, 12]],
        ],
      },
      {
        edges: [
          [
            [1, 3],
            [2, 5],
          ],
          [
            [0, 3],
            [2, 10],
            [3, 12],
            [4, 1],
          ],
          [
            [0, 5],
            [1, 10],
            [4, 7],
          ],
          [[1, 12]],
          [
            [1, 1],
            [2, 7],
          ],
        ],
      },
      {
        edges: [
          [
            [1, 3],
            [2, 5],
          ],
          [
            [0, 3],
            [2, 10],
            [3, 12],
            [4, 1],
          ],
          [
            [0, 5],
            [1, 10],
            [4, 7],
          ],
          [
            [1, 12],
            [4, 11],
          ],
          [
            [1, 1],
            [2, 7],
            [3, 11],
          ],
        ],
      },
      {
        edges: [
          [[1, 7]],
          [
            [0, 7],
            [2, 6],
            [4, 3],
          ],
          [[1, 6]],
          [[4, 2]],
          [
            [1, 3],
            [3, 2],
          ],
        ],
      },
      {
        edges: [
          [[1, 7]],
          [
            [0, 7],
            [2, 6],
            [4, 3],
          ],
          [
            [1, 6],
            [3, 14],
          ],
          [
            [2, 14],
            [4, 2],
          ],
          [
            [1, 3],
            [3, 2],
          ],
        ],
      },
      {
        edges: [
          [[1, 7]],
          [
            [0, 7],
            [2, 6],
            [3, 20],
            [4, 3],
          ],
          [
            [1, 6],
            [3, 14],
          ],
          [
            [1, 20],
            [2, 14],
            [4, 2],
          ],
          [
            [1, 3],
            [3, 2],
          ],
        ],
      },
      {
        edges: [
          [
            [1, 7],
            [2, 5],
          ],
          [
            [0, 7],
            [2, 6],
            [3, 20],
            [4, 3],
          ],
          [
            [0, 5],
            [1, 6],
            [3, 14],
          ],
          [
            [1, 20],
            [2, 14],
            [4, 2],
          ],
          [
            [1, 3],
            [3, 2],
          ],
        ],
      },
      {
        edges: [
          [
            [1, 3],
            [2, 5],
          ],
          [
            [0, 3],
            [2, 12],
            [3, 20],
            [4, 3],
          ],
          [
            [0, 5],
            [1, 12],
            [3, 14],
            [6, 10],
          ],
          [
            [1, 20],
            [2, 14],
            [4, 2],
          ],
          [
            [1, 3],
            [3, 2],
            [5, 11],
          ],
          [
            [4, 11],
            [6, 2],
          ],
          [
            [2, 10],
            [5, 2],
            [7, 100],
          ],
          [[6, 100]],
        ],
      },
    ],
  },
  {
    id: 'majority-element',
    name: 'Majority Element',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    Write a function that takes in a non-empty, unordered <span>array</span> of\n    positive integers and returns the array\'s majority element without sorting\n    the array and without using more than constant space.\n  </p>\n  <p>\n    An array\'s majority element is an element of the array that appears in over\n    half of its indices. Note that the most common element of an array (the\n    element that appears the most times in the array) isn\'t necessarily the\n    array\'s majority element; for example, the arrays\n    <span>[3, 2, 2, 1]</span> and <span>[3, 4, 2, 2, 1]</span> both have\n    <span>2</span> as their most common element, yet neither of these arrays\n    have a majority element, because neither <span>2</span> nor any other\n    element appears in over half of the respective arrays\' indices.\n  </p>\n  <p>\n    You can assume that the input array will always have a majority element.\n  </p>\n  <h3>Sample Input</h3>\n  <pre><span class="CodeEditor-promptParameter">array</span> = [1, 2, 3, 2, 2, 1, 2]</pre>\n  <h3>Sample Output</h3>\n  <pre>2<span class="CodeEditor-promptComment"> // 2 occurs in 4/7 array indices, making it the majority element</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  If the <span>array</span> were sorted, the middle element would have to be\n  the majority element. However, this does not produce an optimal algorithm.\n  Can you find a solution that does not require sorting?\n</p>\n',
      "\n<p>\n  Try to first guess that the first element in the <span>array</span> is the\n  majority element. From here, iterate through the array, incrementing a counter\n  for each copy of that candidate element that is found, and decrementing the\n  counter for each other element that is found. If the counter ends greater than\n  1, then that element must be the majority element. Can you generalize this\n  idea to work for cases where the majority element isn't the first element?\n</p>\n",
      '\n<p>\n  Instead of iterating all the way to the end of the <span>array</span>, try\n  stopping once the counter hits 0. At this point, the guessed majority element\n  must not be the majority element in the subarray of the <span>array</span>\n  that you have already looked at. Moreover, the actual majority element must\n  still be the majority element in the remaining subarray of the\n  <span>array</span>, since at most half of the values in the first subarray\n  were the majority element (otherwise it would have had a negative count).\n  With this intuition, you can just repeat this process, only using the\n  remaining subarray.\n</p>\n',
      '\n<p>\n  This problem can also be solved using bit manipulation. Consider each of the\n  bits used to store an integer. For each of these bits, if over half of the\n  elements in the <span>array</span> have the bit set, then that bit must be\n  set in the majority element as well. Doing this for each bit can determine\n  which bits are set in the majority element, and thus what the majority\n  element is.\n</p>',
    ],
    customInputVars: [
      {
        name: 'array',
        example: [2],
        schema: { items: { type: 'integer' }, minimum: 1, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function majorityElement(array) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.majorityElement = majorityElement;\n',
      solutions: [
        '// O(n) time | O(1) space - where n is the number of elements in the array\nfunction majorityElement(array) {\n  let count = 0;\n  let answer = null;\n\n  for (const value of array) {\n    if (count === 0) answer = value;\n\n    if (value === answer) {\n      count++;\n    } else {\n      count--;\n    }\n  }\n\n  return answer;\n}\n\n// Do not edit the line below.\nexports.majorityElement = majorityElement;\n',
        '// O(n) time | O(1) space - where n is the number of elements in the array\nfunction majorityElement(array) {\n  let answer = 0;\n\n  for (let currentBit = 0; currentBit < 32; currentBit++) {\n    const currentBitValue = 1 << currentBit;\n    let onesCount = 0;\n\n    for (const num of array) {\n      if ((num & currentBitValue) !== 0) onesCount++;\n    }\n\n    if (onesCount > array.length / 2) answer += currentBitValue;\n  }\n\n  return answer;\n}\n\n// Do not edit the line below.\nexports.majorityElement = majorityElement;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [1, 2, 3, 2, 2, 1, 2];\n  const expected = 2;\n  const actual = program.majorityElement(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [1, 2, 3, 2, 2, 1, 2];\n  const expected = 2;\n  const actual = program.majorityElement(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(1) space - where n is the number of elements in the array',
    tests: [
      { array: [2] },
      { array: [1, 2, 1] },
      { array: [3, 3, 1] },
      { array: [4, 5, 5] },
      { array: [1, 2, 3, 2, 2, 1, 2] },
      { array: [1, 2, 3, 2, 3, 2, 2, 4, 2] },
      { array: [1, 1, 1, 1, 1, 1, 1] },
      { array: [5, 4, 3, 2, 1, 1, 1, 1, 1] },
      { array: [1, 1, 1, 1, 1, 5, 4, 3, 2] },
      { array: [1, 1, 1, 1, 2, 2, 2, 2, 2] },
      { array: [435, 6543, 6543, 435, 535, 6543, 6543, 12, 43, 6543, 6543] },
      { array: [1, 2, 2, 2, 1] },
      { array: [1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1] },
      { array: [1, 2, 3, 2, 2, 4, 2, 2, 5, 2, 1] },
    ],
  },
  {
    id: 'blackjack-probability',
    name: 'Blackjack Probability',
    category: 'Recursion',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    In the game of Blackjack, the dealer must draw cards until the sum of the\n    values of their cards is greater than or equal to a\n    <span>target</span> value minus 4. For example, traditional Blackjack uses a\n    <span>target</span> value of 21, so the dealer must draw cards until their\n    total is greater than or equal to 17, at which point they stop drawing cards\n    (they "stand"). If the dealer draws a card that brings their total above the\n    <span>target</span> (above 21 in traditional Blackjack), they lose (they\n    "bust").\n  </p>\n  <p>\n    Naturally, when a dealer is drawing cards, they can either end up standing\n    or busting, and this is entirely up to the luck of their draw.\n  </p>\n\n  <p>\n    Write a function that takes in a <span>target</span> value as well as a\n    dealer\'s <span>startingHand</span> value and returns the probability that\n    the dealer will bust (go over the <span>target</span> value before\n    standing). The <span>target</span> value will always be a positive integer,\n    and the <span>startingHand</span> value will always be a positive integer\n    that\'s smaller than or equal to the <span>target</span> value.\n  </p>\n\n  <p>\n    For simplicity, you can assume that the dealer has an infinite deck of cards\n    and that each card has a value between 1 and 10 inclusive. The likelihood of\n    drawing a card of any value is always the same, regardless of previous\n    draws.\n  </p>\n\n  <p>\n    Your solution should be rounded to 3 decimal places and to the nearest\n    value. For example, a probability of <span>0.314159</span> would be rounded\n    to <span>0.314</span>, while a probability of <span>0.1337</span> would be\n    rounded to <span>0.134</span>.\n  </p>\n  <h3>Sample Input</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">target</span> = 21\n<span class="CodeEditor-promptParameter">startingHand</span> = 15\n</pre>\n  <h3>Sample Output</h3>\n  <pre>\n0.45 <span class="CodeEditor-promptComment">// Drawing a 2-6 would result in the dealer standing.</span>\n<span class="CodeEditor-promptComment">// Drawing a 7-10 would result in the dealer busting.</span>\n<span class="CodeEditor-promptComment">// Drawing a 1 would result in a 16, meaning the dealer keeps drawing.</span>\n<span class="CodeEditor-promptComment">// Drawing with a 16 results in a 0.5 probability of busting (6-10 all result in busts).</span>\n<span class="CodeEditor-promptComment">// The overall probability of busting is 0.4 + (0.1 * 0.5)</span>\n<span class="CodeEditor-promptComment">// (the probability of busting on the first draw + the probability of busting on the second).</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  Try first thinking about a simple case. Given a <span>target</span> value of\n  21 and a <span>startingHand</span> of 15, how would you calculate the\n  probability of busting? And how would that probability change if the\n  <span>startingHand</span> changes to 14?\n</p>\n',
      '\n<p>\n  The probability of busting from any given <span>startingHand</span> is\n  <span>(0.1 * p(startingHand + 1)) + ... + (0.1 * p(startingHand + 10))</span>.\n</p>\n',
      '\n<p>\n  Given the formula for the probability of busting, there will be a lot of\n  repeated calculations, particularly for large <span>target</span> values\n  with a low <span>startingHand</span>. Can you use memoization to prevent\n  recalculating these values?\n</p>',
    ],
    customInputVars: [
      { name: 'target', example: 21, schema: { minimum: 1, type: 'integer' } },
      {
        name: 'startingHand',
        example: 16,
        schema: { minimum: 1, type: 'integer' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function blackjackProbability(target, startingHand) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.blackjackProbability = blackjackProbability;\n',
      solutions: [
        '// O(t - s) time | O(t - s) space - where t is the target, and s is the\n// starting hand\nfunction blackjackProbability(target, startingHand) {\n  const memo = {};\n  return parseFloat(calculateProbability(startingHand, target, memo).toFixed(3));\n}\n\nfunction calculateProbability(currentHand, target, memo) {\n  if (currentHand in memo) return memo[currentHand];\n  if (currentHand > target) return 1;\n  if (currentHand + 4 >= target) return 0;\n\n  let totalProbability = 0;\n  for (let drawnCard = 1; drawnCard <= 10; drawnCard++) {\n    totalProbability += 0.1 * calculateProbability(currentHand + drawnCard, target, memo);\n  }\n\n  memo[currentHand] = totalProbability;\n  return totalProbability;\n}\n\n// Do not edit the line below.\nexports.blackjackProbability = blackjackProbability;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const target = 21;\n  const startingHand = 15;\n  const expected = 0.45;\n  const actual = program.blackjackProbability(target, startingHand);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const target = 21;\n  const startingHand = 15;\n  const expected = 0.45;\n  const actual = program.blackjackProbability(target, startingHand);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(t - s) time | O(t - s) space - where t is the target, and s is the starting hand',
    tests: [
      { startingHand: 16, target: 21 },
      { startingHand: 21, target: 21 },
      { startingHand: 20, target: 21 },
      { startingHand: 17, target: 21 },
      { startingHand: 15, target: 21 },
      { startingHand: 12, target: 21 },
      { startingHand: 5, target: 21 },
      { startingHand: 1, target: 21 },
      { startingHand: 95, target: 100 },
      { startingHand: 90, target: 100 },
      { startingHand: 20, target: 100 },
      { startingHand: 100, target: 100 },
      { startingHand: 1, target: 10 },
      { startingHand: 3, target: 10 },
      { startingHand: 3, target: 30 },
      { startingHand: 7, target: 30 },
      { startingHand: 15, target: 30 },
      { startingHand: 25, target: 30 },
    ],
  },
  {
    id: 'evaluate-expression-tree',
    name: 'Evaluate Expression Tree',
    category: 'Binary Trees',
    complexity: 0,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a binary expression tree. Write a function to evaluate\n    this tree mathematically and return a single resulting integer.\n  </p>\n\n  <p>\n    All leaf nodes in the tree represent operands, which will always be positive\n    integers. All of the other nodes represent operators. There are 4 operators\n    supported, each of which is represented by a negative integer:\n  </p>\n\n  <ul>\n    <li>\n      <span>-1</span>: Addition operator, adding the left and right subtrees.\n    </li>\n    <li>\n      <span>-2</span>: Subtraction operator, subtracting the right subtree from the left subtree.\n    </li>\n    <li>\n      <span>-3</span>: Division operator, dividing the left subtree by the right subtree.\n      If the result is a decimal, it should be rounded towards zero.\n    </li>\n    <li>\n      <span>-4</span>: Multiplication operator, multiplying the left and right subtrees.\n    </li>\n  </ul>\n\n  <p>\n    You can assume the tree will always be a valid expression tree. Each\n    operator also works as a grouping symbol, meaning the bottom of the tree is\n    always evaluated first, regardless of the operator.\n  </p>\n\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =    -1\n        /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      -2       -3\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\    /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   -4     2  8    3\n  /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n 2     3\n</pre>\n<h3>Sample Output</h3>\n<pre>\n6 <span class="CodeEditor-promptComment">// (((2 * 3) - 2) + (8 / 3))\n</span>\n</pre>',
    hints: [
      '<p>\n  This problem will be easiest to solve using recursion. Can you think of what\n  the recursive subproblems would be? And what is the base case?\n</p>\n',
      '\n<p>\n  For each operator, a recursive call can be made on its left and right values.\n  The result of these recursive calls can then be combined using that operator.\n  The base case to finish recursing will be when we reach an operand, which is\n  any positive integer.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction evaluateExpressionTree(tree) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.evaluateExpressionTree = evaluateExpressionTree;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the Binary Tree,\n// and h is the height of the Binary Tree\nfunction evaluateExpressionTree(tree) {\n  if (tree.value >= 0) return tree.value;\n\n  const leftValue = evaluateExpressionTree(tree.left);\n  const rightValue = evaluateExpressionTree(tree.right);\n\n  if (tree.value === -1) return leftValue + rightValue;\n  if (tree.value === -2) return leftValue - rightValue;\n  if (tree.value === -3) return Math.trunc(leftValue / rightValue);\n\n  return leftValue * rightValue;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.evaluateExpressionTree = evaluateExpressionTree;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new program.BinaryTree(-1);\n  tree.left = new program.BinaryTree(2);\n  tree.right = new program.BinaryTree(-2);\n  tree.right.left = new program.BinaryTree(5);\n  tree.right.right = new program.BinaryTree(1);\n  const expected = 6;\n  const actual = program.evaluateExpressionTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new program.BinaryTree(-1);\n  tree.left = new program.BinaryTree(2);\n  tree.right = new program.BinaryTree(-2);\n  tree.right.left = new program.BinaryTree(5);\n  tree.right.right = new program.BinaryTree(1);\n  const expected = 6;\n  const actual = program.evaluateExpressionTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(h) space - where n is the number of nodes in the Binary Tree, and h is the height of the Binary Tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -2 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '2', value: -2 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -3 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '2', value: -3 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -4 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: '4', right: '5', value: -2 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '10', right: '3', value: -3 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '3', left: '4', right: '6', value: -2 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '9', right: '3', value: -3 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '3', left: '4', right: '6', value: -2 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '9', right: '3', value: -3 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '3', left: '6', right: '4', value: -2 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -2 },
            { id: '2', left: '4', right: '5', value: -1 },
            { id: '3', left: '6', right: '7', value: -3 },
            { id: '4', left: null, right: null, value: 7 },
            { id: '5', left: null, right: null, value: 10 },
            { id: '6', left: null, right: null, value: 12 },
            { id: '7', left: '8', right: '9', value: -4 },
            { id: '8', left: null, right: null, value: 1 },
            { id: '9', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -1 },
            { id: '2', left: '4', right: '5', value: -2 },
            { id: '3', left: '6', right: '7', value: -4 },
            { id: '4', left: null, right: null, value: 7 },
            { id: '5', left: null, right: null, value: 10 },
            { id: '6', left: null, right: null, value: 12 },
            { id: '7', left: '8', right: '9', value: -3 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -1 },
            { id: '2', left: '4', right: '5', value: -1 },
            { id: '3', left: '6', right: '7', value: -1 },
            { id: '4', left: null, right: null, value: 7 },
            { id: '5', left: null, right: null, value: 10 },
            { id: '6', left: null, right: null, value: 12 },
            { id: '7', left: '8', right: '9', value: -1 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -2 },
            { id: '2', left: '4', right: '5', value: -2 },
            { id: '3', left: '6', right: '7', value: -2 },
            { id: '4', left: null, right: null, value: 7 },
            { id: '5', left: null, right: null, value: 10 },
            { id: '6', left: null, right: null, value: 12 },
            { id: '7', left: '8', right: '9', value: -2 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -3 },
            { id: '2', left: '4', right: '5', value: -3 },
            { id: '3', left: '6', right: '7', value: -3 },
            { id: '4', left: null, right: null, value: 100 },
            { id: '5', left: null, right: null, value: 10 },
            { id: '6', left: null, right: null, value: 4 },
            { id: '7', left: '8', right: '9', value: -3 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: -4 },
            { id: '2', left: '4', right: '5', value: -4 },
            { id: '3', left: '6', right: '7', value: -4 },
            { id: '4', left: null, right: null, value: 2 },
            { id: '5', left: null, right: null, value: 1 },
            { id: '6', left: null, right: null, value: 7 },
            { id: '7', left: '8', right: '9', value: -4 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '9', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '9', value: -4 },
            { id: '2', left: '4', right: '3', value: -1 },
            { id: '3', left: null, right: null, value: 8 },
            { id: '4', left: '5', right: '6', value: -1 },
            { id: '5', left: null, right: null, value: 7 },
            { id: '6', left: '7', right: '8', value: -2 },
            { id: '7', left: null, right: null, value: 22 },
            { id: '8', left: null, right: null, value: 5 },
            { id: '9', left: '10', right: '11', value: -3 },
            { id: '10', left: null, right: null, value: 100 },
            { id: '11', left: '12', right: '13', value: -2 },
            { id: '12', left: null, right: null, value: 42 },
            { id: '13', left: '14', right: '15', value: -3 },
            { id: '14', left: '16', right: '17', value: -4 },
            { id: '15', left: null, right: null, value: 2 },
            { id: '16', left: null, right: null, value: 3 },
            { id: '17', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'split-binary-tree',
    name: 'Split Binary Tree',
    category: 'Binary Trees',
    complexity: 1,
    prompt:
      '<div class="html">\n<p>\n  Write a function that takes in a Binary Tree with at least one node and\n  checks if that Binary Tree can be split into two Binary Trees of equal sum by\n  removing a single edge. If this split is possible, return the new sum of each\n  Binary Tree, otherwise return 0. Note that you do not need to return the edge\n  that was removed.\n</p>\n<p>\n  The sum of a Binary Tree is the sum of all values in that Binary Tree.\n</p>\n<p>\n  Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n  <span>left</span> child node, and a <span>right</span> child node. Children\n  nodes can either be <span>BinaryTree</span> nodes themselves or\n  <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">tree</span> =     1\n        /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       3       -2\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\    /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    6    -5  5    2\n  /\n 2\n</pre>\n<h3>Sample Output</h3>\n<pre>\n6 <span class="CodeEditor-promptComment">// Remove the edge to the left of the root node,\n// creating two trees, each with sums of 6</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  Try first calculating the sum of the entire Binary Tree. What information does\n  this give you towards solving the problem?\n</p>\n',
      '\n<p>\n  If the sum of the entire Binary Tree is odd, then there is no possible\n  solution, because the values are all integers. Otherwise, the solution could\n  be that sum divided by two, or potentially there is still no solution. What\n  does the scenario look like where the solution is the sum divided by two?\n</p>\n',
      '\n<p>\n  There is a solution if there is a subtree that has a sum equal to the the\n  total Binary Tree sum divided by two. In this case, removing the incoming\n  edge to that node would have to create another Binary Tree of equal sum.\n</p>\n',
      '\n<p>\n  To prevent recalculating the same subtree sums, try using a post-order\n  traversal of the Binary Tree. This allows you to calculate the sums of the\n  smallest subtrees first, then send that information back up to the parents to\n  quickly calculate their sums.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [{ id: '0', left: null, right: null, value: 0 }],
          root: '0',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.BinaryTree = BinaryTree;\n\nfunction splitBinaryTree(tree) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.splitBinaryTree = splitBinaryTree;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the tree and\n// h is the height of the tree\nfunction splitBinaryTree(tree) {\n  const desiredSubtreeSum = getTreeSum(tree) / 2;\n  const canBeSplit = trySubtrees(tree, desiredSubtreeSum)[1];\n  return canBeSplit ? desiredSubtreeSum : 0;\n}\n\nfunction trySubtrees(tree, desiredSubtreeSum) {\n  if (tree === null) return [0, false];\n\n  const [leftSum, leftCanBeSplit] = trySubtrees(tree.left, desiredSubtreeSum);\n  const [rightSum, rightCanBeSplit] = trySubtrees(tree.right, desiredSubtreeSum);\n\n  const currentTreeSum = tree.value + leftSum + rightSum;\n  const canBeSplit = leftCanBeSplit || rightCanBeSplit || currentTreeSum === desiredSubtreeSum;\n  return [currentTreeSum, canBeSplit];\n}\n\nfunction getTreeSum(tree) {\n  if (tree === null) return 0;\n  return tree.value + getTreeSum(tree.left) + getTreeSum(tree.right);\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.splitBinaryTree = splitBinaryTree;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new program.BinaryTree(2);\n  tree.left = new program.BinaryTree(4);\n  tree.left.left = new program.BinaryTree(4);\n  tree.left.right = new program.BinaryTree(6);\n  tree.right = new program.BinaryTree(10);\n  tree.right.left = new program.BinaryTree(3);\n  tree.right.right = new program.BinaryTree(3);\n  const expected = 16;\n  const actual = program.splitBinaryTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new program.BinaryTree(2);\n  tree.left = new program.BinaryTree(4);\n  tree.left.left = new program.BinaryTree(4);\n  tree.left.right = new program.BinaryTree(6);\n  tree.right = new program.BinaryTree(10);\n  tree.right.left = new program.BinaryTree(3);\n  tree.right.right = new program.BinaryTree(3);\n  const expected = 16;\n  const actual = program.splitBinaryTree(tree);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(h) space - where n is the number of nodes in the tree and h is the height of the tree',
    tests: [
      {
        tree: {
          nodes: [{ id: '0', left: null, right: null, value: 0 }],
          root: '0',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [{ id: '2', left: null, right: null, value: 2 }],
          root: '2',
        },
      },
      {
        tree: {
          nodes: [{ id: '-2', left: null, right: null, value: -2 }],
          root: '-2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '2', left: null, right: '2-2', value: 2 },
            { id: '2-2', left: null, right: null, value: 2 },
          ],
          root: '2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '1-2', value: 1 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '4', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '4', left: null, right: null, value: 4 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '1-2', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '1-2', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '1-2', left: null, right: '2-2', value: 1 },
            { id: '2-2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '6', right: '3', value: 1 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '3', left: null, right: '2', value: 3 },
            { id: '2', left: null, right: null, value: 2 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '6', right: '3', value: 1 },
            { id: '6', left: '6-2', right: null, value: 6 },
            { id: '3', left: null, right: '10', value: 3 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '6-2', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '6', right: '3', value: 1 },
            { id: '6', left: '6-2', right: null, value: 6 },
            { id: '3', left: null, right: '8', value: 3 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '6-2', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '6', right: '3', value: 1 },
            { id: '6', left: '6-2', right: null, value: 6 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '6-2', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '2', right: '3', value: 1 },
            { id: '2', left: '4', right: '5', value: 2 },
            { id: '3', left: null, right: '7', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '9', right: '2', value: 1 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '2', left: '15', right: '10', value: 2 },
            { id: '15', left: null, right: null, value: 15 },
            { id: '10', left: '100', right: '200', value: 10 },
            { id: '100', left: null, right: null, value: 100 },
            { id: '200', left: null, right: null, value: 200 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '9', right: '20', value: 1 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '20', left: '30', right: '10', value: 20 },
            { id: '30', left: null, right: null, value: 30 },
            { id: '10', left: '35', right: '15', value: 10 },
            { id: '35', left: null, right: null, value: 35 },
            { id: '15', left: null, right: null, value: 15 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '9', right: '20', value: 1 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '20', left: '30', right: '10', value: 20 },
            { id: '30', left: null, right: null, value: 30 },
            { id: '10', left: '35', right: '25', value: 10 },
            { id: '35', left: null, right: null, value: 35 },
            { id: '25', left: null, right: null, value: 25 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '9', right: '20', value: 1 },
            { id: '9', left: '5', right: '2', value: 9 },
            { id: '20', left: '30', right: '10', value: 20 },
            { id: '30', left: null, right: null, value: 30 },
            { id: '10', left: '35', right: '25', value: 10 },
            { id: '35', left: null, right: null, value: 35 },
            { id: '25', left: null, right: null, value: 25 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '9', right: '20', value: 1 },
            { id: '9', left: '5', right: '2', value: 9 },
            { id: '20', left: '30', right: '10', value: 20 },
            { id: '30', left: null, right: null, value: 30 },
            { id: '10', left: '35', right: '25', value: 10 },
            { id: '35', left: '3', right: null, value: 35 },
            { id: '25', left: null, right: null, value: 25 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '9', right: '20', value: 1 },
            { id: '9', left: '5', right: '2', value: 9 },
            { id: '20', left: '30', right: '10', value: 20 },
            { id: '30', left: null, right: null, value: 30 },
            { id: '10', left: '35', right: '25', value: 10 },
            { id: '35', left: null, right: null, value: 35 },
            { id: '25', left: null, right: null, value: 25 },
            { id: '5', left: '102', right: null, value: 5 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '102', left: null, right: null, value: 102 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '20', right: '9', value: 1 },
            { id: '9', left: '5', right: '2', value: 9 },
            { id: '20', left: '30', right: '10', value: 20 },
            { id: '30', left: null, right: null, value: 30 },
            { id: '10', left: '35', right: '25', value: 10 },
            { id: '35', left: null, right: null, value: 35 },
            { id: '25', left: null, right: null, value: 25 },
            { id: '5', left: '102', right: null, value: 5 },
            { id: '2', left: '3', right: null, value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '102', left: null, right: null, value: 102 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '4', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: '6', value: 5 },
            { id: '6', left: null, right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '4', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: '6', value: 5 },
            { id: '6', left: null, right: '9', value: 6 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-2', left: null, right: '-2-2', value: -2 },
            { id: '-2-2', left: null, right: null, value: -2 },
          ],
          root: '-2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-2', left: null, right: '0', value: -2 },
            { id: '0', left: null, right: null, value: 0 },
          ],
          root: '-2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '1-1', right: '2', value: 1 },
            { id: '2', left: null, right: '-5', value: 2 },
            { id: '1-1', left: '12', right: null, value: 1 },
            { id: '12', left: null, right: '-21', value: 12 },
            { id: '-21', left: null, right: null, value: -21 },
            { id: '-5', left: null, right: null, value: -5 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: null, right: '-4', value: 3 },
            { id: '-4', left: null, right: '5', value: -4 },
            { id: '5', left: null, right: '6', value: 5 },
            { id: '6', left: null, right: '9', value: 6 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: null, right: '-4', value: 3 },
            { id: '-4', left: null, right: '9', value: -4 },
            { id: '9', left: null, right: '5', value: 9 },
            { id: '5', left: null, right: '6', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-20', right: '9', value: 1 },
            { id: '9', left: '-13', right: '4', value: 9 },
            { id: '-20', left: '-30', right: '17', value: -20 },
            { id: '-30', left: '8', right: null, value: -30 },
            { id: '17', left: '-26', right: '-17', value: 17 },
            { id: '-26', left: '19', right: null, value: -26 },
            { id: '-17', left: null, right: null, value: -17 },
            { id: '-13', left: '42', right: null, value: -13 },
            { id: '4', left: '3', right: '-11', value: 4 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '42', left: null, right: null, value: 42 },
            { id: '19', left: null, right: null, value: 19 },
            { id: '8', left: null, right: null, value: 8 },
            { id: '-11', left: null, right: null, value: -11 },
          ],
          root: '1',
        },
      },
    ],
  },
  {
    id: 'colliding-asteroids',
    name: 'Colliding Asteroids',
    category: 'Stacks',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given an array of integers <span>asteroids</span>,\n    where each integer represents the size of an asteroid.\n    The sign of the integer represents the direction the asteroid \n    is moving (positive = right, negative = left). All asteroids\n    move at the same speed, meaning that two asteroids moving in the same direction can never collide.\n  </p>\n  <p>\n    For example, the integer <span>4</span> represents an asteroid\n    of size 4 moving to the right. Similarly, <span>-7</span> represents\n    an asteroid of size 7 moving to the left.\n  </p>\n  <p>\n    If two asteroids collide, the smaller asteroid (based on absolute value) explodes.\n    If two colliding asteroids are the same size, they both explode.\n  </p>\n  <p>\n    Write a function that takes in this array of asteroids and returns\n    an array of integers representing the asteroids after all collisions occur.\n  </p>\n\n<h3>Sample Input</h3>\n<pre><span class="CodeEditor-promptParameter">asteroids</span> = [-3, 5, -8, 6, 7, -4, -7]\n</pre>\n<h3>Sample Output</h3>\n<pre>[-3, -8, 6] <span class="CodeEditor-promptComment">// The -3 moves left, having no collisions.\n// The 5 moves right, colliding with the -8 and being destroyed by it.\n// The 6 never collides with another asteroid.\n// The 7 first collides with the -4, destroying it.\n// The 7 and the -7 then collide, both being destroyed.\n</span>\n</pre>',
    hints: [
      '<p>\n  Try approaching this problem one step at a time. What happens if there\n  is only 1 asteroid? Then what possible scenarios can occur if a second\n  asteroid is added after it?\n</p>\n',
      '\n<p>\n  Two asteroids of the same direction will never collide, since all\n  asteroids have the same speed.\n</p>\n',
      '\n<p>\n  A stack will be a useful data structure for solving this problem. With\n  each added asteroid, pop asteroids off of the top of the stack until\n  the new asteroid is no longer colliding with other asteroids before it.\n</p>',
    ],
    customInputVars: [
      {
        name: 'asteroids',
        example: [5],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function collidingAsteroids(asteroids) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.collidingAsteroids = collidingAsteroids;\n',
      solutions: [
        '// O(n) time | O(n) space - where n is the number of asteroids\nfunction collidingAsteroids(asteroids) {\n  const resultStack = [];\n  for (const asteroid of asteroids) {\n    if (asteroid > 0) {\n      resultStack.push(asteroid);\n      continue;\n    }\n\n    while (true) {\n      const lastStackIdx = resultStack.length - 1;\n      if (resultStack.length === 0 || resultStack[lastStackIdx] < 0) {\n        resultStack.push(asteroid);\n        break;\n      }\n\n      const asteroidSize = Math.abs(asteroid);\n      if (resultStack[lastStackIdx] > asteroidSize) {\n        break;\n      }\n\n      if (resultStack[lastStackIdx] === asteroidSize) {\n        resultStack.pop();\n        break;\n      }\n\n      resultStack.pop();\n    }\n  }\n\n  return resultStack;\n}\n\n// Do not edit the line below.\nexports.collidingAsteroids = collidingAsteroids;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [-3, 5, -8, 6, 7, -4, -7];\n  const expected = [-3, -8, 6];\n  const actual = program.collidingAsteroids(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [-3, 5, -8, 6, 7, -4, -7];\n  const expected = [-3, -8, 6];\n  const actual = program.collidingAsteroids(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(n) space - where n is the number of asteroids',
    tests: [
      { asteroids: [5] },
      { asteroids: [-5] },
      { asteroids: [5, -5] },
      { asteroids: [-5, 5] },
      { asteroids: [-5, -5] },
      { asteroids: [5, 5] },
      { asteroids: [1, 2, 3, 4, 5] },
      { asteroids: [34, 2, 5, 42, 100, 20] },
      { asteroids: [-6, -2, -10, -100, -30] },
      { asteroids: [1, 2, 3, -4] },
      { asteroids: [4, -1, -2, -3] },
      { asteroids: [-3, 7, -8, 6, 7, -5, -7] },
      { asteroids: [4, -5, -5, -5] },
      { asteroids: [6, -5, -5, -5] },
      { asteroids: [4, 7, -3, -5, 6, -10, 100, -50, 99] },
      { asteroids: [-70, 100, 23, 42, -50, -75, 1, -2, -3] },
      { asteroids: [-70, 10, 23, 42, -50, -75, 1, -2, -3] },
      { asteroids: [42, 30, 12, 65, -50, 32, -15, -25] },
      {
        asteroids: [
          5123, -34, 654, -3636, 2432, 4242, 1267, 1337, -43, -864, 38, 38, 1,
          -400,
        ],
      },
      {
        asteroids: [
          651, 13, -1246, 754, 1252, -300, 5468, -5200, 22, 17, -100, 87, 100,
          -250, 1,
        ],
      },
    ],
  },
  {
    id: 'median-of-two-sorted-arrays',
    name: 'Median Of Two Sorted Arrays',
    category: 'Searching',
    complexity: 3,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given two sorted arrays of integers <span>arrayOne</span> and\n    <span>arrayTwo</span>. Write a function that returns the median of these\n    arrays.\n  </p>\n\n  <p>\n    You can assume both arrays have at least one value. However, they could\n    be of different lengths. If the median is a decimal value, it should not\n    be rounded (beyond the inevitable rounding of floating point math).\n  </p>\n<h3>Sample Input</h3>\n<pre>\n<span class="CodeEditor-promptParameter">arrayOne</span> = [1, 3, 4, 5]\n<span class="CodeEditor-promptParameter">arrayTwo</span> = [2, 3, 6, 7]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n3.5 <span class="CodeEditor-promptComment">// The combined array is [1, 2, 3, 3, 4, 5, 6, 7]</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  The median value of the combined array will always have the\n  same number of integers to its left and its right. Therefore\n  the goal is to find the element at the middle index (or the\n  average of the middle indices if the array has an even length).\n</p>\n',
      '\n<p>\n  A naive approach would be to iterate through both arrays\n  simultaneously, with each iteration moving forward in the\n  array with the lower current value until passing half of\n  the total values. This solution would have a linear\n  time complexity, but can you find a way to improve it\n  to be logarithmic?\n</p>\n',
      '\n<p>\n  Try considering just the smaller of the two arrays.\n  Start with the median of that array, and temporarily\n  assume that all of the values to its left of that median\n  are to the left of the overall median, and all of the\n  values to the right are to the right of the overall\n  median. Assuming this is correct, could you also place\n  a dividing point in the larger array, to ensure there\n  are the correct number of values on either side of the\n  combined median? And now can you find a way to do a\n  binary search with just the smaller array to find the\n  actual correct dividing point?\n</p>\n',
      '\n<p>\n  The value at the dividing point in <span>arrayOne</span>\n  must be smaller than the value at the index after the\n  dividing point of <span>arrayTwo</span>. The value at\n  the dividing point in <span>arrayTwo</span> must be\n  smaller than the value at the index after the dividing\n  point of <span>arrayOne</span>. If either of these\n  conditions are not met, then the binary search must\n  continue to either include more or less elements from\n  that smaller array.\n</p>',
    ],
    customInputVars: [
      {
        name: 'arrayOne',
        example: [1],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      {
        name: 'arrayTwo',
        example: [2],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function medianOfTwoSortedArrays(arrayOne, arrayTwo) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.medianOfTwoSortedArrays = medianOfTwoSortedArrays;\n',
      solutions: [
        '// O(n + m) time | O(1) space - where n is the length of arrayOne and\n// m is the length of arrayTwo\nfunction medianOfTwoSortedArrays(arrayOne, arrayTwo) {\n  let idxOne = 0,\n    idxTwo = 0;\n  const middleIdx = Math.floor((arrayOne.length + arrayTwo.length - 1) / 2);\n\n  while (idxOne + idxTwo < middleIdx) {\n    if (idxOne >= arrayOne.length) {\n      idxTwo += 1;\n    } else if (idxTwo >= arrayTwo.length) {\n      idxOne += 1;\n    } else if (arrayOne[idxOne] < arrayTwo[idxTwo]) {\n      idxOne += 1;\n    } else {\n      idxTwo += 1;\n    }\n  }\n\n  if ((arrayOne.length + arrayTwo.length) % 2 === 0) {\n    const areBothValuesArrayOne =\n      idxTwo >= arrayTwo.length ||\n      (idxOne + 1 < arrayOne.length && arrayTwo[idxTwo] > arrayOne[idxOne + 1]);\n    const areBothValuesArrayTwo =\n      idxOne >= arrayOne.length ||\n      (idxTwo + 1 < arrayTwo.length && arrayOne[idxOne] > arrayTwo[idxTwo + 1]);\n\n    const valueOne = areBothValuesArrayOne ? arrayOne[idxOne + 1] : arrayTwo[idxTwo];\n    const valueTwo = areBothValuesArrayTwo ? arrayTwo[idxTwo + 1] : arrayOne[idxOne];\n    return (valueOne + valueTwo) / 2;\n  }\n\n  const valueOne = idxOne < arrayOne.length ? arrayOne[idxOne] : Infinity;\n  const valueTwo = idxTwo < arrayTwo.length ? arrayTwo[idxTwo] : Infinity;\n  return Math.min(valueOne, valueTwo);\n}\n\n// Do not edit the line below.\nexports.medianOfTwoSortedArrays = medianOfTwoSortedArrays;\n',
        '// O(log(min(n, m)) time | O(1) space - where n is the length of arrayOne and\n// m is the length of arrayTwo\nfunction medianOfTwoSortedArrays(arrayOne, arrayTwo) {\n  const smallArray = arrayOne.length <= arrayTwo.length ? arrayOne : arrayTwo;\n  const bigArray = arrayOne.length > arrayTwo.length ? arrayOne : arrayTwo;\n\n  let leftIdx = 0;\n  let rightIdx = smallArray.length - 1;\n  let mergedLeftIdx = Math.floor((smallArray.length + bigArray.length - 1) / 2);\n\n  while (true) {\n    const smallPartitionIdx = Math.floor((leftIdx + rightIdx) / 2);\n    const bigPartitionIdx = mergedLeftIdx - smallPartitionIdx - 1;\n\n    const smallMaxLeftValue = smallPartitionIdx >= 0 ? smallArray[smallPartitionIdx] : -Infinity;\n    const smallMinRightValue =\n      smallPartitionIdx + 1 < smallArray.length ? smallArray[smallPartitionIdx + 1] : Infinity;\n    const bigMaxLeftValue = bigPartitionIdx >= 0 ? bigArray[bigPartitionIdx] : -Infinity;\n    const bigMinRightValue =\n      bigPartitionIdx + 1 < bigArray.length ? bigArray[bigPartitionIdx + 1] : Infinity;\n\n    if (smallMaxLeftValue > bigMinRightValue) {\n      rightIdx = smallPartitionIdx - 1;\n    } else if (bigMaxLeftValue > smallMinRightValue) {\n      leftIdx = smallPartitionIdx + 1;\n    } else {\n      if ((smallArray.length + bigArray.length) % 2 === 0) {\n        return (\n          (Math.max(smallMaxLeftValue, bigMaxLeftValue) +\n            Math.min(smallMinRightValue, bigMinRightValue)) /\n          2\n        );\n      }\n      return Math.max(smallMaxLeftValue, bigMaxLeftValue);\n    }\n  }\n}\n\n// Do not edit the line below.\nexports.medianOfTwoSortedArrays = medianOfTwoSortedArrays;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const arrayOne = [1, 3, 4, 5];\n  const arrayTwo = [2, 3, 6, 7];\n  const expected = 3.5;\n  const actual = program.medianOfTwoSortedArrays(arrayOne, arrayTwo);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const arrayOne = [1, 3, 4, 5];\n  const arrayTwo = [2, 3, 6, 7];\n  const expected = 3.5;\n  const actual = program.medianOfTwoSortedArrays(arrayOne, arrayTwo);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(log(min(n, m)) time | O(1) space - where n is the length of arrayOne and m is the length of arrayTwo',
    tests: [
      { arrayOne: [1], arrayTwo: [2] },
      { arrayOne: [1], arrayTwo: [1] },
      { arrayOne: [1], arrayTwo: [2, 3] },
      { arrayOne: [1, 3], arrayTwo: [2] },
      { arrayOne: [1, 3, 4, 5], arrayTwo: [6, 7, 8, 9] },
      { arrayOne: [6, 7, 8, 9], arrayTwo: [1, 3, 4, 5] },
      { arrayOne: [1, 3, 4, 5], arrayTwo: [2, 3, 6, 7] },
      { arrayOne: [2, 3, 6, 7], arrayTwo: [1, 3, 4, 5] },
      { arrayOne: [1, 3, 4], arrayTwo: [2, 3, 6, 7] },
      { arrayOne: [1, 3, 4], arrayTwo: [2, 3, 6] },
      { arrayOne: [1, 3, 5, 6], arrayTwo: [7, 8] },
      { arrayOne: [7, 8], arrayTwo: [1, 3, 5, 6] },
      { arrayOne: [3, 4, 5], arrayTwo: [1, 2] },
      { arrayOne: [1, 2], arrayTwo: [3, 4, 5] },
      { arrayOne: [3, 4, 5, 6], arrayTwo: [1, 2] },
      { arrayOne: [1, 2], arrayTwo: [3, 4, 5, 6] },
      { arrayOne: [1, 4, 5, 6, 7, 8], arrayTwo: [1, 2, 3] },
      { arrayOne: [1, 5, 6, 7, 8], arrayTwo: [1, 2, 3] },
      { arrayOne: [1, 2, 3], arrayTwo: [1, 4, 5, 6, 7, 8] },
      { arrayOne: [1, 2, 3], arrayTwo: [1, 5, 6, 7, 8] },
      { arrayOne: [1], arrayTwo: [5, 6, 7, 8] },
      { arrayOne: [5, 6, 7, 8], arrayTwo: [1] },
      { arrayOne: [6], arrayTwo: [1, 5, 7, 8] },
      { arrayOne: [1, 5, 7, 8], arrayTwo: [6] },
      {
        arrayOne: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        arrayTwo: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
      },
      { arrayOne: [2, 2, 2, 2, 2], arrayTwo: [3, 3, 3, 3, 3] },
      { arrayOne: [2, 2, 2, 2, 2], arrayTwo: [3, 3, 3, 3] },
      { arrayOne: [-5, -4, -2, 3, 7, 243], arrayTwo: [-1, 0, 0, 32, 100] },
      { arrayOne: [-100, -50, -1, 0, 1], arrayTwo: [-1, 0, 1, 50, 100] },
      { arrayOne: [-100, -50, -1, 15, 30], arrayTwo: [1, 20, 50, 100] },
      { arrayOne: [-100, -50, 15, 30], arrayTwo: [1, 20, 50, 100] },
      { arrayOne: [-10, -5, 10, 20, 70], arrayTwo: [40, 50, 60] },
      { arrayOne: [40, 50, 60], arrayTwo: [-10, -5, 10, 20, 70] },
    ],
  },
  {
    id: 'repair-bst',
    name: 'Repair BST',
    category: 'Binary Search Trees',
    complexity: 2,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a Binary Search Tree (BST) that has at least 2 nodes and that\n    only has nodes with unique values (no duplicate values). Exactly two nodes\n    in the BST have had their values swapped, therefore breaking the BST. Write\n    a function that returns a repaired version of the tree with all values on\n    the correct nodes.\n  </p>\n  <p>\n    Your function can mutate the original tree; you do not need to create a new\n    one. Moreover, the shape of the returned tree should be exactly the same as\n    that of the original input tree.\n  </p>\n  <p>\n    Each <span>BST</span> node has an integer <span>value</span>, a\n    <span>left</span> child node, and a <span>right</span> child node. A node is\n    said to be a valid <span>BST</span> node if and only if it satisfies the BST\n    property: its <span>value</span> is strictly greater than the values of\n    every node to its left; its <span>value</span> is less than or equal to the\n    values of every node to its right; and its children nodes are either valid\n    <span>BST</span> nodes themselves or <span>None</span> / <span>null</span>.\n  </p>\n  <h3>Sample Input</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">tree</span> =    10\n        /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       7       20\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\    /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   3     12  8   22\n  /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n2              14\n</pre>\n  <h3>Sample Output</h3>\n  <pre>\n          10\n        /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       7       20\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\    /  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   3      8  12   22\n  /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n2              14\n</pre\n  >\n</div>',
    hints: [
      '<p>\n  If a binary tree is valid, an in order traversal would return all\n  of the nodes in order.\n</p>\n',
      '\n<p>\n  By doing an in order traversal, you can find the two nodes that\n  are in the incorrect places. Keep track of these nodes and\n  swap their values at the end.\n</p>\n',
      '\n<p>\n  You can keep a global to represent the previous node you saw\n  during the in order traversal. That way with each node you can\n  check if it is in the incorrect place.\n</p>',
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '2', left: null, right: '1', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '2',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexports.BST = BST;\n\nfunction repairBst(tree) {\n  // Write your code here.\n  return null;\n}\n\n// Do not edit the line below.\nexports.repairBst = repairBst;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfunction repairBst(tree) {\n  let nodeOne = null;\n  let nodeTwo = null;\n  let previousNode = null;\n\n  function inOrderTraversal(node) {\n    if (node === null) return;\n\n    inOrderTraversal(node.left);\n\n    if (previousNode !== null && previousNode.value > node.value) {\n      if (nodeOne === null) nodeOne = previousNode;\n      nodeTwo = node;\n    }\n\n    previousNode = node;\n    inOrderTraversal(node.right);\n  }\n\n  inOrderTraversal(tree);\n\n  const temp = nodeOne.value;\n  nodeOne.value = nodeTwo.value;\n  nodeTwo.value = temp;\n  return tree;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.repairBst = repairBst;\n',
        '// This is an input class. Do not edit.\nclass BST {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfunction repairBst(tree) {\n  let nodeOne = null;\n  let nodeTwo = null;\n  let previousNode = null;\n\n  const stack = [];\n  let currentNode = tree;\n  while (currentNode !== null || stack.length > 0) {\n    while (currentNode !== null) {\n      stack.push(currentNode);\n      currentNode = currentNode.left;\n    }\n    currentNode = stack.pop();\n\n    if (previousNode !== null && previousNode.value > currentNode.value) {\n      if (nodeOne === null) nodeOne = previousNode;\n      nodeTwo = currentNode;\n    }\n\n    previousNode = currentNode;\n    currentNode = currentNode.right;\n  }\n\n  const temp = nodeOne.value;\n  nodeOne.value = nodeTwo.value;\n  nodeTwo.value = temp;\n  return tree;\n}\n\n// Do not edit the lines below.\nexports.BST = BST;\nexports.repairBst = repairBst;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new program.BST(2);\n  tree.left = new program.BST(1);\n  tree.right = new program.BST(3);\n  tree.left.left = new program.BST(4);\n  tree.right.right = new program.BST(0);\n  const expected = [0, 1, 2, 3, 4];\n  const actual = inOrderTraverse(program.repairBst(tree), []);\n  chai.expect(actual).to.deep.equal(expected);\n});\n\nfunction inOrderTraverse(tree, array) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const tree = new program.BST(2);\n  tree.left = new program.BST(1);\n  tree.right = new program.BST(3);\n  tree.left.left = new program.BST(4);\n  tree.right.right = new program.BST(0);\n  const expected = [0, 1, 2, 3, 4];\n  const actual = inOrderTraverse(program.repairBst(tree), []);\n  chai.expect(actual).to.deep.equal(expected);\n});\n\nfunction inOrderTraverse(tree, array) {\n  if (tree !== null) {\n    inOrderTraverse(tree.left, array);\n    array.push(tree.value);\n    inOrderTraverse(tree.right, array);\n  }\n  return array;\n}\n",
    },
    bigO: 'O(n) time | O(h) space - where n is the number of nodes in the tree and h is the height of the tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '2', left: null, right: '1', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '3', value: 1 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '3', left: null, right: '2', value: 3 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '2', left: '3', right: '1', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '3', left: null, right: '0', value: 3 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '1', left: '4', right: null, value: 1 },
            { id: '0', left: null, right: null, value: 0 },
          ],
          root: '2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '13', value: 10 },
            { id: '13', left: '15', right: '22', value: 13 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '15', left: null, right: '14', value: 15 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '5', left: '2', right: '6', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '5', left: '2', right: '-15', value: 5 },
            { id: '-15', left: null, right: null, value: -15 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: '-5', right: null, value: 1 },
            { id: '-5', left: '7', right: '-4', value: -5 },
            { id: '-4', left: null, right: '-2', value: -4 },
            { id: '-2', left: null, right: '-1', value: -2 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '7', left: '-22', right: null, value: 7 },
            { id: '-22', left: null, right: null, value: -22 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '-5', right: '15', value: 10 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '-5', left: '2', right: '6', value: -5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: '5', right: null, value: 1 },
            { id: '5', left: '-15', right: '-4', value: 5 },
            { id: '-4', left: null, right: '-2', value: -4 },
            { id: '-2', left: null, right: '-1', value: -2 },
            { id: '-1', left: null, right: null, value: -1 },
            { id: '-15', left: '-22', right: null, value: -15 },
            { id: '-22', left: null, right: null, value: -22 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '5', right: '15', value: 1 },
            { id: '15', left: null, right: '22', value: 15 },
            { id: '22', left: null, right: '500', value: 22 },
            { id: '500', left: '50', right: '1500', value: 500 },
            { id: '1500', left: null, right: '10000', value: 1500 },
            { id: '10000', left: '2200', right: null, value: 10000 },
            { id: '2200', left: null, right: null, value: 2200 },
            { id: '50', left: null, right: '200', value: 50 },
            { id: '200', left: null, right: null, value: 200 },
            { id: '5', left: '2', right: '6', value: 5 },
            { id: '6', left: null, right: null, value: 6 },
            { id: '2', left: '10', right: null, value: 2 },
            { id: '10', left: null, right: null, value: 10 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '5000', left: '5', right: '55000', value: 5000 },
            { id: '55000', left: null, right: null, value: 55000 },
            { id: '5', left: '2', right: '15', value: 5 },
            { id: '15', left: '14', right: '22', value: 15 },
            { id: '22', left: null, right: '502', value: 22 },
            { id: '502', left: '1', right: null, value: 502 },
            { id: '1', left: '203', right: '205', value: 1 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '2', left: '-3', right: '3', value: 2 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '-3', left: null, right: '-2', value: -3 },
            { id: '-2', left: null, right: '-1', value: -2 },
            { id: '-1', left: null, right: '204', value: -1 },
            { id: '204', left: null, right: null, value: 204 },
          ],
          root: '5000',
        },
      },
      {
        tree: {
          nodes: [
            { id: '5000', left: '8', right: '203', value: 5000 },
            { id: '203', left: null, right: null, value: 203 },
            { id: '8', left: '6', right: '15', value: 8 },
            { id: '15', left: '10', right: '22', value: 15 },
            { id: '22', left: null, right: '502', value: 22 },
            { id: '502', left: '204', right: null, value: 502 },
            { id: '204', left: '55000', right: '205', value: 204 },
            { id: '205', left: null, right: '207', value: 205 },
            { id: '207', left: '206', right: '208', value: 207 },
            { id: '208', left: null, right: null, value: 208 },
            { id: '206', left: null, right: null, value: 206 },
            { id: '55000', left: null, right: null, value: 55000 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '6', left: '1', right: '7', value: 6 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '1', left: null, right: '2', value: 1 },
            { id: '2', left: null, right: '3', value: 2 },
            { id: '3', left: null, right: '4', value: 3 },
            { id: '4', left: null, right: '5', value: 4 },
            { id: '5', left: null, right: null, value: 5 },
          ],
          root: '5000',
        },
      },
    ],
  },
  {
    id: 'transpose-matrix',
    name: 'Transpose Matrix',
    category: 'Arrays',
    complexity: 0,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a 2D array of integers <span>matrix</span>. Write a function\n    that returns the transpose of the matrix.\n  </p>\n\n  <p>\n    The transpose of a matrix is a flipped version of the original matrix across\n    its main diagonal (which runs from top-left to bottom-right); it switches\n    the row and column indices of the original matrix.\n  </p>\n\n  <p>\n    You can assume the input matrix always has at least 1 value; however its\n    width and height are not necessarily the same.\n  </p>\n\n  <h3>Sample Input #1</h3>\n  <pre><span class="CodeEditor-promptParameter">matrix</span> = [\n  [1, 2],\n]</pre>\n  <h3>Sample Output # 1</h3>\n  <pre>\n[\n  [1],\n  [2]\n]</pre\n  >\n\n  <h3>Sample Input #2</h3>\n  <pre><span class="CodeEditor-promptParameter">matrix</span> = [\n  [1, 2],\n  [3, 4],\n  [5, 6]\n]</pre>\n  <h3>Sample Output #2</h3>\n  <pre>\n[\n  [1, 3, 5],\n  [2, 4, 6]\n]</pre\n  >\n\n  <h3>Sample Input #3</h3>\n  <pre><span class="CodeEditor-promptParameter">matrix</span> = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]</pre>\n  <h3>Sample Output #3</h3>\n  <pre>\n[\n  [1, 4, 7],\n  [2, 5, 8],\n  [3, 6, 9]\n]</pre\n  >\n</div>',
    hints: [
      '<p>\n  The row and column indices of each entry in the matrix should be flipped.\n  For example, the value at <span>matrix[1][2]</span> will be at\n  <span>matrix[2][1]</span> in the transpose of the matrix.\n</p>\n',
      '\n<p>\n  Each column in the matrix should be become a row in the transpose of the\n  matrix. Each row in the matrix should become a column in the transpose\n  of the matrix.\n</p>\n',
      '\n<p>\n  Try iterating one column at a time, and with each column, create a row of the\n  values to add to the transpose of the matrix.\n</p>',
    ],
    customInputVars: [
      {
        name: 'matrix',
        example: [[1]],
        schema: {
          items: { items: { type: 'integer' }, type: 'array' },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function transposeMatrix(matrix) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.transposeMatrix = transposeMatrix;\n',
      solutions: [
        '// O(w * h) time | O(w * h) space - where w is the\n// width of the matrix and h is the height\nfunction transposeMatrix(matrix) {\n  const transposedMatrix = [];\n  for (let col = 0; col < matrix[0].length; col++) {\n    const newRow = [];\n    for (let row = 0; row < matrix.length; row++) {\n      newRow.push(matrix[row][col]);\n    }\n    transposedMatrix.push(newRow);\n  }\n  return transposedMatrix;\n}\n\n// Do not edit the line below.\nexports.transposeMatrix = transposeMatrix;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n  ];\n  const expected = [\n    [1, 4, 7],\n    [2, 5, 8],\n    [3, 6, 9],\n  ];\n  const actual = program.transposeMatrix(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const input = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n  ];\n  const expected = [\n    [1, 4, 7],\n    [2, 5, 8],\n    [3, 6, 9],\n  ];\n  const actual = program.transposeMatrix(input);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(w * h) time | O(w * h) space - where w is the width of the matrix and h is the height',
    tests: [
      { matrix: [[1]] },
      { matrix: [[1], [-1]] },
      { matrix: [[1, 2, 3]] },
      { matrix: [[1], [2], [3]] },
      {
        matrix: [
          [1, 2, 3],
          [4, 5, 6],
        ],
      },
      {
        matrix: [
          [0, 0, 0],
          [1, 1, 1],
        ],
      },
      {
        matrix: [
          [0, 1],
          [0, 1],
          [0, 1],
        ],
      },
      {
        matrix: [
          [0, 0, 0],
          [0, 0, 0],
        ],
      },
      {
        matrix: [
          [1, 4],
          [2, 5],
          [3, 6],
        ],
      },
      {
        matrix: [
          [-7, -7],
          [100, 12],
          [-33, 17],
        ],
      },
      {
        matrix: [
          [1, 2, 3],
          [4, 5, 6],
          [7, 8, 9],
        ],
      },
      {
        matrix: [
          [1, 4, 7],
          [2, 5, 8],
          [3, 6, 9],
        ],
      },
      {
        matrix: [
          [5, 6, 3, -3, 12],
          [-3, 6, 5, 2, -1],
          [0, 0, 3, 12, 3],
        ],
      },
      {
        matrix: [
          [0, -1, -2, -3],
          [4, 5, 6, 7],
          [2, 3, -2, -3],
          [42, 100, 30, -42],
        ],
      },
      {
        matrix: [
          [1234, 6935, 4205],
          [-23459, 314159, 0],
          [100, 3, 987654],
        ],
      },
    ],
  },
  {
    id: 'reveal-minesweeper',
    name: 'Reveal Minesweeper',
    category: 'Recursion',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    <a\n      class="Link Link--ae"\n      href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)"\n      target="_blank"\n    >\n      Minesweeper\n    </a>\n    is a popular video game. From Wikipedia, "The game features a grid of\n    clickable squares, with hidden "mines" scattered throughout the board. The\n    objective is to clear the board without detonating any mines, with help from\n    clues about the number of neighboring mines in each field." Specifically,\n    when a player clicks on a square (also called a cell) that doesn\'t contain a\n    mine, the square reveals a number representing the number of immediately\n    adjacent mines (including diagonally adjacent mines).\n  </p>\n\n  <p>\n    You\'re given a two-dimensional array of strings that represents a\n    Minesweeper board for a game in progress. You\'re also given a row and a\n    column representing the indices of the next square that the player clicks on\n    the board. Write a function that returns an updated board after the click\n    (your function can mutate the input board).\n  </p>\n\n  <p>\n    The board will always contain only strings, and each string will be one of\n    the following:\n  </p>\n  <ul>\n    <li><span>"M"</span>: A mine that has not been clicked on.</li>\n    <li>\n      <span>"X"</span>: A mine that has been clicked on, indicating a lost game.\n    </li>\n    <li>\n      <span>"H"</span>: A cell with no mine, but whose content is still hidden\n      to the player.\n    </li>\n    <li>\n      <span>"0-8"</span>: A cell with no mine, with an integer from 0 to 8\n      representing the number of adjacent mines. Note that this is a\n      single-digit integer represented as a string. For example\n      <span>"2"</span> would mean there are 2 adjacent cells with mines.\n      Numbered cells are not clickable as they have already been revealed.\n    </li>\n  </ul>\n\n  <p>\n    If the player clicks on a mine, replace the <span>"M"</span> with\n    <span>"X"</span>, indicating the game was lost.\n  </p>\n  <p>\n    If the player clicks on a cell adjacent to a mine, replace the\n    <span>"H"</span> with a string representing the number of adjacent mines.\n  </p>\n  <p>\n    If the player clicks on a cell with no adjacent mines, replace the\n    <span>"H"</span> with <span>"0"</span>. Additionally, reveal all of the\n    adjacent hidden cells as if the player had clicked on those cells as well.\n  </p>\n\n  <p>\n    You can assume the given row and column will always represent a legal move.\n    The board can be of any size and have any number of mines in it.\n  </p>\n\n  <h3>Sample Input #1</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">board</span> = [\n  ["M", "M"],\n  ["H", "H"],\n  ["H", "H"]\n]   \n<span class="CodeEditor-promptParameter">row</span> = 2\n<span class="CodeEditor-promptParameter">column</span> = 0\n  </pre>\n  <h3>Sample Output #1</h3>\n  <pre>\n[\n  ["M", "M"],\n  ["2", "2"],\n  ["0", "0"]\n]\n  </pre>\n\n  <h3>Sample Input #2</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">board</span> = [\n  ["H", "H", "H", "H", "M"],\n  ["H", "1", "M", "H", "1"],\n  ["H", "H", "H", "H", "H"],\n  ["H", "H", "H", "H", "H"]\n]   \n<span class="CodeEditor-promptParameter">row</span> = 3\n<span class="CodeEditor-promptParameter">column</span> = 4\n\n</pre>\n  <h3>Sample Output #2</h3>\n  <pre>\n[\n  ["0", "1", "H", "H", "M"],\n  ["0", "1", "M", "2", "1"],\n  ["0", "1", "1", "1", "0"],\n  ["0", "0", "0", "0", "0"]\n]\n</pre>\n</div>',
    hints: [
      '<p>\n  While the input is a 2D array, this problem can also be thought of as a graph\n  problem. Each cell is a node, each with up to 8 edges to their adjacent cells.\n</p>\n',
      '\n<p>\n  If the player clicks on a cell with no adjacent mines, it is as if they\n  clicked on all of the hidden cells adjacent to that cell as well. Try solving\n  this recursively, running the function again on those adjacent cells.\n</p>\n',
      '\n<p>\n  Doing DFS or BFS through all of the adjacent cells without mines will be the\n  most efficient way to find and reveal them all.\n</p>',
    ],
    customInputVars: [
      {
        name: 'board',
        example: [['H']],
        schema: {
          items: { items: { type: 'string' }, type: 'array' },
          type: 'array',
        },
      },
      { name: 'row', example: 0, schema: { minimum: 0, type: 'integer' } },
      { name: 'column', example: 0, schema: { minimum: 0, type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function revealMinesweeper(board, row, column) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.revealMinesweeper = revealMinesweeper;\n',
      solutions: [
        "// O(w * h) time | O(w * h) space - where w is the width of the board, and\n// h is the height of the board\nfunction revealMinesweeper(board, row, column) {\n  if (board[row][column] === 'M') {\n    board[row][column] = 'X';\n    return board;\n  }\n\n  const neighbors = getNeighbors(board, row, column);\n  let adjacentMinesCount = 0;\n  for (const [neighborRow, neighborColumn] of neighbors) {\n    if (board[neighborRow][neighborColumn] === 'M') {\n      adjacentMinesCount += 1;\n    }\n  }\n\n  if (adjacentMinesCount > 0) {\n    board[row][column] = adjacentMinesCount.toString();\n  } else {\n    board[row][column] = '0';\n    for (const [neighborRow, neighborColumn] of neighbors) {\n      if (board[neighborRow][neighborColumn] === 'H') {\n        revealMinesweeper(board, neighborRow, neighborColumn);\n      }\n    }\n  }\n\n  return board;\n}\n\nfunction getNeighbors(board, row, column) {\n  const directions = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n    [1, 1],\n    [1, -1],\n    [-1, 1],\n    [-1, -1],\n  ];\n  const neighbors = [];\n  for (const [directionRow, directionColumn] of directions) {\n    const newRow = row + directionRow;\n    const newColumn = column + directionColumn;\n    if (0 <= newRow && newRow < board.length && 0 <= newColumn && newColumn < board[0].length) {\n      neighbors.push([newRow, newColumn]);\n    }\n  }\n\n  return neighbors;\n}\n\n// Do not edit the line below.\nexports.revealMinesweeper = revealMinesweeper;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const board = [\n    ['H', 'H', 'H', 'H', 'M'],\n    ['H', '1', 'M', 'H', '1'],\n    ['H', 'H', 'H', 'H', 'H'],\n    ['H', 'H', 'H', 'H', 'H'],\n  ];\n  const row = 3;\n  const column = 4;\n  const expected = [\n    ['0', '1', 'H', 'H', 'M'],\n    ['0', '1', 'M', '2', '1'],\n    ['0', '1', '1', '1', '0'],\n    ['0', '0', '0', '0', '0'],\n  ];\n  const actual = program.revealMinesweeper(board, row, column);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const board = [\n    ['H', 'H', 'H', 'H', 'M'],\n    ['H', '1', 'M', 'H', '1'],\n    ['H', 'H', 'H', 'H', 'H'],\n    ['H', 'H', 'H', 'H', 'H'],\n  ];\n  const row = 3;\n  const column = 4;\n  const expected = [\n    ['0', '1', 'H', 'H', 'M'],\n    ['0', '1', 'M', '2', '1'],\n    ['0', '1', '1', '1', '0'],\n    ['0', '0', '0', '0', '0'],\n  ];\n  const actual = program.revealMinesweeper(board, row, column);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(w * h) time | O(w * h) space - where w is the width of the board, and h is the height of the board',
    tests: [
      { board: [['H']], column: 0, row: 0 },
      { board: [['M']], column: 0, row: 0 },
      { board: [['H', 'M']], column: 0, row: 0 },
      { board: [['H', 'H']], column: 0, row: 0 },
      {
        board: [
          ['H', 'H'],
          ['H', 'H'],
        ],
        column: 0,
        row: 0,
      },
      {
        board: [
          ['H', 'H'],
          ['H', 'H'],
        ],
        column: 0,
        row: 1,
      },
      {
        board: [
          ['H', 'H'],
          ['H', 'H'],
        ],
        column: 1,
        row: 1,
      },
      {
        board: [
          ['H', 'H'],
          ['H', 'H'],
        ],
        column: 1,
        row: 0,
      },
      {
        board: [
          ['H', 'M'],
          ['H', 'H'],
        ],
        column: 1,
        row: 0,
      },
      {
        board: [
          ['H', 'M'],
          ['H', 'H'],
        ],
        column: 1,
        row: 1,
      },
      {
        board: [
          ['H', 'M'],
          ['H', 'H'],
        ],
        column: 0,
        row: 1,
      },
      {
        board: [
          ['H', 'M'],
          ['H', 'H'],
        ],
        column: 0,
        row: 0,
      },
      {
        board: [
          ['M', 'M'],
          ['M', 'M'],
        ],
        column: 0,
        row: 0,
      },
      {
        board: [
          ['M', 'M'],
          ['M', 'M'],
        ],
        column: 0,
        row: 1,
      },
      {
        board: [
          ['M', 'M'],
          ['H', 'H'],
          ['H', 'H'],
        ],
        column: 0,
        row: 0,
      },
      {
        board: [
          ['M', 'M'],
          ['H', 'H'],
          ['H', 'H'],
        ],
        column: 0,
        row: 1,
      },
      {
        board: [
          ['M', 'M'],
          ['H', 'H'],
          ['H', 'H'],
        ],
        column: 0,
        row: 2,
      },
      {
        board: [
          ['M', 'M', 'M'],
          ['M', 'H', 'M'],
          ['M', 'M', 'M'],
        ],
        column: 1,
        row: 1,
      },
      {
        board: [
          ['M', 'M', 'M', 'M'],
          ['M', 'H', 'H', 'M'],
          ['M', 'M', 'M', 'M'],
        ],
        column: 1,
        row: 1,
      },
      {
        board: [
          ['H', 'H', 'H', 'H', 'M'],
          ['H', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H'],
        ],
        column: 0,
        row: 3,
      },
      {
        board: [
          ['H', 'H', 'H', 'H', 'M'],
          ['H', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H'],
        ],
        column: 4,
        row: 3,
      },
      {
        board: [
          ['H', 'H', 'H', 'H', 'M'],
          ['H', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H'],
        ],
        column: 2,
        row: 0,
      },
      {
        board: [
          ['H', 'H', 'H', 'H', 'M'],
          ['H', '1', 'M', 'H', '1'],
          ['H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H'],
        ],
        column: 4,
        row: 3,
      },
      {
        board: [
          ['H', 'H', 'M', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'M', 'H'],
          ['H', 'M', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'M', 'H', 'M', 'H', 'H', 'M'],
          ['M', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'M', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'M', 'H', 'H'],
          ['H', 'M', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
        ],
        column: 0,
        row: 0,
      },
      {
        board: [
          ['H', 'H', 'M', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'M', 'H'],
          ['H', 'M', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'M', 'H', 'M', 'H', 'H', 'M'],
          ['M', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'M', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'M', 'H', 'H'],
          ['H', 'M', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
        ],
        column: 6,
        row: 3,
      },
      {
        board: [
          ['H', 'H', 'M', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'M', 'H'],
          ['H', 'M', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'M', 'H', 'M', 'H', 'H', 'M'],
          ['M', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'M', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'M', 'H', 'H'],
          ['H', 'M', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
        ],
        column: 4,
        row: 7,
      },
      {
        board: [
          ['H', 'M', 'H', 'H', 'H', 'H', 'M', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['M', 'H', 'H', 'M', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'M', 'H', 'H', 'H', 'H', 'M', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'M'],
        ],
        column: 0,
        row: 6,
      },
      {
        board: [
          ['H', 'M', '1', 'H', '1', 'H', 'M', '1'],
          ['H', 'H', 'H', 'H', 'M', 'H', '2', 'H'],
          ['M', 'H', 'H', 'M', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['1', 'M', 'H', 'H', 'H', 'H', 'M', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'M'],
        ],
        column: 0,
        row: 6,
      },
      {
        board: [
          ['H', 'M', '1', 'H', '1', 'H', 'M', '1'],
          ['H', 'H', 'H', 'H', 'M', 'H', '2', 'H'],
          ['M', 'H', 'H', 'M', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['1', 'M', 'H', 'H', 'H', 'H', 'M', 'H'],
          ['1', '1', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'M'],
        ],
        column: 0,
        row: 6,
      },
      {
        board: [
          ['H', 'M', 'H', 'H', 'H', 'H', 'M', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['M', 'H', 'H', 'M', 'H', 'M', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'M', 'H', 'H', 'H', 'H', 'M', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'M'],
        ],
        column: 7,
        row: 6,
      },
      {
        board: [
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'M', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'M', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'M', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'M', 'H'],
          ['H', 'H', 'H', 'H', 'M', 'H', 'H', 'H', 'H', 'M', 'H', 'H'],
          ['M', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H'],
          ['H', 'H', 'H', 'H', 'H', 'H', 'H', 'M', 'H', 'H', 'H', 'H'],
        ],
        column: 2,
        row: 6,
      },
      {
        board: [
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'H', 'H', 'H', 'H', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'H', 'H', 'H', 'H', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'H', 'H', 'H', 'H', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
        ],
        column: 3,
        row: 4,
      },
      {
        board: [
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'H', 'H', 'H', 'H', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'H', 'H', 'H', 'H', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'H', 'H', 'H', 'H', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
        ],
        column: 5,
        row: 5,
      },
      {
        board: [
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', '5', '3', '3', '5', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'H', 'H', 'H', 'H', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'H', 'H', 'H', 'H', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
          ['M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M'],
        ],
        column: 5,
        row: 5,
      },
    ],
  },
  {
    id: 'sweet-and-savory',
    name: 'Sweet And Savory',
    category: 'Arrays',
    complexity: 1,
    prompt:
      '<div class="html">\n  <p>\n    You\'re hosting an event at a food festival and want to showcase the best\n    possible pairing of two dishes from the festival that complement each\n    other\'s flavor profile.\n  </p>\n\n  <p>\n    Each dish has a flavor profile represented by an integer. A negative integer\n    means a dish is sweet, while a positive integer means a dish is savory. The\n    absolute value of that integer represents the intensity of that flavor. For\n    example, a flavor profile of -3 is slightly sweet, one of -10 is extremely\n    sweet, one of 2 is mildly savory, and one of 8 is significantly savory.\n  </p>\n\n  <p>\n    You\'re given an array of these dishes and a target combined flavor profile.\n    Write a function that returns the best possible pairing of two dishes (the\n    pairing with a total flavor profile that\'s closest to the target one). Note\n    that this pairing must include one sweet and one savory dish. You\'re also\n    concerned about the dish being too savory, so your pairing should never be\n    more savory than the target flavor profile.\n  </p>\n\n  <p>\n    All dishes will have a positive or negative flavor profile; there are no\n    dishes with a 0 value. For simplicity, you can assume that there will be at\n    most one best solution. If there isn\'t a valid solution, your function\n    should return <span>[0, 0]</span>. The returned array should be sorted,\n    meaning the sweet dish should always come first.\n  </p>\n\n  <h3>Sample Input #1</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">dishes</span> = [-3, -5, 1, 7]   \n<span class="CodeEditor-promptParameter">target</span> = 8\n</pre>\n  <h3>Sample Output #1</h3>\n  <pre>\n[-3, 7] <span class="CodeEditor-promptComment">// The combined profile of 4 is closest without going over</span>\n</pre>\n\n  <h3>Sample Input #2</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">dishes</span> = [3, 5, 7, 2, 6, 8, 1]  \n<span class="CodeEditor-promptParameter">target</span> = 10\n</pre>\n  <h3>Sample Output #2</h3>\n  <pre>\n[0, 0] <span class="CodeEditor-promptComment">// There are no sweet dishes\n</span>\n</pre>\n\n  <h3>Sample Input #3</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">dishes</span> = [2, 5, -4, -7, 12, 100, -25]  \n<span class="CodeEditor-promptParameter">target</span> = -20\n</pre>\n  <h3>Sample Output #3</h3>\n  <pre>\n[-25, 5] <span class="CodeEditor-promptComment">// This pairing gets the exact combined profile of -20</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  The sweet and savory dishes are essentially two different lists that have\n  been combined into one. It can be helpful to first separate them.\n</p>\n',
      '\n<p>\n  Looking at all possible pairs will be inefficient. Would sorting the lists\n  first help improve the time complexity?\n</p>\n',
      '\n<p>\n  Try using a two pointer approach to find the best pairing. Start with a\n  current pairing, and move the savory pointer until the pairing gets too\n  savory. If the dish is too savory, then move the sweet pointer. Do this\n  through the entire lists, keeping track of the best pairing you find.\n</p>',
    ],
    customInputVars: [
      {
        name: 'dishes',
        example: [],
        schema: { items: { type: 'integer' }, type: 'array' },
      },
      { name: 'target', example: 10, schema: { type: 'integer' } },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function sweetAndSavory(dishes, target) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.sweetAndSavory = sweetAndSavory;\n',
      solutions: [
        '// O(n * log(n)) time | O(n) space - where n is number of dishes\nfunction sweetAndSavory(dishes, target) {\n  const sweetDishes = dishes.filter(dish => dish < 0).sort((a, b) => b - a);\n  const savoryDishes = dishes.filter(dish => dish > 0).sort((a, b) => a - b);\n\n  let bestPair = [0, 0];\n  let bestDifference = Infinity;\n  let sweetIndex = 0,\n    savoryIndex = 0;\n\n  while (sweetIndex < sweetDishes.length && savoryIndex < savoryDishes.length) {\n    const currentSum = sweetDishes[sweetIndex] + savoryDishes[savoryIndex];\n\n    if (currentSum <= target) {\n      const currentDifference = target - currentSum;\n      if (currentDifference < bestDifference) {\n        bestDifference = currentDifference;\n        bestPair = [sweetDishes[sweetIndex], savoryDishes[savoryIndex]];\n      }\n      savoryIndex += 1;\n    } else {\n      sweetIndex += 1;\n    }\n  }\n\n  return bestPair;\n}\n\n// Do not edit the line below.\nexports.sweetAndSavory = sweetAndSavory;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const dishes = [-3, -5, 1, 7];\n  const target = 8;\n  const expected = [-3, 7];\n  const actual = program.sweetAndSavory(dishes, target);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const dishes = [-3, -5, 1, 7];\n  const target = 8;\n  const expected = [-3, 7];\n  const actual = program.sweetAndSavory(dishes, target);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * log(n)) time | O(n) space - where n is number of dishes',
    tests: [
      { dishes: [], target: 10 },
      { dishes: [4], target: 10 },
      { dishes: [-5, 10], target: 4 },
      { dishes: [], target: -10 },
      { dishes: [4], target: -10 },
      { dishes: [-5, 10], target: -4 },
      { dishes: [5, -10], target: -4 },
      { dishes: [-5, 10], target: 5 },
      { dishes: [-5, 10], target: 0 },
      { dishes: [5, -10], target: 0 },
      { dishes: [10, -5], target: 5 },
      { dishes: [10, -5], target: 100 },
      { dishes: [5, -5, 5, -5, 5, -5], target: 10 },
      { dishes: [5, -5, 5, -5, 5, -5], target: 0 },
      { dishes: [3, 5, 7, 2, 6, 8, 1], target: 10 },
      { dishes: [-3, -5, 1, 7], target: 8 },
      { dishes: [-3, -5, 1, 7], target: 0 },
      { dishes: [2, 5, -4, -7, 12, 100, -25], target: -5 },
      { dishes: [2, 5, -4, -7, 12, 100, -25], target: -7 },
      { dishes: [2, 4, -4, -7, 12, 100, -25], target: -1 },
      { dishes: [2, 5, -4, -7, 12, 100, -25], target: -20 },
      { dishes: [2, 5, -4, -7, 12, 100, -25], target: 5 },
      { dishes: [2, 5, -4, -7, 12, 100, -25], target: 7 },
      { dishes: [2, 5, -4, -7, 12, 100, -25], target: 1 },
      { dishes: [2, 5, -4, -7, 12, 100, -25], target: 20 },
      { dishes: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5], target: 6 },
      { dishes: [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5], target: -6 },
      { dishes: [17, 37, 12, -102, 53, 49, -90, 102, 49, 16, 52], target: 12 },
      { dishes: [17, 37, 12, -102, 53, 49, -90, 102, 49, 16, 52], target: 11 },
      {
        dishes: [17, 37, 12, -102, 53, 49, -90, 102, 49, 16, 52],
        target: -100,
      },
      { dishes: [17, 37, 12, -102, 53, 49, -90, 102, 49, 16, 52], target: -28 },
      { dishes: [-12, 13, 100, -53, 540, -538, 53, 76, 32, -63], target: 0 },
      { dishes: [-12, 13, 100, -53, 540, -538, 53, 76, 32, -63], target: -34 },
      { dishes: [-12, 13, 100, -53, 540, -538, 53, 76, 32, -63], target: -15 },
      { dishes: [-12, 13, 100, -53, 540, -538, 53, 76, 32, -63], target: 42 },
    ],
  },
  {
    id: 'optimalAssemblyLine',
    name: 'Optimal Assembly Line',
    category: 'Searching',
    complexity: 3,
    prompt:
      '<div class="html">\n  <p>\n    One of the most efficient ways to run a factory is to use an assembly line,\n    with multiple stations performing different assembling steps simultaneously\n    in order to save time. But an assembly line is only as fast as its slowest\n    station/step; for example, if an assembly line has 100 different steps\n    performed by 100 different stations, with 99 steps taking 1 minute each to\n    complete and 1 step taking 1 hour to complete, then the entire assembly line\n    is dramatically slowed down by the 1-hour-long step.\n  </p>\n  <p>\n    Write a function that takes in a non-empty array of positive integers\n    <span>stepDurations</span> and a positive integer <span>numStations</span>.\n    The input array of integers represents the times that the various steps in\n    an assembly process take, and the input integer represents the number of\n    stations that this assembly process has access to. For this particular\n    assembly process, a single station can perform multiple steps, so long as\n    these steps are performed in order, meaning that a single station can\n    perform multiple steps whose times appear consecutively in the\n    <span>stepDurations</span> array. Your function should return the longest\n    duration of a single station in the assembly line after optimizing the\n    assembly line (i.e., minimizing its slowest station/step).\n  </p>\n  <p>You can assume that there will never be more stations than steps.</p>\n  <h3>Sample Input</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">stepDurations</span> = [15, 15, 30, 30, 45]\n<span class="CodeEditor-promptParameter">numStations</span> = 3</pre>\n  <h3>Sample Output</h3>\n  <pre>60 <span class="CodeEditor-promptComment"> // Station 1 does steps 0 and 1. Station 2 does steps 2 and 3. Station 3 does step 4.</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  First try considering what the range of possible solutions are. What is the\n  smallest possible solution and the largest possible solution?\n</p>\n',
      '\n<p>\n  The smallest possible solution would be the largest duration in\n  <span>stepDurations</span> in the case that this step was the only step done by its\n  station. The largest possible solution would be the sum of all of the\n  <span>stepDurations</span> if they were all done by one solution.\n</p>\n',
      '\n<p>\n  Given this smallest and largest possible solution, you can do a binary\n  search between the values to find the smallest potential solution that\n  is actually valid.\n</p>\n',
      "\n<p>\n  You can check if a potential solution is valid by during a single iteration\n  through the <span>stepDurations</span> array. If a step has a duration larger than\n  the potential solution's max station duration, then that can't be a correct\n  solution. Otherwise, combine that step with the previous steps if the\n  combination of them is not larger than the potential solution's max station\n  duration. If it can't be combined with previous steps, then it must require\n  a new station. Keep track of how many stations are required and ensure it is\n  less than or equal to <span>numStations</span>.\n</p>",
    ],
    customInputVars: [
      {
        name: 'stepDurations',
        example: [5],
        schema: { items: { type: 'integer' }, minimum: 1, type: 'array' },
      },
      {
        name: 'numStations',
        example: 1,
        schema: { minimum: 1, type: 'integer' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function optimalAssemblyLine(stepDurations, numStations) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.optimalAssemblyLine = optimalAssemblyLine;\n',
      solutions: [
        '// O(n * log(m)) time | O(1) space - where n is the length of stepDurations, and\n// m is the sum of all values in stepDurations\nfunction optimalAssemblyLine(stepDurations, numStations) {\n  let left = Math.max(...stepDurations);\n  let right = stepDurations.reduce((a, b) => a + b);\n  let maxStationDuration = Infinity;\n\n  while (left <= right) {\n    const potentialMaxStationDuration = Math.floor((left + right) / 2);\n\n    if (isPotentialSolution(stepDurations, numStations, potentialMaxStationDuration)) {\n      maxStationDuration = potentialMaxStationDuration;\n      right = potentialMaxStationDuration - 1;\n    } else {\n      left = potentialMaxStationDuration + 1;\n    }\n  }\n\n  return maxStationDuration;\n}\n\nfunction isPotentialSolution(stepDurations, numStations, potentialMaxStationDuration) {\n  let stationsRequired = 1;\n  let currentDuration = 0;\n\n  for (const stepDuration of stepDurations) {\n    if (currentDuration + stepDuration > potentialMaxStationDuration) {\n      stationsRequired += 1;\n      currentDuration = stepDuration;\n    } else {\n      currentDuration += stepDuration;\n    }\n  }\n\n  return stationsRequired <= numStations;\n}\n\n// Do not edit the line below.\nexports.optimalAssemblyLine = optimalAssemblyLine;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const stepDurations = [15, 15, 30, 30, 45];\n  const numStations = 3;\n  const expected = 60;\n  const actual = program.optimalAssemblyLine(stepDurations, numStations);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const stepDurations = [15, 15, 30, 30, 45];\n  const numStations = 3;\n  const expected = 60;\n  const actual = program.optimalAssemblyLine(stepDurations, numStations);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * log(m)) time | O(1) space - where n is the length of steps, and m is the sum of all values in steps',
    tests: [
      { numStations: 1, stepDurations: [5] },
      { numStations: 2, stepDurations: [5, 7] },
      { numStations: 3, stepDurations: [1, 2, 3, 4, 5] },
      { numStations: 2, stepDurations: [5, 10, 20, 30] },
      { numStations: 4, stepDurations: [1, 2, 3, 4, 5, 6] },
      { numStations: 3, stepDurations: [15, 25, 35, 45, 55, 65] },
      { numStations: 2, stepDurations: [5, 2, 9, 3] },
      { numStations: 3, stepDurations: [6, 8, 4, 2, 10] },
      { numStations: 2, stepDurations: [30, 5, 20, 10] },
      { numStations: 4, stepDurations: [40, 30, 10, 20, 60, 50] },
      { numStations: 3, stepDurations: [35, 65, 45, 15, 25, 55] },
      { numStations: 2, stepDurations: [1, 2, 2, 3] },
      { numStations: 3, stepDurations: [15, 15, 30, 30, 45] },
      { numStations: 2, stepDurations: [5, 5, 10, 20, 20] },
      { numStations: 4, stepDurations: [20, 10, 20, 30, 10, 30] },
      { numStations: 2, stepDurations: [25, 25, 35, 35] },
      { numStations: 3, stepDurations: [10, 20, 30] },
      { numStations: 4, stepDurations: [15, 25, 35, 45] },
      { numStations: 3, stepDurations: [5, 10, 20] },
      { numStations: 3, stepDurations: [12, 23, 38, 11, 47, 6] },
      { numStations: 4, stepDurations: [32, 41, 15, 27, 22, 9, 48] },
      { numStations: 5, stepDurations: [45, 8, 37, 49, 2, 23, 19, 26] },
      { numStations: 1, stepDurations: [32, 41, 15, 27, 22, 9, 48] },
      { numStations: 1, stepDurations: [45, 8, 37, 49, 2, 23, 19, 26] },
      { numStations: 3, stepDurations: [21, 14, 7, 42, 35, 28] },
      { numStations: 4, stepDurations: [37, 15, 8, 29, 43, 22, 50, 1] },
      { numStations: 5, stepDurations: [18, 33, 46, 27, 9, 12, 39, 24, 3] },
      { numStations: 2, stepDurations: [21, 14, 7, 42, 35, 28] },
      { numStations: 3, stepDurations: [37, 15, 8, 29, 43, 22, 50, 1] },
      { numStations: 3, stepDurations: [18, 33, 46, 27, 9, 12, 39, 24, 3] },
    ],
  },
  {
    id: 'largest-park',
    name: 'Largest Park',
    category: 'Stacks',
    complexity: 3,
    prompt:
      '<div class="html">\n  <p>\n    A city wants to build a new public park, and you\'ve been tasked with finding\n    the largest park they can build without disturbing existing infrastructure.\n  </p>\n  <p>\n    Write a function that takes in a two-dimensional array (a matrix)\n    <span>land</span> representing the total land of the city from a top-down\n    view. Each value in <span>land</span> is a boolean; false values are pieces\n    of land not currently in use, while true values are pieces of land currently\n    in use by other infrastructure. Return the area of the largest possible\n    park.\n  </p>\n\n  <p>\n    The largest possible park will be placed exclusively on unused land (false\n    values). Moreover, the city wants the park to be a perfect rectangle. If\n    there is no available land, your function should return 0.\n  </p>\n  <h3>Sample Input</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">land</span> = [\n  [false, true, true, true, false],\n  [false, false, false, true, false],\n  [false, false, false, false, false],\n  [false, true, true, true, true]\n]\n</pre>\n  <h3>Sample Output</h3>\n  <pre>\n6 <span class="CodeEditor-promptComment"> // The park would go from row 1 to row 2 in columns 0 to 3, giving a total area of 6.</span>\n</pre>\n</div>',
    hints: [
      '<p>\n  Try first breaking this problem down into smaller problems. If you had only\n  a single row, how would you find the largest rectangle of available land in\n  that single row?\n</p>\n',
      '\n<p>\n  If a second row is added below the first row, now each column has a height.\n  This essentially forms a histogram, where you need to find the largest\n  rectangle within that histogram.\n</p>\n',
      '\n<p>\n  To find the area of the largest rectangle in one of these histograms, you need\n  to find the width and the height of the rectangles. Since they must be perfect\n  rectangles, the height is constrained to the lowest height of the histogram\n  bars in the span. The width is then the number of bars in the span.\n</p>\n',
      '\n<p>\n  As you iterate through the histogram, think about how you can identify the\n  start and end of a potential rectangle. When you encounter a bar that is\n  shorter than the previous bars, it means the current rectangle has ended.\n  Can you use this observation to find the largest rectangle in the histogram?\n</p>\n',
      '\n<p>\n  To keep track of the bars that are part of the same rectangle, try using a\n  monotonic stack to maintain the column indices in increasing order based on\n  heights.\n</p>\n',
      "\n<p>\n  Iterate through each column of the histogram. While the stack is not empty and\n  the height at the current column index is less than the height at the index\n  on top of the stack, pop column indices off of the stack, calculating the\n  rectangle's width and height using the popped index and current index. Check\n  if this area is larger than the largest area seen so far, and if it is then\n  save it. After this process, append the current index to the stack.\n  After this iteration, make sure to also process any remaining values in the\n  stack.\n</p>\n",
      '\n<p>\n  Repeat this process with every row, finding the largest possible rectangle of\n  the histogram where this row is the bottom row. The largest rectangle found\n  in any of these rows will be the final solution.\n</p>',
    ],
    customInputVars: [
      {
        name: 'land',
        example: [[true]],
        schema: {
          items: { items: { type: 'boolean' }, type: 'array' },
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function largestPark(land) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the line below.\nexports.largestPark = largestPark;\n',
      solutions: [
        '// O(w * h) time | O(w) space - where w is the width of the input matrix and\n// h is the height of the input matrix\nfunction largestPark(land) {\n  const heights = new Array(land[0].length).fill(0);\n  let maxArea = 0;\n\n  for (const row of land) {\n    for (let columnIndex = 0; columnIndex < land[0].length; columnIndex++) {\n      heights[columnIndex] = row[columnIndex] === false ? heights[columnIndex] + 1 : 0;\n    }\n    maxArea = Math.max(maxArea, largestRectangleHistogram(heights));\n  }\n\n  return maxArea;\n}\n\nfunction largestRectangleHistogram(heights) {\n  const stack = [];\n  let maxArea = 0;\n\n  for (let columnIndex = 0; columnIndex < heights.length; columnIndex++) {\n    while (stack.length > 0 && heights[columnIndex] < heights[stack[stack.length - 1]]) {\n      const height = heights[stack.pop()];\n      const width = stack.length === 0 ? columnIndex : columnIndex - stack[stack.length - 1] - 1;\n      maxArea = Math.max(maxArea, width * height);\n    }\n    stack.push(columnIndex);\n  }\n\n  while (stack.length > 0) {\n    const height = heights[stack.pop()];\n    const width =\n      stack.length === 0 ? heights.length : heights.length - stack[stack.length - 1] - 1;\n    maxArea = Math.max(maxArea, width * height);\n  }\n\n  return maxArea;\n}\n\n// Do not edit the line below.\nexports.largestPark = largestPark;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const land = [\n    [false, true, true, true, false],\n    [false, false, false, true, false],\n    [false, false, false, false, false],\n    [false, true, true, true, true],\n  ];\n  const expected = 6;\n  const actual = program.largestPark(land);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const land = [\n    [false, true, true, true, false],\n    [false, false, false, true, false],\n    [false, false, false, false, false],\n    [false, true, true, true, true],\n  ];\n  const expected = 6;\n  const actual = program.largestPark(land);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(w * h) time | O(w) space - where w is the width of the input matrix and h is the height of the input matrix',
    tests: [
      { land: [[true]] },
      { land: [[false]] },
      { land: [[true, false, true]] },
      { land: [[false, true, false]] },
      { land: [[false, false, false]] },
      { land: [[true, true, true]] },
      {
        land: [
          [false, false, false],
          [false, false, false],
        ],
      },
      {
        land: [
          [false, true, false],
          [false, false, false],
        ],
      },
      {
        land: [
          [false, false, false],
          [false, true, false],
        ],
      },
      {
        land: [
          [false, true, false],
          [false, true, false],
        ],
      },
      {
        land: [
          [false, true, false],
          [false, true, false],
          [false, true, false],
        ],
      },
      {
        land: [
          [false, true, false],
          [false, false, false],
          [false, true, false],
        ],
      },
      {
        land: [
          [false, false, false],
          [false, false, false],
          [false, true, false],
        ],
      },
      {
        land: [
          [false, false, false],
          [false, false, false],
          [false, false, false],
        ],
      },
      {
        land: [
          [false, false, false],
          [false, false, false],
          [false, false, true],
        ],
      },
      {
        land: [
          [false, false, false],
          [false, false, false],
          [true, false, false],
        ],
      },
      {
        land: [
          [true, false, false],
          [false, false, false],
          [false, false, false],
        ],
      },
      {
        land: [
          [false, false, true],
          [false, false, false],
          [false, false, false],
        ],
      },
      {
        land: [
          [true, true, false, true, false],
          [false, true, false, false, false],
          [true, false, false, false, false],
          [false, true, true, false, true],
        ],
      },
      {
        land: [
          [true, true, true],
          [true, true, true],
          [true, true, true],
        ],
      },
      {
        land: [
          [false, false],
          [false, false],
        ],
      },
      {
        land: [
          [true, false, true, false],
          [false, true, false, true],
          [true, false, true, false],
          [false, true, false, true],
        ],
      },
      {
        land: [
          [false, false, false, false, false],
          [false, false, false, false, false],
          [false, false, true, false, false],
          [false, false, false, false, false],
          [false, false, false, false, false],
        ],
      },
      {
        land: [
          [true, false, false, true, true, false],
          [false, true, true, false, true, false],
          [true, true, false, false, true, false],
        ],
      },
      {
        land: [
          [false, true, true, true],
          [true, true, true, true],
          [true, true, true, true],
          [true, true, true, true],
        ],
      },
      {
        land: [
          [true, false, false, true, true, false],
          [false, true, true, false, true, false],
          [true, true, false, true, true, false],
        ],
      },
      { land: [[true], [false], [true], [false], [true], [false], [true]] },
      { land: [[true], [true], [true], [true], [true], [true], [true]] },
      { land: [[false], [false], [false], [false], [false], [false], [false]] },
      {
        land: [
          [false, true, false, false, true, false],
          [true, false, true, false, false, true],
          [false, true, false, true, false, false],
          [false, false, true, false, true, false],
          [true, false, false, true, false, true],
          [false, true, false, false, true, false],
        ],
      },
      {
        land: [
          [true, false, true, false, false],
          [false, true, false, true, true],
          [false, true, true, false, false],
          [false, true, false, false, true],
          [true, false, true, false, false],
        ],
      },
      {
        land: [
          [true, false, true, true, false, false, true],
          [false, true, false, false, true, true, false],
          [true, false, true, true, false, false, true],
        ],
      },
      {
        land: [
          [false, false, true, false, false, true, true],
          [true, true, false, true, true, false, false],
          [false, true, false, true, false, false, false],
          [false, true, false, false, true, true, true],
        ],
      },
      {
        land: [
          [true, false, true, false, false, true, false, true, false, true],
          [false, true, false, true, true, false, true, false, true, false],
          [true, false, true, false, false, true, false, true, false, true],
          [false, true, false, true, true, false, true, false, true, false],
          [true, false, true, false, false, true, false, true, false, true],
          [false, true, false, true, true, false, true, false, true, false],
          [true, false, true, false, false, true, false, true, false, true],
          [false, true, false, true, true, false, true, false, true, false],
          [true, false, true, false, false, true, false, true, false, true],
          [false, true, false, true, true, false, true, false, true, false],
        ],
      },
      {
        land: [
          [false, false, false, false, false, false],
          [false, false, false, false, false, false],
          [false, false, true, true, true, false],
          [false, false, true, true, true, false],
          [false, false, true, true, true, false],
          [false, false, false, false, false, false],
          [false, false, false, false, false, false],
        ],
      },
      {
        land: [
          [true, true, true, false, false, false],
          [true, true, true, false, false, false],
          [true, true, true, false, false, false],
          [false, false, false, false, false, false],
          [false, false, false, false, false, false],
          [false, false, false, false, false, false],
          [false, false, false, false, false, false],
        ],
      },
      {
        land: [
          [true, true, true, true, true, true],
          [true, true, true, true, true, true],
          [true, false, false, false, false, true],
          [true, false, false, false, false, true],
          [true, false, false, false, false, true],
          [true, true, true, true, true, true],
          [true, true, true, true, true, true],
        ],
      },
      {
        land: [
          [false, false, false, true, true, true],
          [false, false, false, true, true, true],
          [false, false, false, true, true, true],
          [false, false, false, true, true, true],
          [true, true, true, true, true, true],
          [true, true, true, true, true, true],
          [true, true, true, true, true, true],
        ],
      },
      {
        land: [
          [false, false, false, true, true, true],
          [false, true, true, true, true, true],
          [true, false, false, false, false, true],
          [true, false, false, false, false, true],
          [true, false, false, false, false, true],
          [true, true, true, true, true, false],
          [false, false, true, true, false, false],
        ],
      },
      {
        land: [
          [
            true,
            false,
            true,
            false,
            true,
            false,
            true,
            false,
            false,
            true,
            false,
            false,
            true,
            false,
            false,
          ],
          [
            false,
            false,
            true,
            true,
            false,
            true,
            false,
            false,
            true,
            false,
            true,
            false,
            false,
            false,
            false,
          ],
          [
            true,
            true,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            true,
            true,
            false,
            false,
            false,
          ],
          [
            true,
            true,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            true,
            true,
            false,
            false,
            true,
          ],
          [
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            true,
          ],
          [
            true,
            false,
            true,
            true,
            false,
            true,
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            false,
            true,
          ],
          [
            false,
            true,
            false,
            false,
            true,
            false,
            true,
            true,
            false,
            true,
            false,
            true,
            false,
            false,
            true,
          ],
          [
            false,
            true,
            false,
            true,
            false,
            true,
            false,
            false,
            true,
            false,
            true,
            true,
            false,
            true,
            false,
          ],
          [
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            true,
          ],
          [
            true,
            false,
            true,
            true,
            false,
            true,
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            false,
            true,
          ],
          [
            false,
            true,
            false,
            false,
            true,
            false,
            true,
            true,
            false,
            false,
            false,
            true,
            false,
            false,
            true,
          ],
          [
            false,
            true,
            false,
            true,
            false,
            true,
            false,
            false,
            true,
            false,
            true,
            true,
            false,
            true,
            false,
          ],
          [
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            true,
          ],
          [
            true,
            false,
            true,
            true,
            false,
            true,
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            false,
            false,
          ],
          [
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
          ],
        ],
      },
    ],
  },
  {
    id: 'longest-most-frequent-prefix',
    name: 'Longest Most Frequent Prefix',
    category: 'Tries',
    complexity: 2,
    prompt:
      '<div class="html">\n  <p>\n    Write a function that takes in an array of unique strings and returns the\n    prefix that appears most frequently throughout the strings. If there are two\n    or more such prefixes, your function should return the longest one. If there\n    are no such prefixes, your function should return the longest string. You\n    can assume that there will only ever be one longest prefix or string.\n  </p>\n\n  <p>\n    For example, given the strings\n    <span>["algoexpert", "algorithm", "foo", "food"]</span>, the most frequent\n    prefix is either "algo" or "foo", since both appear in two strings. However,\n    "algo" is longer than "foo", so "algo" is the desired answer.\n  </p>\n\n  <h3>Sample Input #1</h3>\n  <pre><span class="CodeEditor-promptParameter">strings</span> = [\n  "algoexpert",\n  "algorithm",\n  "frontendexpert",\n  "mlexpert"\n]</pre>\n  <h3>Sample Output #1</h3>\n  <pre>"algo"</pre>\n\n  <h3>Sample Input #2</h3>\n  <pre><span class="CodeEditor-promptParameter">strings</span> = [\n  "hello",\n  "world",\n  "fossil",\n  "worldly",\n  "food",\n  "forrest",\n  "helium",\n  "algoexpert",\n  "algorithm"\n]</pre>\n  <h3>Sample Output #2</h3>\n  <pre>"fo"</pre>\n</div>',
    hints: [
      '<p>\n  This problem requires finding shared prefixes of various strings.\n  Is there a data structure that can help with this?\n</p>\n',
      '\n<p>\n  Try first inserting all of the strings into a trie, and with that trie keep\n  track of the frequency of every prefix you see. The most common prefix will\n  be the solution.\n</p>\n',
      '\n<p>\n  To avoid iterating through the trie after creating it, try calculating what\n  the current solution to the problem is as you insert into the trie.\n</p>',
    ],
    customInputVars: [
      {
        name: 'strings',
        example: ['algoexpert'],
        schema: {
          items: { minLength: 1, type: 'string' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        "function longestMostFrequentPrefix(strings) {\n  // Write your code here.\n  return '';\n}\n\n// Do not edit the line below.\nexports.longestMostFrequentPrefix = longestMostFrequentPrefix;\n",
      solutions: [
        "// O(n * m) time | O(n * m) space - where n is the length of strings, and m\n// is the length of the longest string\nfunction longestMostFrequentPrefix(strings) {\n  const trie = new Trie();\n  for (const string of strings) {\n    trie.insert(string);\n  }\n  return trie.maxPrefixFullString.slice(0, trie.maxPrefixLength);\n}\n\nclass Trie {\n  constructor() {\n    this.root = {count: 0};\n    this.maxPrefixCount = 0;\n    this.maxPrefixLength = 0;\n    this.maxPrefixFullString = '';\n  }\n\n  insert(string) {\n    let currentTrieNode = this.root;\n    for (let i = 0; i < string.length; i++) {\n      if (!(string[i] in currentTrieNode)) {\n        currentTrieNode[string[i]] = {count: 0};\n      }\n      currentTrieNode = currentTrieNode[string[i]];\n      currentTrieNode.count++;\n\n      if (currentTrieNode.count > this.maxPrefixCount) {\n        this.maxPrefixCount = currentTrieNode.count;\n        this.maxPrefixLength = i + 1;\n        this.maxPrefixFullString = string;\n      } else if (currentTrieNode.count === this.maxPrefixCount && i + 1 > this.maxPrefixLength) {\n        this.maxPrefixLength = i + 1;\n        this.maxPrefixFullString = string;\n      }\n    }\n  }\n}\n\n// Do not edit the line below.\nexports.longestMostFrequentPrefix = longestMostFrequentPrefix;\n",
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['algoexpert', 'algorithm', 'frontendexpert', 'mlexpert'];\n  const expected = 'algo';\n  const actual = program.longestMostFrequentPrefix(strings);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['algoexpert', 'algorithm', 'frontendexpert', 'mlexpert'];\n  const expected = 'algo';\n  const actual = program.longestMostFrequentPrefix(strings);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * m) time | O(n * m) space - where n is the length of strings, and m is the length of the longest string',
    tests: [
      { strings: ['algoexpert'] },
      { strings: ['abcdef', 'abcdefg', 'aaa', 'bbb', 'ccc'] },
      { strings: ['abcdefg', 'abcdddd', 'abceeee', 'bcdefg', 'cdefg', 'abce'] },
      { strings: ['algoexpert', 'algorithm', 'frontendexpert', 'mlexpert'] },
      {
        strings: [
          'hello',
          'world',
          'fossil',
          'worldly',
          'food',
          'forrest',
          'helium',
          'algoexpert',
          'algorithm',
        ],
      },
      {
        strings: [
          'foobarbaz',
          'foo',
          'bar',
          'foobarfoo',
          'baz',
          'foobaz',
          'foofoofoo',
          'foobazar',
        ],
      },
      {
        strings: [
          'foobarbaz',
          'foo',
          'bar',
          'foobarfoo',
          'baz',
          'foobaz',
          'foofoofoo',
          'foobazar',
          'fancy',
        ],
      },
      { strings: ['foo', 'bar', 'foobar'] },
      { strings: ['foo', 'bar', 'barfoo'] },
      { strings: ['foo', 'bar', 'baz'] },
      {
        strings: [
          'this',
          'is',
          'a',
          'test',
          'thisisatest',
          'thisisthis',
          'thisisnotatest',
          'atestthisis',
          'testthistest',
          'notthistest',
        ],
      },
      {
        strings: [
          'this',
          'is',
          'a',
          'thisisatest',
          'thisisthis',
          'thisisnotatest',
          'atestthisis',
          'notthistest',
        ],
      },
      {
        strings: [
          'abc1',
          'abc2',
          'abc3',
          'abc4',
          'xyzk1',
          'xyzk2',
          'xyzk3',
          'xyzk4',
        ],
      },
      {
        strings: ['abc', 'def', 'ghi', 'jkl', 'mnop', 'qrs', 'tuv', 'wxy', 'z'],
      },
    ],
  },
  {
    id: 'shortest-unique-prefixes',
    name: 'Shortest Unique Prefixes',
    category: 'Tries',
    complexity: 2,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given an array of unique strings. Write a function that returns an\n    array containing the shortest unique prefix for each string.\n  </p>\n\n  <p>\n    For example, given the strings <span>["algoexpert", "algorithm"]</span>, the\n    shortest prefixes that uniquely identify each string are\n    <span>["algoe", "algor"]</span>.\n  </p>\n\n  <p>\n    If a string <span>strA</span> is entirely contained in another string\n    <span>strB</span>, then there is no completely unique prefix for\n    <span>strA</span>, and thus its shortest unique prefix should be its entire\n    self. For example, given the strings <span>["food", "foodie"]</span>, the\n    shortest prefixes to uniquely identify each string would be\n    <span>["food", "foodi"]</span>. In this example, "food"\'s shortest unique\n    prefix must be "food" (the entire string), since it\'s entirely contained in\n    "foodie". It follows that "foodie" can\'t have just "food" as its shortest\n    unique prefix.\n  </p>\n\n  <p>\n    Your function should return the prefixes in the corresponding order of the input\n    strings (i.e., the index of each prefix should be the same as the index of its corresponding\n    string).\n  </p>\n\n  <h3>Sample Input #1</h3>\n  <pre><span class="CodeEditor-promptParameter">strings</span> = [\n  "algoexpert",\n  "algorithm",\n]</pre>\n  <h3>Sample Output #1</h3>\n  <pre>\n[\n  "algoe",\n  "algor"\n]</pre\n  >\n\n  <h3>Sample Input #2</h3>\n  <pre><span class="CodeEditor-promptParameter">strings</span> = [\n  "hello",\n  "world",\n  "he",\n  "foo",\n  "worldly",\n  "food",\n  "algoexpert"\n]</pre>\n  <h3>Sample Output #2</h3>\n  <pre>\n[\n  "hel",\n  "world",\n  "he",\n  "foo",\n  "worldl",\n  "food",\n  "a"\n]</pre\n  >\n\n  <h3>Sample Input #3</h3>\n  <pre><span class="CodeEditor-promptParameter">strings</span> = [\n  "foo",\n  "food",\n  "foods",\n  "foodie"\n]</pre>\n  <h3>Sample Output #3</h3>\n  <pre>\n[\n  "foo",\n  "food",\n  "foods",\n  "foodi"\n]</pre\n  >\n</div>',
    hints: [
      '<p>\n  This problem requires organizing the strings based on their starting characters.\n  Is there a data structure that can help with this?\n</p>\n',
      '\n<p>\n  Try first inserting all of the strings into a trie, then use that trie to find\n  the shortest unique prefix for each.\n</p>\n',
      '\n<p>\n  In the trie, any node that we only ever see once is unique to a word. Try\n  keeping track of how many visits are made to each node. For each string, the\n  path to the shortest unique prefix ends when a node with only 1 visit is found.\n</p>',
    ],
    customInputVars: [
      {
        name: 'strings',
        example: ['hello'],
        schema: {
          items: { minLength: 1, type: 'string' },
          minItems: 1,
          type: 'array',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function shortestUniquePrefixes(strings) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.shortestUniquePrefixes = shortestUniquePrefixes;\n',
      solutions: [
        '// O(n * m) time | O(n * m) space - where n is the length of strings, and m\n// is the length of the longest string\nfunction shortestUniquePrefixes(strings) {\n  const trie = new Trie();\n  for (const string of strings) {\n    trie.insert(string);\n  }\n\n  const prefixes = [];\n  for (const string of strings) {\n    const uniquePrefix = findUniquePrefix(string, trie);\n    prefixes.push(uniquePrefix);\n  }\n\n  return prefixes;\n}\n\nfunction findUniquePrefix(string, trie) {\n  let currentStringIdx = 0;\n  let currentTrieNode = trie.root;\n\n  while (currentStringIdx < string.length - 1) {\n    const currentStringChar = string[currentStringIdx];\n    currentTrieNode = currentTrieNode[currentStringChar];\n    if (currentTrieNode.count === 1) break;\n    currentStringIdx++;\n  }\n\n  return string.slice(0, currentStringIdx + 1);\n}\n\nclass Trie {\n  constructor() {\n    this.root = {count: 0};\n  }\n\n  insert(string) {\n    let currentTrieNode = this.root;\n    for (let i = 0; i < string.length; i++) {\n      if (!(string[i] in currentTrieNode)) {\n        currentTrieNode[string[i]] = {count: 0};\n      }\n      currentTrieNode = currentTrieNode[string[i]];\n      currentTrieNode.count++;\n    }\n  }\n}\n\n// Do not edit the line below.\nexports.shortestUniquePrefixes = shortestUniquePrefixes;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['algoexpert', 'algorithm', 'frontendexpert', 'mlexpert'];\n  const expected = ['algoe', 'algor', 'f', 'm'];\n  const actual = program.shortestUniquePrefixes(strings);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['algoexpert', 'algorithm', 'frontendexpert', 'mlexpert'];\n  const expected = ['algoe', 'algor', 'f', 'm'];\n  const actual = program.shortestUniquePrefixes(strings);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n * m) time | O(n * m) space - where n is the length of strings, and m is the length of the longest string',
    tests: [
      { strings: ['hello'] },
      { strings: ['hello', 'world'] },
      { strings: ['algoexpert', 'algorithm', 'frontendexpert', 'mlexpert'] },
      { strings: ['foo', 'food'] },
      {
        strings: [
          'hello',
          'world',
          'he',
          'foo',
          'worldly',
          'food',
          'algoexpert',
        ],
      },
      { strings: ['foo', 'food', 'foods', 'foodie'] },
      { strings: ['amazing', 'amaze', 'amazement', 'maze', 'may', 'apple'] },
      {
        strings: [
          'aircraft',
          'airplane',
          'airy',
          'plane',
          'planter',
          'plantation',
        ],
      },
      { strings: ['a', 'ab', 'abc', 'abcd', 'abcde', 'abcdef'] },
      { strings: ['abcdef', 'abcde', 'abcd', 'abc', 'ab', 'a'] },
      { strings: ['a', 'abc', 'abcdefg'] },
      {
        strings: [
          'code',
          'coder',
          'program',
          'programmer',
          'coding',
          'programming',
        ],
      },
      { strings: ['zig', 'zag', 'zap', 'zoo', 'zit'] },
      {
        strings: [
          'swap',
          'paws',
          'print',
          'swing',
          'kayak',
          'trie',
          'tree',
          'king',
          'queen',
          'quilt',
        ],
      },
      {
        strings: [
          'programmingexpert',
          'programming',
          'expert',
          'frontendexpert',
          'front',
          'end',
          'frontend',
        ],
      },
    ],
  },
  {
    id: 'strings-made-up-of-strings',
    name: 'Strings Made Up Of Strings',
    category: 'Tries',
    complexity: 3,
    prompt:
      '<div class="html">\n  <p>\n    Write a function that takes in a non-empty array of unique strings\n    <span>strings</span> as well as another non-empty array of unique strings\n    <span>substrings</span>. This function should return an array of all of\n    the strings in <span>strings</span> that can be formed by concatenating\n    one or more of the strings in <span>substrings</span>.\n  </p>\n\n  <p>Note that:</p>\n  <ul>\n    <li>\n      The strings in <span>substrings</span> won\'t necessarily always be\n      smaller than those in <span>strings</span>. For example, the string\n      <span>"ab"</span> could be contained in <span>substrings</span> with the\n      string <span>"a"</span> contained in <span>strings</span>.\n    </li>\n    <li>\n      A substring can be used multiple times to make up a string. For\n      example, the substring <span>"foo"</span> can be used twice to make up\n      the string <span>"foofoo"</span>.\n    </li>\n    <li>\n      A substring must be entirely contained in a string in order to be\n      part of it.\n    </li>\n    <li>\n      If a string is exactly equal to a substring, that string should\n      be included in the output array.\n    </li>\n    <li>The order of the strings in the output array doesn\'t matter.</li>\n  </ul>\n  <p></p>\n  <h3>Sample Input #1</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">strings</span> = [\n  "bar",\n  "are",\n  "foo",\n  "ba",\n  "b",\n  "barely"\n]\n<span class="CodeEditor-promptParameter">substrings</span> = [\n  "b",\n  "a",\n  "r",\n  "ba",\n  "ar",\n  "bar"\n]</pre>\n  <h3>Sample Output #1</h3>\n  <pre>\n["bar", "ba", "b"]\n</pre\n  >\n\n  <h3>Sample Input #2</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">strings</span> = [\n  "barbar",\n  "algoexpert",\n  "frontendexpert"\n]\n<span class="CodeEditor-promptParameter">substrings</span> = [\n  "algo",\n  "bar",\n  "expert",\n  "end",\n  "front"\n]</pre>\n  <h3>Sample Output #2</h3>\n  <pre>\n["barbar", "algoexpert", "frontendexpert"]\n</pre\n  >\n</div>',
    hints: [
      '<p>\n  Try breaking this problem down into small chunks. For every string in\n  <span>strings</span>, we want to first figure out if any of the\n  <span>substrings</span> are the same as the beginning of the current\n  string. Then the process should repeat for the remaining characters of the\n  current string until the entire string has been found.\n</p>\n',
      '\n<p>\n  Since we need to be able to quickly find if the beginning of a string is\n  present in the <span>substrings</span>, it will be helpful to create a\n  Trie to hold all of the substrings.\n</p>\n',
      "\n<p>\n  You'll likely end up doing a lot of repetitive work. For this reason, adding\n  a memoization dictionary to contain all of the previous found substrings\n  can help improve the time complexity.\n</p>\n",
      '\n<p>\n  Finding a substring of a string is usually an O(n) operation. To avoid this,\n  try simply passing start and end indices to helper functions, rather than\n  actually creating the substrings.\n</p>',
    ],
    customInputVars: [
      {
        name: 'strings',
        example: ['foobar'],
        schema: { items: { minLength: 1, type: 'string' }, type: 'array' },
      },
      {
        name: 'substrings',
        example: ['foo', 'bar'],
        schema: { items: { minLength: 1, type: 'string' }, type: 'array' },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        'function stringsMadeUpOfStrings(strings, substrings) {\n  // Write your code here.\n  return [];\n}\n\n// Do not edit the line below.\nexports.stringsMadeUpOfStrings = stringsMadeUpOfStrings;\n',
      solutions: [
        '// O(s2 * m + s1 * n^2) time | O(s2 * m + s1 * n) space - where s2 is the number\n// of substrings, m is the length of the longest substring, s1 is the\n// number of strings, and n is the length of the longest string\nfunction stringsMadeUpOfStrings(strings, substrings) {\n  const trie = new Trie();\n  for (const substring of substrings) {\n    trie.insert(substring);\n  }\n\n  const solutions = [];\n  for (const string of strings) {\n    if (isMadeUpOfStrings(string, 0, trie, {})) {\n      solutions.push(string);\n    }\n  }\n\n  return solutions;\n}\n\nfunction isMadeUpOfStrings(string, startIdx, trie, memo) {\n  if (startIdx === string.length) return true;\n  if (startIdx in memo) return memo[startIdx];\n\n  let currentTrieNode = trie.root;\n  for (\n    let currentCharacterIdx = startIdx;\n    currentCharacterIdx < string.length;\n    currentCharacterIdx++\n  ) {\n    const currentCharacter = string[currentCharacterIdx];\n    if (!(currentCharacter in currentTrieNode)) break;\n\n    currentTrieNode = currentTrieNode[currentCharacter];\n    if (\n      currentTrieNode.isEndOfString &&\n      isMadeUpOfStrings(string, currentCharacterIdx + 1, trie, memo)\n    ) {\n      memo[startIdx] = true;\n      return true;\n    }\n  }\n\n  memo[startIdx] = false;\n  return false;\n}\n\nclass Trie {\n  constructor() {\n    this.root = {isEndOfString: false};\n  }\n\n  insert(string) {\n    let currentTrieNode = this.root;\n    for (let i = 0; i < string.length; i++) {\n      if (!(string[i] in currentTrieNode)) {\n        currentTrieNode[string[i]] = {isEndOfString: false};\n      }\n      currentTrieNode = currentTrieNode[string[i]];\n    }\n    currentTrieNode.isEndOfString = true;\n  }\n}\n\n// Do not edit the line below.\nexports.stringsMadeUpOfStrings = stringsMadeUpOfStrings;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['bar', 'are', 'foo', 'ba', 'b', 'barely'];\n  const substrings = ['b', 'a', 'r', 'ba', 'ar', 'bar'];\n  const expected = ['bar', 'ba', 'b'];\n  const actual = program.stringsMadeUpOfStrings(strings, substrings);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const strings = ['bar', 'are', 'foo', 'ba', 'b', 'barely'];\n  const substrings = ['b', 'a', 'r', 'ba', 'ar', 'bar'];\n  const expected = ['bar', 'ba', 'b'];\n  const actual = program.stringsMadeUpOfStrings(strings, substrings);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(s2 * m + s1 * n^2) time | O(s2 * m + s1 * n) space - where s2 is the number of substrings, m is the length of the longest substring, s1 is the number of strings, and n is the length of the longest string',
    tests: [
      { strings: ['foobar'], substrings: ['foo', 'bar'] },
      { strings: ['foo'], substrings: ['foo'] },
      { strings: ['foobar'], substrings: ['foo', 'baz'] },
      { strings: ['baz'], substrings: ['b', 'a', 'z'] },
      { strings: ['algoexpert'], substrings: ['algo', 'pert', 'ex'] },
      { strings: ['bar'], substrings: ['barely'] },
      { strings: ['bar'], substrings: ['b', 'a', 'r', 'ba', 'ar'] },
      { strings: ['bar'], substrings: ['b', 'a', 'r', 'ba', 'ar', 'bar'] },
      {
        strings: ['bar', 'are', 'foo', 'ba', 'b', 'barely'],
        substrings: ['b', 'a', 'r', 'ba', 'ar', 'bar'],
      },
      {
        strings: ['barbar', 'algoexpert', 'frontendexpert'],
        substrings: ['algo', 'bar', 'expert', 'end', 'front'],
      },
      { strings: ['foo123', 'bar$%'], substrings: ['foo', '123', 'bar', '$%'] },
      { strings: ['foo123', 'bar$%'], substrings: ['123', 'foo', 'bar'] },
      { strings: ['foobarfoobar'], substrings: ['foo', 'bar'] },
      {
        strings: [
          'foobarfoobar',
          'foo',
          'bar',
          'barfoobar',
          'fobaro',
          'foobaro',
        ],
        substrings: ['foo', 'bar'],
      },
      {
        strings: ['foo', 'bar', 'baz', 'qux', 'quux'],
        substrings: ['foo', 'ba', 'qu', 'ux'],
      },
      {
        strings: ['foofoo', 'barbar', 'bazbaz', 'foobaz'],
        substrings: ['foo', 'bar', 'baz'],
      },
      {
        strings: ['foo', 'bar', 'baz', 'qux', 'quux', 'foobar'],
        substrings: ['foo', 'ba', 'qux'],
      },
      {
        strings: ['foobarbaz', 'bazbarfoo', 'foobaz', 'quxquux', 'quuxqux'],
        substrings: ['foo', 'ba', 'bar', 'baz', 'qux', 'qu'],
      },
      {
        strings: [
          'java',
          'javascript',
          'python',
          'ruby',
          'c',
          'cplusplus',
          'assembly',
        ],
        substrings: [
          'ja',
          'script',
          'py',
          'thon',
          'ruby',
          'c',
          'plus',
          'va',
          'assembly',
        ],
      },
      {
        strings: [
          'java',
          'javascript',
          'python',
          'ruby',
          'c',
          'cplusplus',
          'assembly',
        ],
        substrings: [
          'ja',
          'py',
          'thone',
          'ruby',
          'c',
          'minus',
          'va',
          'assembler',
        ],
      },
      {
        strings: [
          'linkedlist',
          'binarysearchtree',
          'depthfirstsearch',
          'breadthfirstsearch',
          'quicksort',
        ],
        substrings: [
          'linked',
          'list',
          'binary',
          'search',
          'tree',
          'depth',
          'first',
          'breadth',
          'quick',
          'sort',
        ],
      },
      {
        strings: [
          'linkedlist',
          'binarysearchtree',
          'depthfirstsearch',
          'breadthfirstsearch',
          'quicksort',
        ],
        substrings: [
          'so',
          'se',
          'rt',
          'arch',
          'tre',
          'e',
          'binary',
          'depth',
          'link',
          'ed',
          'list',
          'first',
        ],
      },
      {
        strings: [
          'linkedlist',
          'binarysearchtree',
          'depthfirstsearch',
          'breadthfirstsearch',
          'quicksort',
        ],
        substrings: [
          'so',
          'se',
          'rt',
          'arch',
          'tre',
          'binary',
          'depth',
          'link',
          'list',
          'first',
        ],
      },
    ],
  },
  {
    id: 'sum-bsts',
    name: 'Sum BSTs',
    category: 'Binary Search Trees',
    complexity: 2,
    prompt:
      '<div class="html">\n  <p>\n    You\'re given a Binary Tree. As with any Binary Tree, this tree may contain\n    one or more Binary Search Trees (BSTs), and it may even be a BST itself.\n  </p>\n  <p>\n    Write a function that returns the sum of all the values of nodes in this\n    tree which are part of a BST containing at least 3 nodes.\n  </p>\n  <p>\n    Each <span>BinaryTree</span> node has an integer <span>value</span>, a\n    <span>left</span> child node, and a <span>right</span> child node. Children\n    nodes can either be <span>BinaryTree</span> nodes themselves or\n    <span>None</span> / <span>null</span>.\n  </p>\n  <p>\n    A BST is a special type of Binary Tree whose nodes all satisfy the BST\n    property. A node satisfies the BST property if its <span>value</span> is\n    strictly greater than the values of every node to its left; its\n    <span>value</span> is less than or equal to the values of every node to its\n    right; and its children nodes are either valid <span>BST</span> nodes\n    themselves or <span>None</span> / <span>null</span>.\n  </p>\n\n  <h3>Sample Input #1</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">tree</span> =     8\n         /    \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n       2       9\n     /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\       \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n   1     10       5    \n</pre>\n\n  <h3>Sample Output #1</h3>\n  <pre>\n13 <span class="CodeEditor-promptComment">// 1, 2, and 10 form the only BST containing at least 3 nodes.\n</span>\n</pre>\n\n  <h3>Sample Input #2</h3>\n  <pre>\n  <span class="CodeEditor-promptParameter">tree</span> =            20\n            /                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \n           7                 10\n         /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\             /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        0     8           5      15\n            /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\       /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n           7     9     2     5 13   22\n                     /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                    1             14\n</pre>\n\n  <h3>Sample Output #2</h3>\n<pre>\n118 <span class="CodeEditor-promptComment">// The subtrees rooted at 7 and 10 are both BSTs, and their node values add up to 118.\n</span>\n</pre>\n\n  <h3>Sample Input #3</h3>\n  <pre>\n<span class="CodeEditor-promptParameter">tree</span> =            20\n          /                \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \n         9                 10\n       /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\             /     \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n      0     8           6      15\n          /           /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\   /   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n         7           2     5 17   22\n                   /           \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                  1             14\n</pre>\n\n  <h3>Sample Output #3</h3>\n  <pre>\n0 <span class="CodeEditor-promptComment">// The subtrees rooted at 8 and 2 are both BSTs, but they only contain 2 nodes each.\n</span>\n</pre>\n</div>',
    hints: [
      "<p>\n  You'll need to have each node in the tree pass information up to its parent node.\n  What information does each node need from its children nodes? And what algorithm\n  can be used to pass this information up?\n</p>\n",
      "\n<p>\n  To efficiently pass information up the tree, you'll want to use a postorder\n  traversal depth first search. This will allow you to see all of the children\n  of a node before processing that node.\n</p>\n",
      "\n<p>\n  For any given node, you'll need to determine if that node can be the root of\n  a BST. To do this, you'll need to know if both of its children are root nodes\n  of BSTs. You'll also need to know the maximum and minimum values of those\n  trees.\n</p>\n",
      "\n<p>\n  To ensure you only count BSTs with at least 3 nodes, try also passing information\n  up to the parent node on how many nodes are in the child's subtree.\n</p>",
    ],
    customInputVars: [
      {
        name: 'tree',
        example: {
          nodes: [
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '2',
        },
        schema: {
          description:
            "A Binary Tree is represented by a list of <span>nodes</span> and a <span>root</span> node. Every node has to\nhave a unique string <span>id</span> that will be referenced by other nodes' <span>left</span> and <span>right</span>\npointers and by the <span>root</span>.\n",
          properties: {
            nodes: {
              items: {
                properties: {
                  id: { type: 'string' },
                  left: { type: ['string', 'null'] },
                  right: { type: ['string', 'null'] },
                  value: { type: 'integer' },
                },
                required: ['id', 'value', 'left', 'right'],
                type: 'object',
              },
              type: 'array',
            },
            root: { type: 'string' },
          },
          required: ['root', 'nodes'],
          type: 'object',
        },
      },
    ],
    isFree: false,
    isAvailable: true,
    solution: {
      solutionsDisabled: false,
      startingCode:
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction sumBsts(tree) {\n  // Write your code here.\n  return -1;\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.sumBsts = sumBsts;\n',
      solutions: [
        '// This is an input class. Do not edit.\nclass BinaryTree {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// O(n) time | O(h) space - where n is the number of nodes in the\n// tree and h is the height of the tree\nfunction sumBsts(tree) {\n  return getTreeInfo(tree).totalSumBstNodes;\n}\n\nfunction getTreeInfo(tree) {\n  if (tree === null) {\n    return {\n      isBst: true,\n      maxValue: -Infinity,\n      minValue: Infinity,\n      bstSum: 0,\n      bstSize: 0,\n      totalSumBstNodes: 0,\n    };\n  }\n\n  const leftTreeInfo = getTreeInfo(tree.left);\n  const rightTreeInfo = getTreeInfo(tree.right);\n\n  const satisfiesBstProp =\n    tree.value > leftTreeInfo.maxValue && tree.value <= rightTreeInfo.minValue;\n  const isBst = satisfiesBstProp && leftTreeInfo.isBst && rightTreeInfo.isBst;\n\n  const maxValue = Math.max(tree.value, Math.max(leftTreeInfo.maxValue, rightTreeInfo.maxValue));\n  const minValue = Math.min(tree.value, Math.min(leftTreeInfo.minValue, rightTreeInfo.minValue));\n\n  let bstSum = 0;\n  let bstSize = 0;\n\n  let totalSumBstNodes = leftTreeInfo.totalSumBstNodes + rightTreeInfo.totalSumBstNodes;\n\n  if (isBst) {\n    bstSum = tree.value + leftTreeInfo.bstSum + rightTreeInfo.bstSum;\n    bstSize = 1 + leftTreeInfo.bstSize + rightTreeInfo.bstSize;\n\n    if (bstSize >= 3) totalSumBstNodes = bstSum;\n  }\n\n  return {\n    isBst,\n    maxValue,\n    minValue,\n    bstSum,\n    bstSize,\n    totalSumBstNodes,\n  };\n}\n\n// Do not edit the lines below.\nexports.BinaryTree = BinaryTree;\nexports.sumBsts = sumBsts;\n',
      ],
      sandboxCode:
        "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(8);\n  root.left = new program.BinaryTree(2);\n  root.left.left = new program.BinaryTree(1);\n  root.left.right = new program.BinaryTree(10);\n  root.right = new program.BinaryTree(9);\n  root.right.right = new program.BinaryTree(5);\n  const expected = 13;\n  const actual = program.sumBsts(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
      unitTests:
        "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  const root = new program.BinaryTree(8);\n  root.left = new program.BinaryTree(2);\n  root.left.left = new program.BinaryTree(1);\n  root.left.right = new program.BinaryTree(10);\n  root.right = new program.BinaryTree(9);\n  root.right.right = new program.BinaryTree(5);\n  const expected = 13;\n  const actual = program.sumBsts(root);\n  chai.expect(actual).to.deep.equal(expected);\n});\n",
    },
    bigO: 'O(n) time | O(h) space - where n is the number of nodes in the tree and h is the height of the tree',
    tests: [
      {
        tree: {
          nodes: [
            { id: '2', left: '1', right: '3', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '2',
        },
      },
      {
        tree: {
          nodes: [{ id: '1', left: null, right: null, value: 1 }],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '2', left: '3', right: '1', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '3', left: null, right: null, value: 3 },
          ],
          root: '2',
        },
      },
      {
        tree: {
          nodes: [
            { id: '10', left: '5', right: null, value: 10 },
            { id: '5', left: '1', right: null, value: 5 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '10',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '5', value: 1 },
            { id: '5', left: null, right: '10', value: 5 },
            { id: '10', left: null, right: null, value: 10 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: null, right: '5', value: 1 },
            { id: '5', left: null, right: '10', value: 5 },
            { id: '10', left: null, right: '15', value: 10 },
            { id: '15', left: null, right: null, value: 15 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '20', left: '7', right: '10', value: 20 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '7', left: '3', right: '8', value: 7 },
            { id: '8', left: '7-2', right: '9', value: 8 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '7-2', left: null, right: null, value: 7 },
            { id: '3', left: null, right: null, value: 3 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
          ],
          root: '20',
        },
      },
      {
        tree: {
          nodes: [
            { id: '8', left: '2', right: null, value: 8 },
            { id: '2', left: '1', right: '-5', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '-5', left: null, right: null, value: -5 },
          ],
          root: '8',
        },
      },
      {
        tree: {
          nodes: [
            { id: '3', left: '8', right: '2', value: 3 },
            { id: '8', left: '2-2', right: '9', value: 8 },
            { id: '2', left: '1', right: '4', value: 2 },
            { id: '2-2', left: '1-1', right: null, value: 2 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '1-1', left: '-1', right: null, value: 1 },
            { id: '-1', left: '-5', right: '20', value: -1 },
            { id: '-5', left: null, right: null, value: -5 },
            { id: '20', left: null, right: null, value: 20 },
          ],
          root: '3',
        },
      },
      {
        tree: {
          nodes: [
            { id: '3', left: '8', right: '2', value: 3 },
            { id: '8', left: '2-2', right: '9', value: 8 },
            { id: '2', left: '1', right: '4', value: 2 },
            { id: '2-2', left: '1-1', right: null, value: 2 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '1-1', left: '-1', right: null, value: 1 },
            { id: '-1', left: '-5', right: '-4', value: -1 },
            { id: '-5', left: null, right: null, value: -5 },
            { id: '-4', left: null, right: null, value: -4 },
          ],
          root: '3',
        },
      },
      {
        tree: {
          nodes: [
            { id: '3', left: '8', right: '2', value: 3 },
            { id: '8', left: '2-2', right: '9', value: 8 },
            { id: '2', left: '1', right: '4', value: 2 },
            { id: '2-2', left: '15', right: null, value: 2 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '15', left: '18', right: null, value: 15 },
            { id: '18', left: '16', right: '20', value: 18 },
            { id: '16', left: null, right: null, value: 16 },
            { id: '20', left: null, right: null, value: 20 },
          ],
          root: '3',
        },
      },
      {
        tree: {
          nodes: [
            { id: '3', left: '8', right: '2', value: 3 },
            { id: '8', left: '2-2', right: '9', value: 8 },
            { id: '2', left: '1', right: '4', value: 2 },
            { id: '2-2', left: '-2', right: '30', value: 2 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '-2', left: '18', right: null, value: -2 },
            { id: '18', left: '16', right: '20', value: 18 },
            { id: '16', left: null, right: null, value: 16 },
            { id: '20', left: null, right: null, value: 20 },
            { id: '30', left: null, right: null, value: 30 },
          ],
          root: '3',
        },
      },
      {
        tree: {
          nodes: [
            { id: '3', left: '8', right: '2', value: 3 },
            { id: '8', left: '2-2', right: null, value: 8 },
            { id: '2', left: '1', right: '4', value: 2 },
            { id: '2-2', left: '-2', right: '30', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '-2', left: '18', right: null, value: -2 },
            { id: '18', left: '16', right: '20', value: 18 },
            { id: '16', left: null, right: null, value: 16 },
            { id: '20', left: null, right: null, value: 20 },
            { id: '30', left: null, right: null, value: 30 },
          ],
          root: '3',
        },
      },
      {
        tree: {
          nodes: [
            { id: '3', left: '8', right: '2', value: 3 },
            { id: '8', left: '2-2', right: '7', value: 8 },
            { id: '2', left: '1', right: '4', value: 2 },
            { id: '2-2', left: '-2', right: '30', value: 2 },
            { id: '7', left: null, right: null, value: 7 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '4', left: null, right: null, value: 4 },
            { id: '-2', left: '18', right: null, value: -2 },
            { id: '18', left: '16', right: '20', value: 18 },
            { id: '16', left: null, right: null, value: 16 },
            { id: '20', left: null, right: null, value: 20 },
            { id: '30', left: null, right: null, value: 30 },
          ],
          root: '3',
        },
      },
      {
        tree: {
          nodes: [
            { id: '8', left: '2', right: '9', value: 8 },
            { id: '2', left: '1', right: '10', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '10', left: null, right: null, value: 10 },
            { id: '9', left: null, right: null, value: 9 },
          ],
          root: '8',
        },
      },
      {
        tree: {
          nodes: [
            { id: '8', left: '2', right: '9', value: 8 },
            { id: '2', left: '1', right: '-5', value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '-5', left: null, right: null, value: -5 },
            { id: '9', left: null, right: '12', value: 9 },
            { id: '12', left: null, right: null, value: 12 },
          ],
          root: '8',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '6', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '6', left: '1-2', right: null, value: 6 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '3', left: '-8', right: '0', value: 3 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7', right: '0-2', value: 0 },
            { id: '-7', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '6', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '6', left: '1-2', right: null, value: 6 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '10', value: 1 },
            { id: '10', left: '5', right: '23', value: 10 },
            { id: '23', left: '13', right: '22', value: 23 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '3', left: '-8', right: '0', value: 3 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7', right: '0-2', value: 0 },
            { id: '-7', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '6', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '6', left: '1-2', right: null, value: 6 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '10', value: 1 },
            { id: '10', left: '5', right: '23', value: 10 },
            { id: '23', left: '13', right: '22', value: 23 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '3', left: '-8', right: '0', value: 3 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7', right: '-5', value: 0 },
            { id: '-7', left: null, right: null, value: -7 },
            { id: '-5', left: null, right: null, value: -5 },
            { id: '5', left: '6', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '6', left: '1-2', right: null, value: 6 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '1', left: '3', right: '10', value: 1 },
            { id: '10', left: '5', right: '23', value: 10 },
            { id: '23', left: '19', right: '22', value: 23 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '19', left: null, right: '14', value: 19 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '3', left: '-8', right: '0', value: 3 },
            { id: '-8', left: '-3', right: null, value: -8 },
            { id: '-3', left: null, right: null, value: -3 },
            { id: '0', left: '-7', right: '-5', value: 0 },
            { id: '-7', left: null, right: null, value: -7 },
            { id: '-5', left: null, right: null, value: -5 },
            { id: '5', left: '6', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '6', left: '99', right: null, value: 6 },
            { id: '99', left: null, right: null, value: 99 },
          ],
          root: '1',
        },
      },
      {
        tree: {
          nodes: [
            { id: '100', left: '1', right: null, value: 100 },
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-100', left: '1', right: null, value: -100 },
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '-100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-100', left: null, right: '1', value: -100 },
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '-100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-100', left: null, right: '-99', value: -100 },
            { id: '-99', left: null, right: '-98', value: -99 },
            { id: '-98', left: null, right: '-97', value: -98 },
            { id: '-97', left: null, right: '1', value: -97 },
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '-100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-100', left: null, right: '-99', value: -100 },
            { id: '-99', left: null, right: '-98', value: -99 },
            { id: '-98', left: null, right: '-97', value: -98 },
            { id: '-97', left: null, right: '-98-2', value: -97 },
            { id: '-98-2', left: '-7', right: '10', value: -98 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '-100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-100', left: null, right: '-99', value: -100 },
            { id: '-99', left: null, right: '-98', value: -99 },
            { id: '-98', left: null, right: '-97', value: -98 },
            { id: '-97', left: null, right: '1', value: -97 },
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '12', value: 13 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: null, value: 1 },
          ],
          root: '-100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-100', left: null, right: '-99', value: -100 },
            { id: '-99', left: null, right: '-98', value: -99 },
            { id: '-98', left: null, right: '-97', value: -98 },
            { id: '-97', left: null, right: '1', value: -97 },
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '12', value: 13 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: null, right: '1-5', value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
          ],
          root: '-100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '-100', left: null, right: '-99', value: -100 },
            { id: '-99', left: null, right: '-98', value: -99 },
            { id: '-98', left: null, right: '-97', value: -98 },
            { id: '-97', left: null, right: '1', value: -97 },
            { id: '1', left: '-7', right: '10', value: 1 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '22', left: null, right: null, value: 22 },
            { id: '13', left: null, right: '12', value: 13 },
            { id: '12', left: null, right: null, value: 12 },
            { id: '-7', left: '-8', right: '0', value: -7 },
            { id: '-8', left: '-9', right: null, value: -8 },
            { id: '-9', left: null, right: null, value: -9 },
            { id: '0', left: '-7-2', right: '0-2', value: 0 },
            { id: '-7-2', left: null, right: null, value: -7 },
            { id: '0-2', left: null, right: null, value: 0 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '2', left: '1-2', right: null, value: 2 },
            { id: '1-2', left: null, right: '1-3', value: 1 },
            { id: '1-3', left: null, right: '1-4', value: 1 },
            { id: '1-4', left: '1-5', right: null, value: 1 },
            { id: '1-5', left: null, right: null, value: 1 },
          ],
          root: '-100',
        },
      },
      {
        tree: {
          nodes: [
            { id: '20', left: '7', right: '10', value: 20 },
            { id: '7', left: '0', right: '8', value: 7 },
            { id: '0', left: null, right: null, value: 0 },
            { id: '8', left: '7-2', right: '9', value: 8 },
            { id: '7-2', left: null, right: null, value: 7 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '5', left: '2', right: '5-2', value: 5 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '15', left: '13', right: '22', value: 15 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '22', left: null, right: null, value: 22 },
          ],
          root: '20',
        },
      },
      {
        tree: {
          nodes: [
            { id: '20', left: '9', right: '10', value: 20 },
            { id: '9', left: '0', right: '8', value: 9 },
            { id: '0', left: null, right: null, value: 0 },
            { id: '8', left: '7-2', right: null, value: 8 },
            { id: '7-2', left: null, right: null, value: 7 },
            { id: '10', left: '6', right: '15', value: 10 },
            { id: '6', left: '2', right: '5', value: 6 },
            { id: '2', left: '1', right: null, value: 2 },
            { id: '1', left: null, right: null, value: 1 },
            { id: '5', left: null, right: null, value: 5 },
            { id: '15', left: '17', right: '22', value: 15 },
            { id: '17', left: null, right: '14', value: 17 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '22', left: null, right: null, value: 22 },
          ],
          root: '20',
        },
      },
      {
        tree: {
          nodes: [
            { id: '20', left: '7', right: '10', value: 20 },
            { id: '7', left: '2', right: '8', value: 7 },
            { id: '2', left: null, right: null, value: 2 },
            { id: '8', left: '7-2', right: '9', value: 8 },
            { id: '7-2', left: null, right: null, value: 7 },
            { id: '9', left: null, right: null, value: 9 },
            { id: '10', left: '5', right: '15', value: 10 },
            { id: '5', left: '2-2', right: '5-2', value: 5 },
            { id: '2-2', left: null, right: null, value: 2 },
            { id: '5-2', left: null, right: null, value: 5 },
            { id: '15', left: '13', right: '8-2', value: 15 },
            { id: '13', left: null, right: '14', value: 13 },
            { id: '14', left: null, right: null, value: 14 },
            { id: '8-2', left: null, right: null, value: 8 },
          ],
          root: '20',
        },
      },
    ],
  },
];

module.exports = {
  questions,
};
